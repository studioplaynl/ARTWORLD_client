{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. ARTWORLD Documentation Todo: - [ ] copy paste wordpress pages https://github.com/lonekorean/wordpress-export-to-markdown [ ] copy paste nextcloud pages","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"#artworld-documentation","text":"Todo: - [ ] copy paste wordpress pages https://github.com/lonekorean/wordpress-export-to-markdown [ ] copy paste nextcloud pages","title":"ARTWORLD Documentation"},{"location":"1.%20implementation/0-List-of-tasks/","text":"UPGRADE PHASER with Fabric Fabric with eraser breaks Possible solution: https://github.com/fabricjs/fabric.js/issues/7171 https://www.npmjs.com/package/fabric-with-erasing 826 van-der-glaskunstlab kinderen-4-t-m-12-amif 55210352 - KUNSTLAB DIGITAAL Implementeren ontwerp uren Amersfoort implementeren Max' ontwerp 3,6u Middelburg implementeren Max' ontwerp 3,6u Cranendonckimplementeren Max' ontwerp 3,6u Katwijkimplementeren Max' ontwerp 3,6u Gilze implementeren Max' ontwerp 3,6u Beginwereld duidelijker maken 5u Beginwereld aanpassen 8u 3D dierentuin en bloementuin plaatsen 10u Interieur huis uren Huis inrichten 34u Navigatie UI uren Duidelijk maken in de werelden waar je bent 20u Navigatie bar aanpassen 6u Teken APP uren Tekenapp opschonen 12u Nieuwe tekening maken. weg in de tekenapp 6u Oplossen pipet bug 4u pijltje terug in tekening- en stopmotion app 1u Player uren Avatar kan in interactie een beweging maken 12u ItemsBar Notifications uren Meldingen kenbaar maken in itemsbar als je post of een like of vriendschapsverzoek hebt 20u Update Phaser uren update de game engine 10u Divers uren overleg en afstemming 2u documentatie en oplevering overleg 4u Toelichting op design: docs.google Link naar overzicht starten ARTWORLD: design.penpot","title":"0 List of tasks"},{"location":"1.%20implementation/Avatar/","text":"avatars are being saved as 64x64 pixels and the url gets placed in users profile under avatar. the json file still gets saved as 2048x2048, every extra frame adds 2048 pixels to the width of the image. So for the future: save avatars in a storage objects and when chosen, convert to correct size and save in avatar url on profile storage object contains: frames png url json url version convert image function, split x and y sizing for adaptive scaling","title":"Avatar"},{"location":"1.%20implementation/BetaWorld/","text":"domain names clone of ARTWORLD used for development and testing nakama server / nakama.svelte betanakama.toekomst.school Visit betaworld: https://betaworld.toekomst.school log out / in when switching from nakama.toekomst.school to betanakama.toekomst.school current VPS Contabo VPS S 4 vCPU Cores 8 GB RAM 50 GB NVMe or 200 GB SSD 32 TB Traffic Unlimited Incoming IP: 185.193.67.152","title":"domain names"},{"location":"1.%20implementation/BetaWorld/#domain-names","text":"clone of ARTWORLD used for development and testing nakama server / nakama.svelte betanakama.toekomst.school Visit betaworld: https://betaworld.toekomst.school","title":"domain names"},{"location":"1.%20implementation/BetaWorld/#log-out-in","text":"when switching from nakama.toekomst.school to betanakama.toekomst.school","title":"log out / in"},{"location":"1.%20implementation/BetaWorld/#current-vps","text":"Contabo VPS S 4 vCPU Cores 8 GB RAM 50 GB NVMe or 200 GB SSD 32 TB Traffic Unlimited Incoming IP: 185.193.67.152","title":"current VPS"},{"location":"1.%20implementation/Chat-Message-Functionality/","text":"","title":"Chat Message Functionality"},{"location":"1.%20implementation/Compression-Tests-Images/","text":"We get the following results from the comparison of png and jpg image formats to heic, avif and webp. Artworld.png is converted to the respective image formats, and we get the following sizes |Format|Size of image (KB)|Size respectively to the png file| |-|:-:|-:| |PNG|33|100%| |HEIC|12|36%| |AVIF|10|30%| |WEBP|32|97%| Based on the doodle picture from location1 e13\u2026ff2.jpg |Format|Size of image (KB)|Size respectively to the jpg file| |-|:-:|-:| |JPG|33|100%| |HEIC|19|58%| |AVIF|31|94%| |WEBP|25|76%| Based on museum.png from location1 |Format|Size of image (KB)|Size respectively to the png file| |-|:-:|-:| |PNG|25|100%| |HEIC|11|44%| |AVIF|2|8%| |WEBP|27|108%| We get the following results on rendering in location1 Heic https://user-images.githubusercontent.com/71214731/145584124-cbe05ea9-e995-4e2c-bfff-1a33017d28e8.png No image is rendered. Avif https://user-images.githubusercontent.com/71214731/145584135-8b55f81d-28f0-45c9-b705-909efdfcbdd1.png Some images get the black background color after conversion, some does not display at all. Webp https://user-images.githubusercontent.com/71214731/145584140-3ca3ee14-81d6-41ce-91a1-2f3c43f690ef.png All images are displayed as they are supposed. This format can be used to be able to load an image from several alternative formats according to browser support \"this.load.image('museum', [ 'museum.webp', 'museum.avif', 'museum.png' ]);\"","title":"Compression Tests Images"},{"location":"1.%20implementation/Compression-Tests-Images/#we-get-the-following-results-from-the-comparison-of-png-and-jpg-image-formats-to-heic-avif-and-webp","text":"Artworld.png is converted to the respective image formats, and we get the following sizes |Format|Size of image (KB)|Size respectively to the png file| |-|:-:|-:| |PNG|33|100%| |HEIC|12|36%| |AVIF|10|30%| |WEBP|32|97%| Based on the doodle picture from location1 e13\u2026ff2.jpg |Format|Size of image (KB)|Size respectively to the jpg file| |-|:-:|-:| |JPG|33|100%| |HEIC|19|58%| |AVIF|31|94%| |WEBP|25|76%| Based on museum.png from location1 |Format|Size of image (KB)|Size respectively to the png file| |-|:-:|-:| |PNG|25|100%| |HEIC|11|44%| |AVIF|2|8%| |WEBP|27|108%|","title":"We get the following results from the comparison of png and jpg image formats to heic, avif and webp."},{"location":"1.%20implementation/Compression-Tests-Images/#we-get-the-following-results-on-rendering-in-location1","text":"Heic https://user-images.githubusercontent.com/71214731/145584124-cbe05ea9-e995-4e2c-bfff-1a33017d28e8.png No image is rendered. Avif https://user-images.githubusercontent.com/71214731/145584135-8b55f81d-28f0-45c9-b705-909efdfcbdd1.png Some images get the black background color after conversion, some does not display at all. Webp https://user-images.githubusercontent.com/71214731/145584140-3ca3ee14-81d6-41ce-91a1-2f3c43f690ef.png All images are displayed as they are supposed.","title":"We get the following results on rendering in location1"},{"location":"1.%20implementation/Compression-Tests-Images/#this-format-can-be-used-to-be-able-to-load-an-image-from-several-alternative-formats-according-to-browser-support","text":"\"this.load.image('museum', [ 'museum.webp', 'museum.avif', 'museum.png' ]);\"","title":"This format can be used to be able to load an image from several alternative formats according to browser support"},{"location":"1.%20implementation/Conventions/","text":"Naming Conventions Filenames and Classnames are the same Class names start with capital Letter File, Scene and Key names are the same Function names are camelCased","title":"Conventions"},{"location":"1.%20implementation/Conventions/#naming-conventions","text":"Filenames and Classnames are the same Class names start with capital Letter File, Scene and Key names are the same Function names are camelCased","title":"Naming Conventions"},{"location":"1.%20implementation/Coordinate-System-Conversion/","text":"Coordinate system Conversion ARTWORLD needs to be able to grow from time to time. It is better to have worlds where 0, 0 is the center, because then coordinates remain valid when worlds become bigger. 0 , 0 is still the center etc This means that there needs to be a conversion between what I call ARTWORLDcoordinates (0, 0 is center) and phaser2Dcoordinates(0,0 is top left) It is a simple conversion when we know the worldSize. artworldVectorToPhaser2D(worldSize, positionVector) { const worldSizeX = worldSize.x const worldSizeY = worldSize.y positionVector.x = positionVector.x + (worldSizeX / 2) positionVector.y = positionVector.y + (worldSizeY / 2) return positionVector } Phaser2DVectorToArtworld(worldSize, x, y) { // usage: // pass the worldSize and the coordinates you want to do the calculation on // output is a Vector const worldSizeX = worldSize.x const worldSizeY = worldSize.y positionVector.x = positionVector.x - (worldSizeX / 2) positionVector.y = positionVector.y - (worldSizeY / 2) return positionVector } So we need to define a wordSize(x,y) in each scene, this way our ARTWORLDcoordinates stay consistent. ARTWORLDcoordinates are especially important when we think where to place 'houses', artworks, etc, and when we store the last position of the player. Conventions to make this system work In Phaser everything works with Phaser2Dcoordinates We design worlds with ARTWORLDcoordinates On the server we store everything in ARTWROLDcoordinates, so that everything is placed as designed, also when the world has grown in each direction That means that coordinates only have to be converted when sending it over the network, and when receiving coordinates over the networks. Also when we place Locations we do it with ARTWORLDcoordinates, and we convert them to Phaser2Dcoordinates when passing arguments. Then Phaser just deals with them as Phaser2Dcoordinates In practice what we have to do when making a scene: import CoordinatesTranslator from \"../class/CoordinatesTranslator.js\" define globally: this.worldSize = new Phaser.Math.Vector2(3000, 3000) define locations with ARTWORLDcoordinates this.location1 = this.add.isotriangle(CoordinatesTranslator.artworldToPhaser2D(this.worldSize.x, -200), CoordinatesTranslator.artworldToPhaser2D(this.worldSize.y, 200), 150, 150, false, 0x8dcb0e, 0x3f8403, 0x63a505) Behind the scenes coordinates are converted here: When the player avatar is loaded from the server, the last know position is also retreived in Player.js attachAvatarToPlayer //*place the player in the last known position scene.player.x = translateCoordinates.artworldToPhaser2D(this.worldSize.x, this.player.posX) scene.player.y = translateCoordinates.artworldToPhaser2D(this.worldSize.y, this.player.posY) When we send Player movement over the network It is not yet converted in the Player.js, but it will be converted in ManageSession.sendMoveMessage, so we pass scene, to know worldSize later on. in Player.js sendMovement(scene) { if (scene.createdPlayer) { if ( ManageSession.updateMovementTimer > ManageSession.updateMovementInterval ) { //send the player position as artworldCoordinates, because we store in artworldCoordinates on the server ManageSession.sendMoveMessage(scene, scene.player.x, scene.player.y) ManageSession.updateMovementTimer = 0 } } } In ManageSession.sendMoveMessage `sendMoveMessage(scene, posX, posY) { //transpose phaser coordinates to artworld coordinates //console.log(scene) posX = CoordinatesTranslator.Phaser2DToArtworld(scene.worldSize.x, posX) posY = CoordinatesTranslator.Phaser2DToArtworld(scene.worldSize.y, posY) var opCode = 1; var data = '{ \"posX\": ' + posX + ', \"posY\": ' + posY + ', \"location\": \"' + this.location + '\" }' this.socket.rpc(\"move_position\", data) }`","title":"Coordinate System Conversion"},{"location":"1.%20implementation/Coordinate-System-Conversion/#conventions-to-make-this-system-work","text":"In Phaser everything works with Phaser2Dcoordinates We design worlds with ARTWORLDcoordinates On the server we store everything in ARTWROLDcoordinates, so that everything is placed as designed, also when the world has grown in each direction That means that coordinates only have to be converted when sending it over the network, and when receiving coordinates over the networks. Also when we place Locations we do it with ARTWORLDcoordinates, and we convert them to Phaser2Dcoordinates when passing arguments. Then Phaser just deals with them as Phaser2Dcoordinates In practice what we have to do when making a scene: import CoordinatesTranslator from \"../class/CoordinatesTranslator.js\" define globally: this.worldSize = new Phaser.Math.Vector2(3000, 3000) define locations with ARTWORLDcoordinates this.location1 = this.add.isotriangle(CoordinatesTranslator.artworldToPhaser2D(this.worldSize.x, -200), CoordinatesTranslator.artworldToPhaser2D(this.worldSize.y, 200), 150, 150, false, 0x8dcb0e, 0x3f8403, 0x63a505) Behind the scenes coordinates are converted here: When the player avatar is loaded from the server, the last know position is also retreived in Player.js attachAvatarToPlayer //*place the player in the last known position scene.player.x = translateCoordinates.artworldToPhaser2D(this.worldSize.x, this.player.posX) scene.player.y = translateCoordinates.artworldToPhaser2D(this.worldSize.y, this.player.posY) When we send Player movement over the network It is not yet converted in the Player.js, but it will be converted in ManageSession.sendMoveMessage, so we pass scene, to know worldSize later on. in Player.js sendMovement(scene) { if (scene.createdPlayer) { if ( ManageSession.updateMovementTimer > ManageSession.updateMovementInterval ) { //send the player position as artworldCoordinates, because we store in artworldCoordinates on the server ManageSession.sendMoveMessage(scene, scene.player.x, scene.player.y) ManageSession.updateMovementTimer = 0 } } } In ManageSession.sendMoveMessage `sendMoveMessage(scene, posX, posY) { //transpose phaser coordinates to artworld coordinates //console.log(scene) posX = CoordinatesTranslator.Phaser2DToArtworld(scene.worldSize.x, posX) posY = CoordinatesTranslator.Phaser2DToArtworld(scene.worldSize.y, posY) var opCode = 1; var data = '{ \"posX\": ' + posX + ', \"posY\": ' + posY + ', \"location\": \"' + this.location + '\" }' this.socket.rpc(\"move_position\", data) }`","title":"Conventions to make this system work"},{"location":"1.%20implementation/Create_and_update_SERVER_OBJECT_examples/","text":"To retreive objects (eg addressbook) from the server, works like this: listObjects(\"addressbook\", ManageSession.userProfile.id, 10) We get back an array of max 10 (in this case) objects that have \"addressbook\" as collection value. For example: 0: 0: {collection: 'addressbook', key: 'address_f42eb28f-9f4d-476c-9788-2240bac4cf48', permission_read: 2, permission_write: 1, value: {\u2026}, \u2026} 1: {collection: 'addressbook', key: 'addressbook_5264dc23-a339-40db-bb84-e0849ded4e68', permi... We have an array with an array of objects (because in this case we have multiple addressbooks, most of the time we have only one). Even if there is only one object coming back it will be in the form of: [0][0] The first array is standard, the second array is the array of objects we are looking for. Inside the array we can query the values of the object with dot notation. In the case of retreiving the value: [0][1].value The object ( on the [0][0] level) looks in detail like: { collection: \"addressbook\", create_time: \"2021-12-23T13:20:46Z\", key: \"address_f42eb28f-9f4d-476c-9788-2240bac4cf48\", permission_read: 2, permission_write: 1, update_time: \"2021-12-23T16:09:10Z\", user_id: \"f42eb28f-9f4d-476c-9788-2240bac4cf48\", value: {user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\", user_name: \"user11\"}, version: \"99914b932bd37a50b983c5e7c90ae93b\" } Examples Locations OBJECT Heart / Like button Object","title":"Create and update SERVER OBJECT examples"},{"location":"1.%20implementation/Create_onlinePlayers_diagram/","text":"","title":"Create onlinePlayers diagram"},{"location":"1.%20implementation/Depth_of_elements_in_game/","text":"Float on top: Menu item (all DOM Elements) UI Scene: zoom icons background: 10, order by creation order locations: 30-50 * location: 30 * namePlate: 31 * userIcon: 31 * locationDescription: 32 * locationEnterButton: 500 (above the player(s) and playerItemBar(s) artWorks and likeButton: 100 (they are in the same container) spinner: 199 player: 201 playerShadow: 200 onlinePlayer: 200 movementDetectLayer: 219 playerItemsBar: 220 - 300 onlinePlayerItemsBar: 301 - 499 (above the playerItemsBar)","title":"Depth of elements in game"},{"location":"1.%20implementation/Download_art_Images_flow/","text":"Eg a list of images to show in the billBoards, eg a rotating selection of liked images of the player. create an array of liked images in the array scene.AbriImages A if the key doesn't exist: Download the image B if the image can't be downloaded, skip the item, remove it from the array create an array with the image keys and sizes","title":"Download art Images flow"},{"location":"1.%20implementation/HistoryTracker-and-the-Back-button/","text":"Locations and Homes There are two types of scenes that players can enter: locations and homes. In cases when it is a location, this.location contains the scene name, while for a home, it contains the home's unique ID. History Tracker The class of History Tracker has two methods: locationPush and homePush . As the names suggest, when a player enters a location, a value of that location is pushed to the array of ManageSession.locationHistory , and when one gets into a home, an object with two properties is pushed to the same array: { locationName: \"DefaultUserHome\", homeID: scene.location } Both methods have a condition, they should not be matching the value of the previous scene. Otherwise, a player gets into an infinite loop when using the back button. Back button On clicking of the back button, the last element of the array of ManageSession.locationHistory is taken in order to leave the current scene and stop the current scene: let currentLocationKey = ManageSession.locationHistory.pop() ... ManageSession.socket.rpc(\"leave\", currentLocationKey) ... this.scene.stop(currentLocationKey) But before leaving the scene, we check whether the scene is a location or a house: if (currentLocationKey.locationName && currentLocationKey.homeID) { currentLocationKey = currentLocationKey.locationName } if it is a house, then we reassign the value of the currentLocationKey. And for entering the previous scene, we take the last element of the array of ManageSession.locationHistory and join it: let previousLocation = ManageSession.locationHistory[ManageSession.locationHistory.length - 1] ... ManageSession.getStreamUsers(\"join\", previousLocation) We also check whether the previous scene is a location or a house: let homeID = null if (previousLocation.locationName && previousLocation.homeID) { homeID = previousLocation.homeID previousLocation = previousLocation.locationName } For starting the previous scene, we provide two arguments, and the second argument is ignored when the scene is a location, not a home. this.scene.start(previousLocation, { user_id: homeID })","title":"HistoryTracker and the Back button"},{"location":"1.%20implementation/HistoryTracker-and-the-Back-button/#locations-and-homes","text":"There are two types of scenes that players can enter: locations and homes. In cases when it is a location, this.location contains the scene name, while for a home, it contains the home's unique ID.","title":"Locations and Homes"},{"location":"1.%20implementation/HistoryTracker-and-the-Back-button/#history-tracker","text":"The class of History Tracker has two methods: locationPush and homePush . As the names suggest, when a player enters a location, a value of that location is pushed to the array of ManageSession.locationHistory , and when one gets into a home, an object with two properties is pushed to the same array: { locationName: \"DefaultUserHome\", homeID: scene.location } Both methods have a condition, they should not be matching the value of the previous scene. Otherwise, a player gets into an infinite loop when using the back button.","title":"History Tracker"},{"location":"1.%20implementation/HistoryTracker-and-the-Back-button/#back-button","text":"On clicking of the back button, the last element of the array of ManageSession.locationHistory is taken in order to leave the current scene and stop the current scene: let currentLocationKey = ManageSession.locationHistory.pop() ... ManageSession.socket.rpc(\"leave\", currentLocationKey) ... this.scene.stop(currentLocationKey) But before leaving the scene, we check whether the scene is a location or a house: if (currentLocationKey.locationName && currentLocationKey.homeID) { currentLocationKey = currentLocationKey.locationName } if it is a house, then we reassign the value of the currentLocationKey. And for entering the previous scene, we take the last element of the array of ManageSession.locationHistory and join it: let previousLocation = ManageSession.locationHistory[ManageSession.locationHistory.length - 1] ... ManageSession.getStreamUsers(\"join\", previousLocation) We also check whether the previous scene is a location or a house: let homeID = null if (previousLocation.locationName && previousLocation.homeID) { homeID = previousLocation.homeID previousLocation = previousLocation.locationName } For starting the previous scene, we provide two arguments, and the second argument is ignored when the scene is a location, not a home. this.scene.start(previousLocation, { user_id: homeID })","title":"Back button"},{"location":"1.%20implementation/Home-and-server-OBJECT/","text":"home object: collection: \"home\" create_time: \"2022-01-19T16:31:43Z\" key: \"Amsterdam\" permission_read: 2 permission_write: 1 update_time: \"2022-01-19T16:32:27Z\" user_id: \"4c0003f0-3e3f-4b49-8aad-10db98f2d3dc\" value: posX: 184.83 posY: 312.66 url: \"home/stock/portalBlauw.png\" username: \"user22\" version: 0 version: \"0579e989a16f3e228a10d49d13dc3da6\" Get array of home objects => create home array scene.homes // scene.homesRepresented = [] filter by key = location (eg Amsterdam) => scene.homes A download the images B if image can't be downloaded, use a placeholder (should we also send a noticifation to admin?) create the home in an array scene.homesRepresented and in the scene with the image key, and posX posY from scene.homes, with the class GenerateLocation In Phaser we get a global download error event, so we are handling that in a special way: await convertImage(url, \"128\", \"png\") .then((rec) => { //console.log(\"rec\", rec) // load all the images to phaser scene.load.image(homeImageKey, rec) .on(`filecomplete-image-${homeImageKey}`, (homeImageKey) => { //delete from this.resolveErrorObjectArray this.resolveErrorObjectArray = this.resolveErrorObjectArray.filter((obj) => obj.imageKey !== homeImageKey) // console.log(\"this.resolveErrorObjectArray\", this.resolveErrorObjectArray) //create the home this.createHome(element, index, homeImageKey, scene) }, this) // put the file in the loadErrorCache, in case it doesn't load, it get's removed when it is loaded successfully this.resolveErrorObjectArray.push({ loadFunction: \"getHomeImage\", element: element, index: index, imageKey: homeImageKey, scene: scene }) scene.load.start() // start loading the image in memory }) We push the element we want to download into a global resolveErrorObjectArray with all the relevant information: 1. the element (object) 2. the index of the array it is being handled in 3. the imageKey that is already generated in the context 4. the scene it is being used in 5. the loadFunction The loadFunction we use in the error handling function to inject the image in the right array and function to that the image is put in the right place: resolveLoadError(offendingFile) { // element, index, homeImageKey, offendingFile, scene this.resolveErrorObjectArray //all loading images let resolveErrorObject = this.resolveErrorObjectArray.find(o => o.imageKey == offendingFile.key) let loadFunction = resolveErrorObject.loadFunction let element = resolveErrorObject.element let index = resolveErrorObject.index let imageKey = offendingFile.key let scene = resolveErrorObject.scene // console.log(\"element, index, homeImageKey, offendingFile, scene\", element, index, imageKey, scene) switch (loadFunction) { case (\"getHomeImage\"): console.log(\"load offendingFile again\", imageKey) scene.load.image(imageKey, './assets/ball_grey.png') .on(`filecomplete-image-${imageKey}`, (imageKey) => { //delete from this.resolveErrorObjectArray this.resolveErrorObjectArray = this.resolveErrorObjectArray.filter((obj) => obj.imageKey !== imageKey) console.log(\"this.resolveErrorObjectArray\", this.resolveErrorObjectArray) //create the home this.createHome(element, index, imageKey, scene); }, this) scene.load.start() break default: console.log(\"please state fom which function the loaderror occured!\") } }","title":"Home and server OBJECT"},{"location":"1.%20implementation/Home/","text":"Welcome to the ARTWORLD_client wiki! Overview Network Flow Client side Server API calls","title":"Home"},{"location":"1.%20implementation/How_to_deploy_artworld/","text":"How to deploy ARTWORLD up to date Linux machine (with correct security in place!) (contabo/digital ocean) nginx docker golang basic linux experience startup sudo apt-get install docker docker-compose nginx golang certbot node npm unzip client code clone ARTWORLD_client code to /var/www/artworld/ mkdir /var/www/artworld cd /var/www/artworld wget https://github.com/studioplaynl/ARTWORLD_client/archive/refs/heads/main.zip unzip main mv ARTWORLD_client-main/ ARTWORLD_client cd ARTWORLD_client/ npm install npm run build -edit your server domain name in ./src/nakama.svelte get nginx up and running: start by editing /var/www/nginx with the correct domain and folder settings sudo cp /var/www/nginx /etc/nginx/sites-enabled/artworld sudo systemctl restart nginx set your dns settings to point the domain to the correct IP adress get certbot for a certificate(as shown in the config example) now you can test the domain and see if the clientside code is up and running. server code clone the artworld server code to your home directory edit config.yml if necessary go mod vendor npm run docker server should be live now. clone to betaworld server this has als9o been automated as a cron job, running at 1am each day sudo docker commit artworld_nakama_server_nakama_1 artworld_nakama sudo docker save artworld_nakama | gzip | ssh root@185.193.67.152 'gunzip | docker load' sudo docker commit artworld_nakama_server_postgres_1 artworld_postgres sudo docker save artworld_postgres | gzip | ssh root@185.193.67.152 'gunzip | docker load' Amazon AWS Create a S3 bucket in Amazon AWS for storage of files. object ownership: ACLs enabled(object writer) block public acces: block all bucket versioning: disabled tag: none encryption: disabled advanced settings: disabled cors settings: [ { \"AllowedHeaders\": [ \"*\" ], \"AllowedMethods\": [ \"PUT\", \"HEAD\", \"GET\" ], \"AllowedOrigins\": [ \"https://yourdomain.com\" ], \"ExposeHeaders\": [] } ] create access key: click right top username > security credentials create user(permission: AWSS3FullAcces) create in the nakama server folder the file named \"credentials\" [default] aws_access_key_id = \"youracceskeyid\" aws_secret_access_key = \"youracceskey\" update main.go const ( AWS_S3_REGION = \"your region\" AWS_S3_BUCKET = \"your bucket\" ) AWS image converter: this is needed for converting images to the correct sizes incl. caching to setup: https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/deployment.html - press launch solution - choose correct location in top right! - choose following settings: AutoWebP No - CorsEnabled Yes - CorsOrigin https://yourwebsite.com - DeployDemoUI No - EnableDefaultFallbackImage No - EnableSignature Yes - FallbackImageS3Bucket - - FallbackImageS3Key - - LogRetentionPeriod 1 - SecretsManagerKey your secret key - SecretsManagerSecret your secret secret - SourceBuckets artworldstudioplay - to create a secret go to: secretsmanager https://eu-central-1.console.aws.amazon.com/secretsmanager/home?region=eu-central-1#!/listSecrets/ - other type of secret - fill in key and value troubleshoot","title":"How to deploy ARTWORLD"},{"location":"1.%20implementation/How_to_deploy_artworld/#how-to-deploy-artworld","text":"up to date Linux machine (with correct security in place!) (contabo/digital ocean) nginx docker golang basic linux experience","title":"How to deploy ARTWORLD"},{"location":"1.%20implementation/How_to_deploy_artworld/#startup","text":"sudo apt-get install docker docker-compose nginx golang certbot node npm unzip","title":"startup"},{"location":"1.%20implementation/How_to_deploy_artworld/#client-code","text":"clone ARTWORLD_client code to /var/www/artworld/ mkdir /var/www/artworld cd /var/www/artworld wget https://github.com/studioplaynl/ARTWORLD_client/archive/refs/heads/main.zip unzip main mv ARTWORLD_client-main/ ARTWORLD_client cd ARTWORLD_client/ npm install npm run build -edit your server domain name in ./src/nakama.svelte","title":"client code"},{"location":"1.%20implementation/How_to_deploy_artworld/#get-nginx-up-and-running","text":"start by editing /var/www/nginx with the correct domain and folder settings sudo cp /var/www/nginx /etc/nginx/sites-enabled/artworld sudo systemctl restart nginx set your dns settings to point the domain to the correct IP adress get certbot for a certificate(as shown in the config example) now you can test the domain and see if the clientside code is up and running.","title":"get nginx up and running:"},{"location":"1.%20implementation/How_to_deploy_artworld/#server-code","text":"clone the artworld server code to your home directory edit config.yml if necessary go mod vendor npm run docker server should be live now.","title":"server code"},{"location":"1.%20implementation/How_to_deploy_artworld/#clone-to-betaworld-server","text":"this has als9o been automated as a cron job, running at 1am each day sudo docker commit artworld_nakama_server_nakama_1 artworld_nakama sudo docker save artworld_nakama | gzip | ssh root@185.193.67.152 'gunzip | docker load' sudo docker commit artworld_nakama_server_postgres_1 artworld_postgres sudo docker save artworld_postgres | gzip | ssh root@185.193.67.152 'gunzip | docker load'","title":"clone to betaworld server"},{"location":"1.%20implementation/How_to_deploy_artworld/#amazon-aws","text":"Create a S3 bucket in Amazon AWS for storage of files. object ownership: ACLs enabled(object writer) block public acces: block all bucket versioning: disabled tag: none encryption: disabled advanced settings: disabled cors settings: [ { \"AllowedHeaders\": [ \"*\" ], \"AllowedMethods\": [ \"PUT\", \"HEAD\", \"GET\" ], \"AllowedOrigins\": [ \"https://yourdomain.com\" ], \"ExposeHeaders\": [] } ] create access key: click right top username > security credentials create user(permission: AWSS3FullAcces) create in the nakama server folder the file named \"credentials\" [default] aws_access_key_id = \"youracceskeyid\" aws_secret_access_key = \"youracceskey\" update main.go const ( AWS_S3_REGION = \"your region\" AWS_S3_BUCKET = \"your bucket\" )","title":"Amazon AWS"},{"location":"1.%20implementation/How_to_deploy_artworld/#aws-image-converter","text":"this is needed for converting images to the correct sizes incl. caching to setup: https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/deployment.html - press launch solution - choose correct location in top right! - choose following settings: AutoWebP No - CorsEnabled Yes - CorsOrigin https://yourwebsite.com - DeployDemoUI No - EnableDefaultFallbackImage No - EnableSignature Yes - FallbackImageS3Bucket - - FallbackImageS3Key - - LogRetentionPeriod 1 - SecretsManagerKey your secret key - SecretsManagerSecret your secret secret - SourceBuckets artworldstudioplay - to create a secret go to: secretsmanager https://eu-central-1.console.aws.amazon.com/secretsmanager/home?region=eu-central-1#!/listSecrets/ - other type of secret - fill in key and value","title":"AWS image converter:"},{"location":"1.%20implementation/How_to_deploy_artworld/#troubleshoot","text":"","title":"troubleshoot"},{"location":"1.%20implementation/Items-bar/","text":"Player: - items bar around the player, following the player - The layer items bar has profile (home), liked, friend's homes, achievements. onlinePlayer: - items bar around the onlinePlayer, following the player - The layer items bar has home, likes. scene.playerLikedPanelKeys data structure: {artworks: Array(3)} {name: 'geelCoral_128'} allLikedArray: drawing/5264dc23-a339-40db-bb84-e0849ded4e68/geelCoral.png drawing/5264dc23-a339-40db-bb84-e0849ded4e68/witMurene.png drawing/5264dc23-a339-40db-bb84-e0849ded4e68/4_blauwSpotlijster.png drawing/5264dc23-a339-40db-bb84-e0849ded4e68/magentaGemeenschappelijke-vlieg.png","title":"Items bar"},{"location":"1.%20implementation/LOG-release-notes/","text":"1.2 Chip: rewriting saving artworks without json (saves size), png preview model Maarten: when png rewrite is done: auto reload avatar player. rewrite auto reload player: log off/ log in room: network players also get updated Maarten: rewrite server object handling","title":"LOG release notes"},{"location":"1.%20implementation/Last-Position-Players/","text":"Now the server remembers the last location and position of the player This can be used to place players when onBoarding the Game. The serverside LastPosition cannot be used for placing the player in the right position. It would then have to keep track the last positions of all visited locations. We could use HistoryTracker to remember the last position per location for the player. But then for the onLinePlayers we would have to get their position without them moving first. So now we implement position as follows: we place player in fixed positions we filter the placement based on known position and location the last position is kept in HistoryTracker, when going back the player is also put in the last known position of that location","title":"Last Position Players"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/","text":"Data structure {id: \"user_id\", art_url: \"art_url\"} We are storing the object as: collectionName.value.collectionName = [ {}, {} ] collection: \"liked\" create_time: \"2022-01-26T12:02:11Z\" key: \"liked_5264dc23-a339-40db-bb84-e0849ded4e68\" permission_read: 2 permission_write: 1 update_time: \"2022-02-03T14:11:23Z\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" value: liked: (Array (2)) [ 0: { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", }, 1: { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", } ] The functionality can be found in the class ArtworkList.js We do the first check in the NetworkBoot scene. We then have the latest liked array, each time a like is added of deleted we update the local and the server array, so the array is already in the updates state when clicking the liked button 1.a check if it exists on the server 1.b If the Liked object does not exists, create the object 1.c if the object exists, parse it to local array (ManageSession.allLiked) We get a server Object with this.getServerObject(\"liked\", ManageSession.userProfile.id, 10) which calls async getServerObject(collection, userID, maxItems) { Promise.all([listObjects(collection, userID, maxItems)]) .then(response => { console.log(\"collection\", collection) console.log(\"response\", response) //check if the object exists if (response[0].length > 0) { //the object exists: addressbook // check if the right object exists: addressbook_user_id let filteredResponse = response[0].filter(element => { console.log(collection + \"_\" + ManageSession.userProfile.id, typeof collection) console.log(\"element\", element) return element.key == collection + \"_\" + ManageSession.userProfile.id } ) console.log(\"filteredResponse\", filteredResponse) if (filteredResponse.length > 0) { //the right collection object exists, but check if there is data in de object, in the expected format if (typeof filteredResponse[0].value[collection] != \"undefined\") { //the object is in the right format (object.value.object), we assign our local copy ManageSession[collection] = filteredResponse[0].value console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //when the right addressbook does not exist: make an empty one //addressbook_userid.value exists but .addressbook this.createEmptyServerObject(collection) } } else { //when the right addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //the addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } }) } This is a promise, so we use Promise.all() to resolve a async/ await function inline. Promise.all is easier to use then Promise, because it gives the result in one line If the Liked Object does not exists, we make an empty object with an empty array, in the correct form: async createEmptyServerObject(collection) { //general method of creating an array inside an object with the argument of the method console.log(\"createEmptyServerObject\") console.log(collection) ManageSession[collection] = { [collection]:[] } const type = collection const name = type + \"_\" + ManageSession.userProfile.id const pub = 2 const value = ManageSession[collection] console.log(\" ManageSession. empty\", ManageSession[collection]) updateObject(type, name, value, pub) } Data structure of liked If the Liked Object has content, then the Object in inside a one element array. Like so: collection: \"liked\" create_time: \"2022-01-12T12:31:53Z\" key: \"all_liked_5264dc23-a339-40db-bb84-e0849ded4e68\" permission_read: 2 permission_write: 1 update_time: \"2022-01-13T15:45:02Z\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" value: liked: [ { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", }, ] version: \"d1be852d6a66654ec9faa878fcb41b7d\" url and previewURl is of the latest version, if we want to latest-latest version we would have to query for url and convert that url. Data of Artwork List Called with listImages(\"drawing\", this.location, 100) { \"collection\": \"stopmotion\", \"key\": \"1642771303290_limoenWalrus\", \"permission_read\": 2, \"permission_write\": 1, \"value\": \"url\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", \"json\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.json\", \"version\": 1, \"previewUrl\": \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", \"displayname\": \"limoenWalrus1\" \"version\": \"47ef7fee1aeebeeae6bb183aa0728267\", \"user_id\": \"5264dc23-a339-40db-bb84-e0849ded4e68\", \"create_time\": \"2022-01-21T13:21:44Z\", \"update_time\": \"2022-01-21T13:23:01Z\", \"url\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus\" } Final Code async getServerObject(collection, userID, maxItems) { Promise.all([listObjects(collection, userID, maxItems)]) .then(response => { console.log(\"collection\", collection) console.log(\"response\", response) //check if the object exists if (response[0].length > 0) { //the object exists: addressbook // check if the right object exists: addressbook_user_id let filteredResponse = response[0].filter(element => { console.log(collection + \"_\" + ManageSession.userProfile.id, typeof collection) console.log(\"element\", element) return element.key == collection + \"_\" + ManageSession.userProfile.id } ) console.log(\"filteredResponse\", filteredResponse) if (filteredResponse.length > 0) { //the right collection object exists, but check if there is data in de object, in the expected format if (typeof filteredResponse[0].value[collection] != \"undefined\") { //the object is in the right format (object.value.object), we assign our local copy ManageSession[collection] = filteredResponse[0].value console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //when the right addressbook does not exist: make an empty one //addressbook_userid.value exists but .addressbook this.createEmptyServerObject(collection) } } else { //when the right addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //the addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } }) } async createEmptyServerObject(collection) { //general method of creating an array inside an object with the argument of the method console.log(\"createEmptyServerObject\") console.log(collection) ManageSession[collection] = { [collection]:[] } const type = collection const name = type + \"_\" + ManageSession.userProfile.id const pub = 2 const value = ManageSession[collection] console.log(\" ManageSession. empty\", ManageSession[collection]) updateObject(type, name, value, pub) }","title":"Like(Heart) Button and OBJECT"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/#data-structure","text":"{id: \"user_id\", art_url: \"art_url\"} We are storing the object as: collectionName.value.collectionName = [ {}, {} ] collection: \"liked\" create_time: \"2022-01-26T12:02:11Z\" key: \"liked_5264dc23-a339-40db-bb84-e0849ded4e68\" permission_read: 2 permission_write: 1 update_time: \"2022-02-03T14:11:23Z\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" value: liked: (Array (2)) [ 0: { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", }, 1: { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", } ]","title":"Data structure"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/#the-functionality-can-be-found-in-the-class-artworklistjs","text":"We do the first check in the NetworkBoot scene. We then have the latest liked array, each time a like is added of deleted we update the local and the server array, so the array is already in the updates state when clicking the liked button 1.a check if it exists on the server 1.b If the Liked object does not exists, create the object 1.c if the object exists, parse it to local array (ManageSession.allLiked) We get a server Object with this.getServerObject(\"liked\", ManageSession.userProfile.id, 10) which calls async getServerObject(collection, userID, maxItems) { Promise.all([listObjects(collection, userID, maxItems)]) .then(response => { console.log(\"collection\", collection) console.log(\"response\", response) //check if the object exists if (response[0].length > 0) { //the object exists: addressbook // check if the right object exists: addressbook_user_id let filteredResponse = response[0].filter(element => { console.log(collection + \"_\" + ManageSession.userProfile.id, typeof collection) console.log(\"element\", element) return element.key == collection + \"_\" + ManageSession.userProfile.id } ) console.log(\"filteredResponse\", filteredResponse) if (filteredResponse.length > 0) { //the right collection object exists, but check if there is data in de object, in the expected format if (typeof filteredResponse[0].value[collection] != \"undefined\") { //the object is in the right format (object.value.object), we assign our local copy ManageSession[collection] = filteredResponse[0].value console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //when the right addressbook does not exist: make an empty one //addressbook_userid.value exists but .addressbook this.createEmptyServerObject(collection) } } else { //when the right addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //the addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } }) } This is a promise, so we use Promise.all() to resolve a async/ await function inline. Promise.all is easier to use then Promise, because it gives the result in one line If the Liked Object does not exists, we make an empty object with an empty array, in the correct form: async createEmptyServerObject(collection) { //general method of creating an array inside an object with the argument of the method console.log(\"createEmptyServerObject\") console.log(collection) ManageSession[collection] = { [collection]:[] } const type = collection const name = type + \"_\" + ManageSession.userProfile.id const pub = 2 const value = ManageSession[collection] console.log(\" ManageSession. empty\", ManageSession[collection]) updateObject(type, name, value, pub) }","title":"The functionality can be found in the class ArtworkList.js"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/#data-structure-of-liked","text":"If the Liked Object has content, then the Object in inside a one element array. Like so: collection: \"liked\" create_time: \"2022-01-12T12:31:53Z\" key: \"all_liked_5264dc23-a339-40db-bb84-e0849ded4e68\" permission_read: 2 permission_write: 1 update_time: \"2022-01-13T15:45:02Z\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" value: liked: [ { user_id: \"e0849c23-a339-40db-bb84-e0849ded4e68\", collection: \"drawing\", key: \"1642771303290_limoenWalrus\", version: 1, url: \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", previewURl: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", }, ] version: \"d1be852d6a66654ec9faa878fcb41b7d\" url and previewURl is of the latest version, if we want to latest-latest version we would have to query for url and convert that url.","title":"Data structure of liked"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/#data-of-artwork-list","text":"Called with listImages(\"drawing\", this.location, 100) { \"collection\": \"stopmotion\", \"key\": \"1642771303290_limoenWalrus\", \"permission_read\": 2, \"permission_write\": 1, \"value\": \"url\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png\", \"json\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.json\", \"version\": 1, \"previewUrl\": \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus.png?signature=c8c1aba753e01a6f06fd321a5a01a46fc18a483bb618ca1e2478283028a077f8\", \"displayname\": \"limoenWalrus1\" \"version\": \"47ef7fee1aeebeeae6bb183aa0728267\", \"user_id\": \"5264dc23-a339-40db-bb84-e0849ded4e68\", \"create_time\": \"2022-01-21T13:21:44Z\", \"update_time\": \"2022-01-21T13:23:01Z\", \"url\": \"stopmotion/5264dc23-a339-40db-bb84-e0849ded4e68/1_1642771303290_limoenWalrus\" }","title":"Data of Artwork List"},{"location":"1.%20implementation/Like%28Heart%29-Button-and-OBJECT/#final-code","text":"async getServerObject(collection, userID, maxItems) { Promise.all([listObjects(collection, userID, maxItems)]) .then(response => { console.log(\"collection\", collection) console.log(\"response\", response) //check if the object exists if (response[0].length > 0) { //the object exists: addressbook // check if the right object exists: addressbook_user_id let filteredResponse = response[0].filter(element => { console.log(collection + \"_\" + ManageSession.userProfile.id, typeof collection) console.log(\"element\", element) return element.key == collection + \"_\" + ManageSession.userProfile.id } ) console.log(\"filteredResponse\", filteredResponse) if (filteredResponse.length > 0) { //the right collection object exists, but check if there is data in de object, in the expected format if (typeof filteredResponse[0].value[collection] != \"undefined\") { //the object is in the right format (object.value.object), we assign our local copy ManageSession[collection] = filteredResponse[0].value console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //when the right addressbook does not exist: make an empty one //addressbook_userid.value exists but .addressbook this.createEmptyServerObject(collection) } } else { //when the right addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } console.log(\"ManageSession.\" + collection, ManageSession[collection]) } else { //the addressbook does not exist: make an empty one this.createEmptyServerObject(collection) } }) } async createEmptyServerObject(collection) { //general method of creating an array inside an object with the argument of the method console.log(\"createEmptyServerObject\") console.log(collection) ManageSession[collection] = { [collection]:[] } const type = collection const name = type + \"_\" + ManageSession.userProfile.id const pub = 2 const value = ManageSession[collection] console.log(\" ManageSession. empty\", ManageSession[collection]) updateObject(type, name, value, pub) }","title":"Final Code"},{"location":"1.%20implementation/Locations-OBJECT/","text":"Locations is being stored as an object in the database, with a collection name(the group where all these specific items get stored in), a key( to specify specifically that object) and the user Id. All 3 are mandatory to create, delete and find locations. That means you can have multiple locations, within the same collection and with the same key, but from a different user. This for instance makes it possible to search for all \"userhouses\" in \"locationA\". list Locations listObjects(type, userID, limit) response example: [ { \"collection\": \"home\", \"key\": \"test\", \"permission_read\": 2, \"permission_write\": 1, \"value\": { \"posX\": 12345, \"posY\": 12345 }, \"version\": \"e9a4463161b584c4f8ff1ab98d3b5932\", \"user_id\": \"4bd9378d-8b5b-4ea3-b683-6c3324792afe\", \"create_time\": \"2021-12-09T11:06:16Z\", \"update_time\": \"2021-12-09T11:32:30Z\" } ] create/update locations if you are admin(this gives you the possibility to create locations for other users): updateObjectAdmin(id, type, name, value, pub) if not admin: updateObject(type, name, value, pub) delete object if admin: deleteObjectAdmin(id, type, name); if not admin: deleteObject(type, name)","title":"Locations OBJECT"},{"location":"1.%20implementation/Locations-OBJECT/#list-locations","text":"listObjects(type, userID, limit) response example: [ { \"collection\": \"home\", \"key\": \"test\", \"permission_read\": 2, \"permission_write\": 1, \"value\": { \"posX\": 12345, \"posY\": 12345 }, \"version\": \"e9a4463161b584c4f8ff1ab98d3b5932\", \"user_id\": \"4bd9378d-8b5b-4ea3-b683-6c3324792afe\", \"create_time\": \"2021-12-09T11:06:16Z\", \"update_time\": \"2021-12-09T11:32:30Z\" } ]","title":"list Locations"},{"location":"1.%20implementation/Locations-OBJECT/#createupdate-locations","text":"if you are admin(this gives you the possibility to create locations for other users): updateObjectAdmin(id, type, name, value, pub) if not admin: updateObject(type, name, value, pub)","title":"create/update locations"},{"location":"1.%20implementation/Locations-OBJECT/#delete-object","text":"if admin: deleteObjectAdmin(id, type, name); if not admin: deleteObject(type, name)","title":"delete object"},{"location":"1.%20implementation/Movement---player/","text":"Sending the movement over the network is now optimized: we send a moveTo command. With double tapping and swiping this is straight foreward: the player moves to a target. With keyboard moving this is not that obvious so keyboardmoving is not enabled at the moment. Because we don't want to move when we are painting on a Graffitiwall, we added a graphic in the background that detects mousePresses, everything that should disable playerMovement is above that layer. This layer sets ManageSession.playerMove to true Methods in our Move.js class moveByCursor() Sets .cursorKeyIsDown to true or false when either one of the keyboard moving keys is down movingAnimation() Plays the appropiate animation according to the movement flag that is set maybe better with events! moveByKeyboard() moves player with keyboard commands MoveObjectToTarget() General method to move the player to a goal and detect when it has arrived this.updatePositionHistory(scene) // update the url and historyTracker ManageSession.sendMoveMessage(scene, target.x, target.y, \"moveTo\") //set movement over network checkIfPlayerReachedMoveGoal stops the player when it reached the goal (with a tolerance that is speed dependent) stops the player animation when the player reached also shaked the camera when the player reaches the end of the world updatePositionHistory update the url when the player moved update the position in the history tracker aswell moveBySwiping() move by swiping with mouse or finger moveByTapping() move by double tapping with finger or mouse sendMovement() send movement over the network Links with information: physics.moveto example: https://phaser.io/examples/v3/view/physics/arcade/move-to scroll camera example: https://phaser.io/examples/v3/view/camera/scroll-view World Camera example: https://labs.phaser.io/edit.html?src=src/camera/world%20camera.js&v=3.55.2 config parameters for the camera (acceleration, drag, maxSpeed) Get world point from camera: http://labs.phaser.io/edit.html?src=src/camera/get%20world%20point.js Move And Stop At Position: https://phaser.io/examples/v3/view/physics/arcade/move-and-stop-at-position Virtual Joystick https://codepen.io/rexrainbow/pen/oyqvQY Swipe discussion https://www.html5gamedevs.com/topic/39661-creating-swiping-mechanism/ Swipe example https://www.thepolyglotdeveloper.com/2020/09/include-touch-cursor-gesture-events-phaser-game/ Swipe movement (works really well!) playerMovingBySwiping() { if (!this.input.activePointer.isDown && this.isClicking == true) { const playerX = this.player.x const playerY = this.player.y const swipeX = this.input.activePointer.upX - this.input.activePointer.downX const swipeY = this.input.activePointer.upY - this.input.activePointer.downY // console.log(\"swipeX:\") // console.log(swipeX) // console.log(\"swipeY:\") // console.log(swipeY) this.swipeAmount.x = swipeX this.swipeAmount.y = swipeY const moveSpeed = this.swipeAmount.length() console.log(\"moveSpeed:\") console.log(moveSpeed) // console.log(\"this.swipeAmount:\") // console.log(this.swipeAmount.x) // console.log(this.swipeAmount.y) // console.log(\"\") //if (Math.abs(swipeX > 10) || Math.abs(swipeY > 10)) { this.playerIsMovingByClicking = true; // trigger moving animation this.target.x = playerX + swipeX this.target.y = playerY + swipeY this.physics.moveToObject(this.player, this.target, moveSpeed * 1.5); this.isClicking = false; // if (this.input.activePointer.upY < this.input.activePointer.downY) { // this.swipeDirection = \"up\"; // } else if (this.input.activePointer.upY > this.input.activePointer.downY) { // this.swipeDirection = \"down\"; // } } else if (this.input.activePointer.isDown && this.isClicking == false) { this.isClicking = true; } this.distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.target.x, this.target.y); // 4 is our distance tolerance, i.e. how close the source can get to the target // before it is considered as being there. The faster it moves, the more tolerance is required. if (this.playerIsMovingByClicking) { if (this.distance < 10) { this.player.body.reset(this.target.x, this.target.y); this.playerIsMovingByClicking = false } else { this.sendPlayerMovement(); } } }","title":"Movement   player"},{"location":"1.%20implementation/Movement---player/#swipe-movement-works-really-well","text":"playerMovingBySwiping() { if (!this.input.activePointer.isDown && this.isClicking == true) { const playerX = this.player.x const playerY = this.player.y const swipeX = this.input.activePointer.upX - this.input.activePointer.downX const swipeY = this.input.activePointer.upY - this.input.activePointer.downY // console.log(\"swipeX:\") // console.log(swipeX) // console.log(\"swipeY:\") // console.log(swipeY) this.swipeAmount.x = swipeX this.swipeAmount.y = swipeY const moveSpeed = this.swipeAmount.length() console.log(\"moveSpeed:\") console.log(moveSpeed) // console.log(\"this.swipeAmount:\") // console.log(this.swipeAmount.x) // console.log(this.swipeAmount.y) // console.log(\"\") //if (Math.abs(swipeX > 10) || Math.abs(swipeY > 10)) { this.playerIsMovingByClicking = true; // trigger moving animation this.target.x = playerX + swipeX this.target.y = playerY + swipeY this.physics.moveToObject(this.player, this.target, moveSpeed * 1.5); this.isClicking = false; // if (this.input.activePointer.upY < this.input.activePointer.downY) { // this.swipeDirection = \"up\"; // } else if (this.input.activePointer.upY > this.input.activePointer.downY) { // this.swipeDirection = \"down\"; // } } else if (this.input.activePointer.isDown && this.isClicking == false) { this.isClicking = true; } this.distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.target.x, this.target.y); // 4 is our distance tolerance, i.e. how close the source can get to the target // before it is considered as being there. The faster it moves, the more tolerance is required. if (this.playerIsMovingByClicking) { if (this.distance < 10) { this.player.body.reset(this.target.x, this.target.y); this.playerIsMovingByClicking = false } else { this.sendPlayerMovement(); } } }","title":"Swipe movement (works really well!)"},{"location":"1.%20implementation/Movement--onlinePlayer/","text":"In ManageSession we get onlinePlayer movement via the socket, with: this.socket.onstreamdata = (streamdata) => { let data = JSON.parse(streamdata.data) The data we get is: { location: \"ArtworldAmsterdam\", posX: 50, posY: 50, user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" }","title":"Movement  onlinePlayer"},{"location":"1.%20implementation/Network-Flow-Client-Side/","text":"Graphical flow of the network: Figma: network flow client 1. App.Svelte Is the Session empty? session (https) -> token, expiration 2. yes, the Session is empty: login.Svelte session.js let storedSession = localStorage.getItem(\"Session\") export const Session = writable(storedSession ? JSON.parse(storedSession) : null); Session.subscribe((value) => { if (value) { manageSession.sessionStored = value; //! push the Session with url to manageSession localStorage.setItem('Session', JSON.stringify(value)) } else localStorage.removeItem('Session'); // for logout }) let profileStore = localStorage.getItem(\"profile\") export const Profile = writable(profileStore ? JSON.parse(profileStore) : null); Profile.subscribe((value) => { localStorage.setItem('profile', JSON.stringify(value)); manageSession.userProfile = value //! push the profile with url to manageSession // console.log(\"Profile.subscribe((value)\") // console.log(value) } else localStorage.removeItem('profile'); // for logout client.authenticateEmail(email, password, create) .then((response)=> { \u2028Session.set(session) getAccount()} Session object: Session$1 { created_at: \u201c1636024979\u201d, expires_at: \u201c1636032179\u201d, token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiI1MjY0ZGMyMy1hMzM5LTQwZGItYmI4NC1lMDg0OWRlZDRlNjgiLCJ1c24iOiJ1c2VyMTEiLCJleHAiOjE2MzYwMzIxNzl9.HVT1r90Ud5cHd-I5PcqxIuygHmTlDRWBhN-7FeHhQSA\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\", username: \"user11\", vars: undefined } Profile Object without URL $Profile { avatar_url: \"avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\" create_time: \"2021-10-16T17:28:59Z\" edge_count: 4 id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" lang_tag: \"en\" meta: {azc: 'Amsterdam', posX: 528, posY: 800, role: 'speler', user_id: '', \u2026} metadata: \"{\\\"azc\\\": \\\"Amsterdam\\\", \\\"posX\\\": 528, \\\"posY\\\": 800, \\\"role\\\": \\\"speler\\\", \\\"user_id\\\": \\\"\\\", \\\"location\\\": \\\"location1\\\"}\" update_time: \"2021-11-03T16:00:14Z\" username: \"user11\" } Profile Object WITH URL $Profile { avatar_url: \"avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\" create_time: \"2021-10-16T17:28:59Z\" edge_count: 4 id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" lang_tag: \"en\" meta: {azc: 'Amsterdam', posX: 528, posY: 800, role: 'speler', user_id: '', \u2026} metadata: \"{\\\"azc\\\": \\\"Amsterdam\\\", \\\"posX\\\": 528, \\\"posY\\\": 800, \\\"role\\\": \\\"speler\\\", \\\"user_id\\\": \\\"\\\", \\\"location\\\": \\\"location1\\\"}\" update_time: \"2021-11-03T16:00:14Z\" url: \"https://artworldstudioplay.s3.eu-central-1.amazonaws.com/avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAR7FDNFNP252ENA7M%2F20211104%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20211104T120408Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=f85d6c618c85f2561803d2fcb86a5a2288d6b8bf7325d0c7effe8268df36d26c\" username: \"user11\" } 3. No the Session is not empty -> MainMenu.js //* check if the user profile is loaded, to be able to send the player to the right location if (typeof (manageSession.userProfile.meta.location) != \"undefined\") { this.launchLocation = manageSession.userProfile.meta.location + \"_Scene\" console.log(this.launchLocation) this.checkSceneExistence() } else { getAccount(\"\", true) .then(rec => { manageSession.freshSession = rec //! only set the menu button visible if the user data is downloaded! this.launchLocation = manageSession.freshSession.meta.location + \"_Scene\" this.checkSceneExistence() }) } } //create checkSceneExistence() { //check if this.launchLocation exists in SCENES const locationExists = SCENES.includes(this.launchLocation) //if location does not exists; launch default location if (!locationExists) { //set to fail-back scene manageSession.location = \"location1\" manageSession.launchLocation = manageSession.location + \"_Scene\" } else { manageSession.location = manageSession.userProfile.meta.location } this.playBtn.setVisible(true) } 4A. networkBoot_Scene.js manageSession.createPlayer = true await manageSession.createSocket() .then(rec => { console.log(manageSession.launchLocation) this.scene.launch(manageSession.launchLocation) }) 4B. manageSession.js createSocket socket.connect getStreamUsers (\u201cjoin\u201d, this.location) socket.onstreampresence 5. locationX_Scene.js manageSession.createPlayer = true loadAndCreatePlayerAvatar() attachtAvatarToPlayer() createOnlinePlayers() attachtAvatarToOnlinePlayer(player, preExisting) 6. CHANGE LOCATIONS LocationA: manageSession.socket.rpc(\"leave\", locationA) setTimeout(() => { manageSession.location = location manageSession.createPlayer = true manageSession.getStreamUsers(\"join\", locationB) this.scene.start(locationScene) }, 1000) LocationB: manageSession.createPlayer = true loadAndCreatePlayerAvatar() attachtAvatarToPlayer() createOnlinePlayers() attachtAvatarToOnlinePlayer(player, preExisting)","title":"Network Flow Client Side"},{"location":"1.%20implementation/Network-Flow-Client-Side/#graphical-flow-of-the-network","text":"","title":"Graphical flow of the network:"},{"location":"1.%20implementation/Network-Flow-Client-Side/#figma-network-flow-client","text":"","title":"Figma: network flow client"},{"location":"1.%20implementation/Network-Flow-Client-Side/#1-appsvelte-is-the-session-empty","text":"session (https) -> token, expiration","title":"1. App.Svelte Is the Session empty?"},{"location":"1.%20implementation/Network-Flow-Client-Side/#2-yes-the-session-is-empty","text":"login.Svelte session.js let storedSession = localStorage.getItem(\"Session\") export const Session = writable(storedSession ? JSON.parse(storedSession) : null); Session.subscribe((value) => { if (value) { manageSession.sessionStored = value; //! push the Session with url to manageSession localStorage.setItem('Session', JSON.stringify(value)) } else localStorage.removeItem('Session'); // for logout }) let profileStore = localStorage.getItem(\"profile\") export const Profile = writable(profileStore ? JSON.parse(profileStore) : null); Profile.subscribe((value) => { localStorage.setItem('profile', JSON.stringify(value)); manageSession.userProfile = value //! push the profile with url to manageSession // console.log(\"Profile.subscribe((value)\") // console.log(value) } else localStorage.removeItem('profile'); // for logout client.authenticateEmail(email, password, create) .then((response)=> { \u2028Session.set(session) getAccount()}","title":"2. yes, the Session is empty:"},{"location":"1.%20implementation/Network-Flow-Client-Side/#session-object","text":"Session$1 { created_at: \u201c1636024979\u201d, expires_at: \u201c1636032179\u201d, token: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiI1MjY0ZGMyMy1hMzM5LTQwZGItYmI4NC1lMDg0OWRlZDRlNjgiLCJ1c24iOiJ1c2VyMTEiLCJleHAiOjE2MzYwMzIxNzl9.HVT1r90Ud5cHd-I5PcqxIuygHmTlDRWBhN-7FeHhQSA\" user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\", username: \"user11\", vars: undefined }","title":"Session object:"},{"location":"1.%20implementation/Network-Flow-Client-Side/#profile-object-without-url","text":"$Profile { avatar_url: \"avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\" create_time: \"2021-10-16T17:28:59Z\" edge_count: 4 id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" lang_tag: \"en\" meta: {azc: 'Amsterdam', posX: 528, posY: 800, role: 'speler', user_id: '', \u2026} metadata: \"{\\\"azc\\\": \\\"Amsterdam\\\", \\\"posX\\\": 528, \\\"posY\\\": 800, \\\"role\\\": \\\"speler\\\", \\\"user_id\\\": \\\"\\\", \\\"location\\\": \\\"location1\\\"}\" update_time: \"2021-11-03T16:00:14Z\" username: \"user11\" }","title":"Profile Object without URL"},{"location":"1.%20implementation/Network-Flow-Client-Side/#profile-object-with-url","text":"$Profile { avatar_url: \"avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\" create_time: \"2021-10-16T17:28:59Z\" edge_count: 4 id: \"5264dc23-a339-40db-bb84-e0849ded4e68\" lang_tag: \"en\" meta: {azc: 'Amsterdam', posX: 528, posY: 800, role: 'speler', user_id: '', \u2026} metadata: \"{\\\"azc\\\": \\\"Amsterdam\\\", \\\"posX\\\": 528, \\\"posY\\\": 800, \\\"role\\\": \\\"speler\\\", \\\"user_id\\\": \\\"\\\", \\\"location\\\": \\\"location1\\\"}\" update_time: \"2021-11-03T16:00:14Z\" url: \"https://artworldstudioplay.s3.eu-central-1.amazonaws.com/avatar/5264dc23-a339-40db-bb84-e0849ded4e68/current.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAR7FDNFNP252ENA7M%2F20211104%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20211104T120408Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=f85d6c618c85f2561803d2fcb86a5a2288d6b8bf7325d0c7effe8268df36d26c\" username: \"user11\" }","title":"Profile Object WITH URL"},{"location":"1.%20implementation/Network-Flow-Client-Side/#3-no-the-session-is-not-empty-mainmenujs","text":"//* check if the user profile is loaded, to be able to send the player to the right location if (typeof (manageSession.userProfile.meta.location) != \"undefined\") { this.launchLocation = manageSession.userProfile.meta.location + \"_Scene\" console.log(this.launchLocation) this.checkSceneExistence() } else { getAccount(\"\", true) .then(rec => { manageSession.freshSession = rec //! only set the menu button visible if the user data is downloaded! this.launchLocation = manageSession.freshSession.meta.location + \"_Scene\" this.checkSceneExistence() }) } } //create checkSceneExistence() { //check if this.launchLocation exists in SCENES const locationExists = SCENES.includes(this.launchLocation) //if location does not exists; launch default location if (!locationExists) { //set to fail-back scene manageSession.location = \"location1\" manageSession.launchLocation = manageSession.location + \"_Scene\" } else { manageSession.location = manageSession.userProfile.meta.location } this.playBtn.setVisible(true) }","title":"3. No the Session is not empty -&gt; MainMenu.js"},{"location":"1.%20implementation/Network-Flow-Client-Side/#4a-networkboot_scenejs","text":"manageSession.createPlayer = true await manageSession.createSocket() .then(rec => { console.log(manageSession.launchLocation) this.scene.launch(manageSession.launchLocation) })","title":"4A. networkBoot_Scene.js"},{"location":"1.%20implementation/Network-Flow-Client-Side/#4b-managesessionjs","text":"createSocket socket.connect getStreamUsers (\u201cjoin\u201d, this.location) socket.onstreampresence","title":"4B. manageSession.js"},{"location":"1.%20implementation/Network-Flow-Client-Side/#5-locationx_scenejs","text":"manageSession.createPlayer = true loadAndCreatePlayerAvatar() attachtAvatarToPlayer() createOnlinePlayers() attachtAvatarToOnlinePlayer(player, preExisting)","title":"5. locationX_Scene.js"},{"location":"1.%20implementation/Network-Flow-Client-Side/#6-change-locations","text":"LocationA: manageSession.socket.rpc(\"leave\", locationA) setTimeout(() => { manageSession.location = location manageSession.createPlayer = true manageSession.getStreamUsers(\"join\", locationB) this.scene.start(locationScene) }, 1000) LocationB: manageSession.createPlayer = true loadAndCreatePlayerAvatar() attachtAvatarToPlayer() createOnlinePlayers() attachtAvatarToOnlinePlayer(player, preExisting)","title":"6. CHANGE LOCATIONS"},{"location":"1.%20implementation/PNG_Compression_percentages/","text":"to create the best looking, smallest png files with transparency: 1-step 1. pngquant: pngquant 64 --force --skip-if-larger *.png Total reduction: 70.67% 2-step [No difference to 1-step, but documented...] 1. pngcrush pngcrush is a PNG (Portable Network Graphics) file optimizer. It reduces the file size of the image by passing it through various compression methods and filters. Debian/Ubuntu users can run the following command for installation. sudo apt get install pngcrush Users of other Linux distributions can install it using their standard installation commands followed by pngcrush. After the installation is done, we can reduce the size of PNG file by running: pngcrush -brute Reduce Image Size Pngcrush Reducing PNG file size The '-brute' option takes the file through 114 filter/compression methods. The extended process consumes few seconds. Instead of applying the brute force approach, users can select filters, levels and strategies for optimization. The types of filters and other properties can be learnt through the manual pages - man pngcrush. -d [output dir] Average reduction in size: 18% After that reduce color with pngquant: pngquant 64 --force --skip-if-larger *.png Average reduction in size: 68.25% Total reduction: 70.67%","title":"PNG Compression percentages"},{"location":"1.%20implementation/Parsing-URL-Parameters---Phaser-onboarding/","text":"https://docs.google.com/drawings/d/19rJP5XxY_8ZWCcD-bzCNEFJ0sJDMKTL9rEqBGvq5y14/edit?usp=sharing","title":"Parsing URL Parameters   Phaser onboarding"},{"location":"1.%20implementation/Phaser_error_handling/","text":"Now I using a queue to load details about the function the file is loaded in: this.resolveErrorObjectArray = [] async getHomeImages(url, element, index, homeImageKey, scene) { console.log(\"getHomeImages\") await convertImage(url, \"128\", \"png\") .then((rec) => { //console.log(\"rec\", rec) // load all the images to phaser scene.load.image(homeImageKey, rec) .on(`filecomplete-image-${homeImageKey}`, (homeImageKey) => { //delete from this.resolveErrorObjectArray this.resolveErrorObjectArray = this.resolveErrorObjectArray.filter((obj) => obj.imageKey !== homeImageKey) console.log(\"this.resolveErrorObjectArray\", this.resolveErrorObjectArray) //create the home this.createHome(element, index, homeImageKey, scene) }, this) // put the file in the loadErrorCache, incase it doesn't load this.resolveErrorObjectArray.push({ loadFunction: \"getHomeImage\", element: element, index: index, imageKey: homeImageKey }) scene.load.start() // start loading the image in memory }) } resolveLoadError(offendingFile) { let resolveErrorObject = this.resolveErrorObjectArray.find(obj => obj.imageKey == offendingFile.key) let loadFunction = resolveErrorObject.loadFunction let element = resolveErrorObject.element let index = resolveErrorObject.index let imageKey = offendingFile.key let scene = ManageSession.currentScene switch (loadFunction) { case (\"getHomeImage\"): console.log(\"load offendingFile again\", imageKey, offendingFile) scene.load.image(imageKey, './assets/ball_grey.png') .on(`filecomplete-image-${imageKey}`, (imageKey) => { //delete from this.resolveErrorObjectArray this.resolveErrorObjectArray = this.resolveErrorObjectArray.filter((obj) => obj.imageKey !== imageKey) console.log(\"this.resolveErrorObjectArray\", this.resolveErrorObjectArray) //create the home this.createHome(element, index, imageKey, scene); }, this) scene.load.start() break default: console.log(\"please state fom which function the loaderror occured!\") } } Was using this: scene.load.image(homeImageKey, rec) .on(`filecomplete-image-${homeImageKey}`, (homeImageKey) => { //create the home this.createHome(element, index, homeImageKey, scene) }, this) .on(`loaderror`, (offendingFile) => { this.resolveLoadError(element, index, homeImageKey, offendingFile, scene) }, this) scene.load.start() But the .on('loaderror) callback is for the whole scene, so it is difficult to create a callback specific for a method. On way to do it maybe is to only add to the queue when a method is finished. So to use to load queue per loading method/ sequence... Async loader plugin: https://pablo.gg/en/blog/games/how-to-load-assets-asynchronously-with-phaser-3/ Maybe a useful methode: https://phaser.discourse.group/t/loading-audio/1306/4 async create() { const asyncLoader = loaderPlugin => { return new Promise(resolve => { loaderPlugin.on('filecomplete', () => resolve()).on('loaderror', () => resolve()) loaderPlugin.start() }) } await asyncLoader(this.load.audio('song', ['assets/sounds/0781.ogg'])) this.sound.add('song').play() }","title":"Phaser error handling"},{"location":"1.%20implementation/Phaser_event_system/","text":"subscribe to the event: this.events.on('gameEditMode', this.gameEditModeSign, this) send the event with arguments: scene.events.emit('gameEditMode', 'off') callbackFunction with arguments: gameEditModeSign(arg) { console.log(\"gameEditMode received\", arg) } Use case: doubble click -> move player to specific location, an other object should also be able to subscribe on that moveTo If you move a GameObject with a tween, then the progression of the tween event can be 'read', and calledback. Scene event senders and listeners Here is our event listener, the 'handler' function. The 'this' argument is the context. this.events.on('chatsubo', this.handler, this) We'll use the Scenes own EventEmitter to dispatch our event this.events.emit('chatsubo') Event arguments The event sends 2 arguments: 200 and 300 this.events.emit('addImage', 200, 300) The event handles sends the arguments on to the handler function ```this.events.on('addImage', handler, this) function handler (x, y) { this.add.image(x, y, 'plush') } ### Create Event Emitter // Create our own EventEmitter instance var emitter = new Phaser.Events.EventEmitter(); // Set-up an event handler emitter.on('addImage', this.handler, this); // Emit it a few times with varying arguments emitter.emit('addImage', 200, 300); emitter.emit('addImage', 400, 300); emitter.emit('addImage', 600, 300); } handler (x, y) { this.add.image(x, y, 'plush'); } ``` Once vs On This handler will only be called once, no matter how many times the event fires this.events.once('addImage', this.handler, this) background info: Events dispatch class ONMOVE event example https://labs.phaser.io/edit.html?src=src/input/game%20object/on%20move%20event.js&v=3.55.2 Object emits event https://labs.phaser.io/edit.html?src=src/events/listen%20to%20game%20object%20event.js&v=3.55.2 Move gameObject to mouse click (\"click to move\" movement\") using tween https://stackoverflow.com/questions/69759621/phaser-3-move-gameobject-to-mouse-click-click-to-move-movement-using-twee https://stackoverflow.com/questions/28522568/how-can-i-get-the-object-on-which-the-tween-in-acting-inside-the-oncomplete-call Tween handlers https://rexrainbow.github.io/phaser3-rex-notes/docs/site/tween/#play-task https://phasergames.com/phaser-3-snippets/phaser-3-tween-snippets/","title":"Phaser event system"},{"location":"1.%20implementation/Phaser_event_system/#scene-event-senders-and-listeners","text":"Here is our event listener, the 'handler' function. The 'this' argument is the context. this.events.on('chatsubo', this.handler, this) We'll use the Scenes own EventEmitter to dispatch our event this.events.emit('chatsubo')","title":"Scene event senders and listeners"},{"location":"1.%20implementation/Phaser_event_system/#event-arguments","text":"The event sends 2 arguments: 200 and 300 this.events.emit('addImage', 200, 300) The event handles sends the arguments on to the handler function ```this.events.on('addImage', handler, this) function handler (x, y) { this.add.image(x, y, 'plush') } ### Create Event Emitter // Create our own EventEmitter instance var emitter = new Phaser.Events.EventEmitter(); // Set-up an event handler emitter.on('addImage', this.handler, this); // Emit it a few times with varying arguments emitter.emit('addImage', 200, 300); emitter.emit('addImage', 400, 300); emitter.emit('addImage', 600, 300); } handler (x, y) { this.add.image(x, y, 'plush'); } ```","title":"Event arguments"},{"location":"1.%20implementation/Phaser_event_system/#once-vs-on","text":"This handler will only be called once, no matter how many times the event fires this.events.once('addImage', this.handler, this) background info: Events dispatch class ONMOVE event example https://labs.phaser.io/edit.html?src=src/input/game%20object/on%20move%20event.js&v=3.55.2 Object emits event https://labs.phaser.io/edit.html?src=src/events/listen%20to%20game%20object%20event.js&v=3.55.2 Move gameObject to mouse click (\"click to move\" movement\") using tween https://stackoverflow.com/questions/69759621/phaser-3-move-gameobject-to-mouse-click-click-to-move-movement-using-twee https://stackoverflow.com/questions/28522568/how-can-i-get-the-object-on-which-the-tween-in-acting-inside-the-oncomplete-call Tween handlers https://rexrainbow.github.io/phaser3-rex-notes/docs/site/tween/#play-task https://phasergames.com/phaser-3-snippets/phaser-3-tween-snippets/","title":"Once vs On"},{"location":"1.%20implementation/RELEASE_LOG/","text":"","title":"RELEASE LOG"},{"location":"1.%20implementation/SERVEROBJECT-achievements/","text":"The achievements object stores an array of timers (should this be objects?) For the achievement itemsbar item we use an achievementObject to store the achievements we reached, and their icons The timer object should be called achievementTimer Object?","title":"SERVEROBJECT achievements"},{"location":"1.%20implementation/SERVEROBJECT-addressbook/","text":"We create an addressbook object as: { collection: \"addressbook\", create_time: \"2022-02-04T10:19:30Z\", key: \"b9ae6807-1ce1-4b71-a8a3-f5958be4d340\", permission_read: 2, permission_write: 1, update_time: \"2022-02-04T10:19:30Z\", user_id: \"5264dc23-a339-40db-bb84-e0849ded4e68\", value: {}, version: \"247e6735883b9170eed471dd411095cb\" } value of the addressbook objects: user_id: \"b9ae6807-1ce1-4b71-a8a3-f5958be4d340\" user_name: \"user1\" show empy addressbook when array is empty when deleting the last friend, show empty addressbook","title":"SERVEROBJECT addressbook"},{"location":"1.%20implementation/SERVEROBJECT-liked/","text":"{ collection: \"drawing\" key: \"1646914921380_witParelhoen\" url: \"drawing/f42eb28f-9f4d-476c-9788-2240bac4cf48/0_1646914921380_witParelhoen.png\" user_id: \"f42eb28f-9f4d-476c-9788-2240bac4cf48\" }","title":"SERVEROBJECT liked"},{"location":"1.%20implementation/ServerCallsFormat/","text":"uploadImage(name, type, json, img, status,version, displayName) this function: - gets upload URL for json and png - uploads blobs to aws - send an object to nakama containing: { \"url\": \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/4_blauwSpotlijster.png\", \"json\": \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/4_blauwSpotlijster.json\", \"version\": 4, \"displayname\": \"blauwSpotlijster\" } no response on succes getUploadURL(type, name, filetype,version) this function creates a signed upload url for file upload to AWS usage example var version = 1 var [jsonURL, jsonLocation] = await getUploadURL(\"home\", \"current\", \"json\", version) // creates route on aws \"/home/user_id/1_current.json\" updateTitle(collection, key, name, userID) this function: - picks up object - updates object.value.displayname - pushes object back to server example updateTitle(\"drawing\", \"12345345_geelkoe\", \"nieuwe naam\", \"`1231hh3123dasda\") updateObject(type, name, value, pub, userID) userID is optional, only necessary for admin and moderator functions. Example (addressbook): const type = \"addressbook\" const name = type + \"_\" + ManageSession.userProfile.id const value = '{\"user_id\": \"b9ae6807-1ce1-4b71-a8a3-f5958be4d340\", \"posX\": \"500\", \"posY\": \"110\"}' const pub = 2 updateObject(type, name, value, pub) getAccount(id, avatar) 0:[ { avatar_url: \"avatar/f42eb28f-9f4d-476c-9788-2240bac4cf48/current.png\", create_time: \"2021-10-11T11:32:02Z\", display_name: undefined, edge_count: 0, facebook_id: undefined, gamecenter_id: undefined, google_id: undefined, id: \"f42eb28f-9f4d-476c-9788-2240bac4cf48\", lang_tag: \"en\", location: undefined, metadata:{ azc: \"Amsterdam\", location: \"ArtworldAmsterdam\", posX: -122.62672, posY: 22.468008, role: \"speler\", user_id: \"\", } online: true, steam_id: undefined, timezone: undefined, update_time: \"2022-02-08T13:02:37Z\", url: \"https://artworldstudioplay.s3.eu-central-1.amazonaws.com/avatar/f42eb28f-9f4d-476c-9788-2240bac4cf48/current.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAR7FDNFNP252ENA7M%2F20220208%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20220208T130243Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=fbf4c90016829b9ad0376fd0b7c96b563a0dfd16d46f0d6289287a444fa8604c\", username: \"user33\", }, ] The url is the actual avatar url, the url is called via getAccount, getUrl, but with a couple of await functions it takes a bit for the url to load via the getAccount function. getAvatar(avatar_url) uploadAvatar(data) deleteFile(type,file,user) adding data (eg locations) to the backend function updateObject(type, name, value, pub) Example: type: \"home\" (collection) name = \"hansjes huisje\" (key) value = object with keys (value) pub: permission_read (pub) updateObject(\"location\", name, value, true) listObjects(type, userID, limit, page) type = \"location\" userID = per user, null to get all users limit = how many you want to get(standard 100) page = index of limit(if limit = 100, index 0 = 1 - 100, index 1 = 101 -200, index 2 = 202 - 300 etc...) examples getting a users home object listObjects('home','5264dc23-a339-40db-bb84-e0849ded4e68') returns the object: [ { \"collection\": \"home\", \"key\": \"Amsterdam\", \"permission_read\": 2, \"permission_write\": 1, \"value\": { \"url\": \"home/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\", \"posX\": 228.16, \"posY\": 57.66, \"userName\": \"user11\" }, \"version\": \"d1be852d6a66654ec9faa878fcb41b7d\", \"user_id\": \"5264dc23-a339-40db-bb84-e0849ded4e68\", \"create_time\": \"2022-01-12T12:31:53Z\", \"update_time\": \"2022-01-13T15:45:02Z\" } ] convert images convertImage(path,size, format) output: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/filters:trim()/avatar/4ced8bff-d79c-4842-b2bd-39e9d9aa597e/current.png?signature=cbda2578e5612c70c009ebc6e0424e9025078aa94517543b310bf01eedefb167\" size and format at not both required to work, either one or both will also function for example: convertImage(path,, format) This is a replacement for getAvatar() if needed more filters can be added in the future, see: https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/thumbor-filters.html listAllObjects(type, id, limit, cursor) type is eg drawing, location, etc ... id is userID(or undefined , but not null or \"\" ) limit is the max number of objects you want to receive (either by page or in total) cursor is on the first call ```undefined```` (just empty), when supplied, it defines the next page of limit-number of objects. The cursor is the last objects update time, so: objects[limit - 1].update_time Results come back within .objects array: [ { collection: \"drawing\" downloaded: true key: \"2023-01-02T21_50_42_GeelAvoceta\" permission_read: 1 read: 1 update_time: \"2023-01-20T16:55:15.02286+01:00\" user_id: \"f011a5dc-901a-42c0-9589-587b389d1e3e\" username: \"user11\" value: displayname: \"bloem\" url: \"drawing/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-02T21_50_42_GeelAvoceta.png\" version: \"0\" }, ..... ] update_time: \"2023-01-20T16:55:15.02286+01:00\" of the last object is used as the cursor to get the next page of objects. validate(string,type,input) types email - validates email adresses password - validates length is betweenm 5 and 10 characters repeat password - checks if password and repeat password are identical special - checks if the value contains no special characters examples: can be used in 2 ways, inline, automatically sets border to red if fail <input type=\"text\" placeholder=\"Enter Username\" name=\"username\" id=\"username\" bind:value={username} on:keyup={async input => {await validate(username,\"special\",input)}} required /> or can used within a function as following: if(await validate(email,\"email\")){ // run action if valid } else { // run if invalid ) setLoader(state) setLoader(true) sets loading screen on setLoader(false) sets loading screen off getAllHouses(location,user_id) Gives you all the houses objects within the location, optionally add a user_id example result: [ { \"read\": 2, \"artworks\": { \"stopmotion\": 1, \"drawing\": 3 }, \"username\": \"user6\", \"key\": \"Amsterdam\", \"collection\": \"home\", \"update_time\": \"2022-08-08T15:17:06.817697+02:00\", \"permission_read\": 2, \"value\": { \"username\": \"user6\", \"url\": \"home/fcbcc269-a109-4a4b-a570-5ccafc5308d8/5_current.png\", \"posX\": -904.9999877562127, \"posY\": 72.49999139457941, \"version\": 5 }, \"user_id\": \"fcbcc269-a109-4a4b-a570-5ccafc5308d8\" },","title":"ServerCallsFormat"},{"location":"1.%20implementation/ServerCallsFormat/#uploadimagename-type-json-img-statusversion-displayname","text":"this function: - gets upload URL for json and png - uploads blobs to aws - send an object to nakama containing: { \"url\": \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/4_blauwSpotlijster.png\", \"json\": \"drawing/5264dc23-a339-40db-bb84-e0849ded4e68/4_blauwSpotlijster.json\", \"version\": 4, \"displayname\": \"blauwSpotlijster\" } no response on succes","title":"uploadImage(name, type, json, img, status,version, displayName)"},{"location":"1.%20implementation/ServerCallsFormat/#getuploadurltype-name-filetypeversion","text":"this function creates a signed upload url for file upload to AWS","title":"getUploadURL(type, name, filetype,version)"},{"location":"1.%20implementation/ServerCallsFormat/#usage-example","text":"var version = 1 var [jsonURL, jsonLocation] = await getUploadURL(\"home\", \"current\", \"json\", version) // creates route on aws \"/home/user_id/1_current.json\"","title":"usage example"},{"location":"1.%20implementation/ServerCallsFormat/#updatetitlecollection-key-name-userid","text":"this function: - picks up object - updates object.value.displayname - pushes object back to server","title":"updateTitle(collection, key, name, userID)"},{"location":"1.%20implementation/ServerCallsFormat/#example","text":"updateTitle(\"drawing\", \"12345345_geelkoe\", \"nieuwe naam\", \"`1231hh3123dasda\")","title":"example"},{"location":"1.%20implementation/ServerCallsFormat/#updateobjecttype-name-value-pub-userid","text":"userID is optional, only necessary for admin and moderator functions.","title":"updateObject(type, name, value, pub, userID)"},{"location":"1.%20implementation/ServerCallsFormat/#example-addressbook","text":"const type = \"addressbook\" const name = type + \"_\" + ManageSession.userProfile.id const value = '{\"user_id\": \"b9ae6807-1ce1-4b71-a8a3-f5958be4d340\", \"posX\": \"500\", \"posY\": \"110\"}' const pub = 2 updateObject(type, name, value, pub)","title":"Example (addressbook):"},{"location":"1.%20implementation/ServerCallsFormat/#getaccountid-avatar","text":"0:[ { avatar_url: \"avatar/f42eb28f-9f4d-476c-9788-2240bac4cf48/current.png\", create_time: \"2021-10-11T11:32:02Z\", display_name: undefined, edge_count: 0, facebook_id: undefined, gamecenter_id: undefined, google_id: undefined, id: \"f42eb28f-9f4d-476c-9788-2240bac4cf48\", lang_tag: \"en\", location: undefined, metadata:{ azc: \"Amsterdam\", location: \"ArtworldAmsterdam\", posX: -122.62672, posY: 22.468008, role: \"speler\", user_id: \"\", } online: true, steam_id: undefined, timezone: undefined, update_time: \"2022-02-08T13:02:37Z\", url: \"https://artworldstudioplay.s3.eu-central-1.amazonaws.com/avatar/f42eb28f-9f4d-476c-9788-2240bac4cf48/current.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAR7FDNFNP252ENA7M%2F20220208%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20220208T130243Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=fbf4c90016829b9ad0376fd0b7c96b563a0dfd16d46f0d6289287a444fa8604c\", username: \"user33\", }, ] The url is the actual avatar url, the url is called via getAccount, getUrl, but with a couple of await functions it takes a bit for the url to load via the getAccount function.","title":"getAccount(id, avatar)"},{"location":"1.%20implementation/ServerCallsFormat/#getavataravatar_url","text":"","title":"getAvatar(avatar_url)"},{"location":"1.%20implementation/ServerCallsFormat/#uploadavatardata","text":"","title":"uploadAvatar(data)"},{"location":"1.%20implementation/ServerCallsFormat/#deletefiletypefileuser","text":"","title":"deleteFile(type,file,user)"},{"location":"1.%20implementation/ServerCallsFormat/#adding-data-eg-locations-to-the-backend","text":"function updateObject(type, name, value, pub) Example: type: \"home\" (collection) name = \"hansjes huisje\" (key) value = object with keys (value) pub: permission_read (pub) updateObject(\"location\", name, value, true)","title":"adding data (eg locations) to the backend"},{"location":"1.%20implementation/ServerCallsFormat/#listobjectstype-userid-limit-page","text":"type = \"location\" userID = per user, null to get all users limit = how many you want to get(standard 100) page = index of limit(if limit = 100, index 0 = 1 - 100, index 1 = 101 -200, index 2 = 202 - 300 etc...)","title":"listObjects(type, userID, limit, page)"},{"location":"1.%20implementation/ServerCallsFormat/#examples","text":"getting a users home object listObjects('home','5264dc23-a339-40db-bb84-e0849ded4e68') returns the object: [ { \"collection\": \"home\", \"key\": \"Amsterdam\", \"permission_read\": 2, \"permission_write\": 1, \"value\": { \"url\": \"home/5264dc23-a339-40db-bb84-e0849ded4e68/current.png\", \"posX\": 228.16, \"posY\": 57.66, \"userName\": \"user11\" }, \"version\": \"d1be852d6a66654ec9faa878fcb41b7d\", \"user_id\": \"5264dc23-a339-40db-bb84-e0849ded4e68\", \"create_time\": \"2022-01-12T12:31:53Z\", \"update_time\": \"2022-01-13T15:45:02Z\" } ]","title":"examples"},{"location":"1.%20implementation/ServerCallsFormat/#convert-images","text":"convertImage(path,size, format) output: \"https://d3hkghsa3z4n1z.cloudfront.net/fit-in/64x64/filters:trim()/avatar/4ced8bff-d79c-4842-b2bd-39e9d9aa597e/current.png?signature=cbda2578e5612c70c009ebc6e0424e9025078aa94517543b310bf01eedefb167\" size and format at not both required to work, either one or both will also function for example: convertImage(path,, format) This is a replacement for getAvatar() if needed more filters can be added in the future, see: https://docs.aws.amazon.com/solutions/latest/serverless-image-handler/thumbor-filters.html","title":"convert images"},{"location":"1.%20implementation/ServerCallsFormat/#listallobjectstype-id-limit-cursor","text":"type is eg drawing, location, etc ... id is userID(or undefined , but not null or \"\" ) limit is the max number of objects you want to receive (either by page or in total) cursor is on the first call ```undefined```` (just empty), when supplied, it defines the next page of limit-number of objects. The cursor is the last objects update time, so: objects[limit - 1].update_time Results come back within .objects array: [ { collection: \"drawing\" downloaded: true key: \"2023-01-02T21_50_42_GeelAvoceta\" permission_read: 1 read: 1 update_time: \"2023-01-20T16:55:15.02286+01:00\" user_id: \"f011a5dc-901a-42c0-9589-587b389d1e3e\" username: \"user11\" value: displayname: \"bloem\" url: \"drawing/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-02T21_50_42_GeelAvoceta.png\" version: \"0\" }, ..... ] update_time: \"2023-01-20T16:55:15.02286+01:00\" of the last object is used as the cursor to get the next page of objects.","title":"listAllObjects(type, id, limit, cursor)"},{"location":"1.%20implementation/ServerCallsFormat/#validatestringtypeinput","text":"","title":"validate(string,type,input)"},{"location":"1.%20implementation/ServerCallsFormat/#types","text":"email - validates email adresses password - validates length is betweenm 5 and 10 characters repeat password - checks if password and repeat password are identical special - checks if the value contains no special characters","title":"types"},{"location":"1.%20implementation/ServerCallsFormat/#examples_1","text":"can be used in 2 ways, inline, automatically sets border to red if fail <input type=\"text\" placeholder=\"Enter Username\" name=\"username\" id=\"username\" bind:value={username} on:keyup={async input => {await validate(username,\"special\",input)}} required /> or can used within a function as following: if(await validate(email,\"email\")){ // run action if valid } else { // run if invalid )","title":"examples:"},{"location":"1.%20implementation/ServerCallsFormat/#setloaderstate","text":"setLoader(true) sets loading screen on setLoader(false) sets loading screen off","title":"setLoader(state)"},{"location":"1.%20implementation/ServerCallsFormat/#getallhouseslocationuser_id","text":"Gives you all the houses objects within the location, optionally add a user_id example result: [ { \"read\": 2, \"artworks\": { \"stopmotion\": 1, \"drawing\": 3 }, \"username\": \"user6\", \"key\": \"Amsterdam\", \"collection\": \"home\", \"update_time\": \"2022-08-08T15:17:06.817697+02:00\", \"permission_read\": 2, \"value\": { \"username\": \"user6\", \"url\": \"home/fcbcc269-a109-4a4b-a570-5ccafc5308d8/5_current.png\", \"posX\": -904.9999877562127, \"posY\": 72.49999139457941, \"version\": 5 }, \"user_id\": \"fcbcc269-a109-4a4b-a570-5ccafc5308d8\" },","title":"getAllHouses(location,user_id)"},{"location":"1.%20implementation/Storage.js/","text":"Storage.js is there to create a bridge between local storage(svelte sessions and accessible arrays for Phaser) and the server storage. Achievements Likes Addressbook","title":"Storage.js"},{"location":"1.%20implementation/Storage.js/#achievements","text":"","title":"Achievements"},{"location":"1.%20implementation/Storage.js/#likes","text":"","title":"Likes"},{"location":"1.%20implementation/Storage.js/#addressbook","text":"","title":"Addressbook"},{"location":"1.%20implementation/Svelte-spa-router-query-params-demo---refactoring/","text":"","title":"Svelte spa router query params demo   refactoring"},{"location":"1.%20implementation/UI-scrollable-panels/","text":"","title":"UI scrollable panels"},{"location":"2.%20research%20notes/Icons-and-svg-FREE/","text":"Free https://www.svgrepo.com/ https://icons8.com/icons/set/svg https://freeicons.io/ https://uxwing.com/ https://simpleicons.org/ Payed https://www.flaticon.com/ https://www.freepik.com/","title":"Icons and svg FREE"},{"location":"2.%20research%20notes/Icons-and-svg-FREE/#free","text":"https://www.svgrepo.com/ https://icons8.com/icons/set/svg https://freeicons.io/ https://uxwing.com/ https://simpleicons.org/","title":"Free"},{"location":"2.%20research%20notes/Icons-and-svg-FREE/#payed","text":"https://www.flaticon.com/ https://www.freepik.com/","title":"Payed"},{"location":"2.%20research%20notes/phaser3/A-canvas-can-be-used-as-a-Texture/","text":"addCanvas(key, source [, skipCache]) Creates a new Canvas Texture object from an existing Canvas element and adds it to this Texture Manager, unless skipCache is true. Parameters: Name Type Argument Default Description key string The unique string-based key of the Texture. source HTMLCanvasElement The Canvas element to form the base of the new Texture. skipCache boolean false Skip adding this Texture into the Cache? Example: https://phaser.io/examples/v3/view/textures/create-canvas addGLTexture(key, glTexture [, width] [, height]) Takes a WebGL Texture and creates a Phaser Texture from it, which is added to the Texture Manager using the given key. This allows you to then use the Texture as a normal texture for texture based Game Objects like Sprites. If the width and height arguments are omitted, but the WebGL Texture was created by Phaser\u2019s WebGL Renderer and has glTexture.width and glTexture.height properties, these values will be used instead. This is a WebGL only feature. addImage(key, source [, dataSource]) Adds a new Texture to the Texture Manager created from the given Image element. dataSource HTMLImageElement | HTMLCanvasElement addRenderTexture(key, renderTexture) Adds a Render Texture to the Texture Manager using the given key. This allows you to then use the Render Texture as a normal texture for texture based Game Objects like Sprites. renderTexture Phaser.GameObjects.RenderTexture","title":"A canvas can be used as a Texture"},{"location":"2.%20research%20notes/phaser3/Add-3D-to-Phaser/","text":"Build fake 3D HTML5 games with Phaser, Arcade physics, three.js and Phaser 3D library https://enable3d.io/docs.html https://enable3d.io/examples.html https://enable3d.io/examples/custom-setup.html https://enable3d.io/examples/isometric-game-orthographic-camera.html https://enable3d.io/examples/load-and-use-textures.html https://enable3d.io/examples/shape-showcase.html https://enable3d.io/examples/fbx-loader-and-animations.html discussion: https://phaser.discourse.group/t/phaser-in-3d-with-physics-yes-it-works-using-enable3d/4610/35 Sync 2D to 3D https://enable3d.io/examples/sync-2d-to-3d.html Sync 3D to 2D https://enable3d.io/examples/sync-3d-to-2d.html","title":"Add 3D to Phaser"},{"location":"2.%20research%20notes/phaser3/Add-a-plugin-to-a-scene/","text":"Global Plugin: https://phaser.io/examples/v3/view/plugins/global-scene-plugin","title":"Add a plugin to a scene"},{"location":"2.%20research%20notes/phaser3/Add-scene-on-the-fly/","text":"https://phaser.io/examples/v3/view/scenes/scene-add Add Scene After Game, with passing on data Add Scene From Another Scene Add and start Scene Scene Files Payload Files specified in the Scene config files payload will be loaded in before the Scene is started, meaning they're available before even the Scene.preload function (if set) is called This is perfect for loading in small JSON config files for example, or a tiny amount of preloader assets that the preloader itself needs to use.","title":"Add scene on the fly"},{"location":"2.%20research%20notes/phaser3/Automatic-Scene-loading-flag/","text":"super({ key: \u201cAZC1_Scene\u201d, active: true}); when there is a active: true flag, the scene gets loaded even when it is not the first in line. Scenes get loaded in order of the config scenes: [scene1, scene2, scene3] scene1 gets loaded first, but scene2 get loaded after that when active: true, default is: active: false","title":"Automatic Scene loading flag"},{"location":"2.%20research%20notes/phaser3/Background-image-repeating/","text":"","title":"Background image repeating"},{"location":"2.%20research%20notes/phaser3/Camera-effects%2C-colors%2C-fade/","text":"Fade camera out from color: this.cameras.main.fadeFrom(2000, Phaser.Math.Between(50, 255), Phaser.Math.Between(50, 255), Phaser.Math.Between(50, 255)); this.cameras.main.on('camerafadeoutcomplete', function () { this.scene.restart(); }, this); Fade camera in to color: var red = Phaser.Math.Between(50, 255); var green = Phaser.Math.Between(50, 255); var blue = Phaser.Math.Between(50, 255); this.cameras.main.fade(2000, red, green, blue);","title":"Camera effects, colors, fade"},{"location":"2.%20research%20notes/phaser3/Camera-follow/","text":"Camera follows player with: this.gameCam = this.cameras.main; this.gameCam.startFollow(this.player); //setBounds has to be set before follow, otherwise the camera doesn\u2019t follow! Order is: this.gameCam = this.cameras.main; this.gameCam.setBounds(0, 0, map.widthInPixels, map.heightInPixels); this.gameCam.startFollow(this.player);","title":"Camera follow"},{"location":"2.%20research%20notes/phaser3/Change-Gravity-per-sce/","text":"You can specify the gravity for a particular scene by redefining the physics settings in the scene\u2019s constructor method. class FirstScene extends Phaser.Scene { constructor() { super({ key: 'first', physics: { default: 'arcade', arcade: { gravity: { y: 2000 } } } }); } Check out the API Docs to see what else can be configured on a scene-by-scene basis.","title":"Change Gravity per sce"},{"location":"2.%20research%20notes/phaser3/Changing-the-collision-shape%2C-size%2C-mouse-input-events/","text":"All collision examples: http://labs.phaser.io/index.html?dir=physics/arcade/&q= The video explains how to set the size of the collision rectangle Eg star object set the box to 100, 200 pix, true sets it in the middle star.body.setSize(100,200, true); Change the shape to a circle: star.body.setCircle(100, -100 + star.body.halfHeight, -100 + star.body.halfWidth) Center the circle https://phaser.discourse.group/t/circular-collider-using-setcircle-is-not-centred-properly/8263/3 .setInteractive is to get pointer input events. Change the shape/ hit area like this: let star = this.add.image(100,100, \u201cstar\u201d) var shape = new Phaser.Geom.Polygon([ 0, 143, 200, 143, 220, 200, 0, 200 ]); star.setInteractive(shape, Phaser.Geom.Polygon.Contains); this.input.on(\u2018gameobjectover\u2019, function (pointer, gameObject) { gameObject.setTint(0x7878ff); console.log(\u201cmouse over\u201d) }); this.input.on(\u2018gameobjectout\u2019, function (pointer, gameObject) { gameObject.clearTint(); }); // Draw the polygon var graphics = this.add.graphics({ x: star.x, y: star.y}); graphics.lineStyle(2, 0x00aa00); graphics.beginPath(); graphics.moveTo(shape.points[0].x, shape.points[0].y); for (var i = 1; i < shape.points.length; i++) { graphics.lineTo(shape.points[i].x, shape.points[i].y); } graphics.closePath(); graphics.strokePath(); mousing over the green shape makes the start change color Mouse input with setInteractive, input area, attach input to GameObject: this.location2DialogBox = this.add.graphics(); this.location2DialogBox.fillStyle(0xfffff00, 0.4) this.location2DialogBox.fillRoundedRect(0, 0, mainWidth, mainHeight, 32) this.location2DialogBox.setVisible(false) this.realtimeTexture = this.add.renderTexture(0, 0, mainWidth, mainHeight); this.realtimeTexture.draw(this.location2DialogBox); this.realtimeTexture.setInteractive(new Phaser.Geom.Rectangle(0, 0, mainWidth, mainWidth), Phaser.Geom.Rectangle.Contains) this.realtimeTexture.on(\u2018pointerdown\u2019, () => { this.enterLocation2Scene() }); Add an existing GameObject to the physics this.physics.add.existing(Gameobject) Works also with graphics using matter physics: https://www.thepolyglotdeveloper.com/2020/08/use-matterjs-physics-sprite-collisions-phaser-game/","title":"Changing the collision shape, size, mouse input events"},{"location":"2.%20research%20notes/phaser3/Check-world-bounds/","text":"To enable the player to collide with the world bounds (in Player): scene.player.setCollideWorldBounds(true) scene.player.onWorldBounds = true scene.player.body.onWorldBounds = true scene.player.body.checkCollision.up = true scene.player.body.checkCollision.down = true scene.player.body.checkCollision.left = true scene.player.body.checkCollision.right = true To catch the collided object with the world bounds (in the scene): this.physics.world.on('worldbounds', (collidingObject) => { })","title":"Check world bounds"},{"location":"2.%20research%20notes/phaser3/Check-world-bounds/#to-enable-the-player-to-collide-with-the-world-bounds-in-player","text":"scene.player.setCollideWorldBounds(true) scene.player.onWorldBounds = true scene.player.body.onWorldBounds = true scene.player.body.checkCollision.up = true scene.player.body.checkCollision.down = true scene.player.body.checkCollision.left = true scene.player.body.checkCollision.right = true","title":"To enable the player to collide with the world bounds (in Player):"},{"location":"2.%20research%20notes/phaser3/Check-world-bounds/#to-catch-the-collided-object-with-the-world-bounds-in-the-scene","text":"this.physics.world.on('worldbounds', (collidingObject) => { })","title":"To catch the collided object with the world bounds (in the scene):"},{"location":"2.%20research%20notes/phaser3/DOM-elements-in-phaser-and-as-input/","text":"Css Text https://phaser.io/examples/v3/view/game-objects/dom-element/css-text Css Style Object https://phaser.io/examples/v3/view/game-objects/dom-element/css-style-object All dome examples: https://phaser.io/examples/v3/category/game-objects/dom-element","title":"DOM elements in phaser and as input"},{"location":"2.%20research%20notes/phaser3/Datamanager-system-registry/","text":"A reference to the global registry. This is a game-wide instance of the Data Manager, allowing you to exchange data between Scenes via a universal and shared point. In the default set-up you can access this from within a Scene via the this.registry property. Example: Central Data Storage and exchange between Scenes with Data Registry","title":"Datamanager system registry"},{"location":"2.%20research%20notes/phaser3/Disable-mouse-input-from-outside-the-canvas/","text":"","title":"Disable mouse input from outside the canvas"},{"location":"2.%20research%20notes/phaser3/Drag-containers-%28also-scenes%21%29/","text":"","title":"Drag containers (also scenes!)"},{"location":"2.%20research%20notes/phaser3/Dragging/","text":"Via general purpose this.input.on(\u2018drag\u2019 var container = this.add.container(400, 300, [ bg, text ]); container.setSize(bg.width, bg.height); container.setInteractive(); this.input.setDraggable(container); this.input.on('drag', function (pointer, gameObject, dragX, dragY) { gameObject.x = dragX; gameObject.y = dragY; }); 2. Via per object .setInteractive( { draggable: true }) this.mario_star.setInteractive({ draggable: true }) this.mario_star.on('dragstart', function (pointer) { this.setTint(0xff0000); }) this.mario_star.on('drag', function (pointer, dragX, dragY) { this.x = dragX; this.y = dragY; }) this.mario_star.on('dragend', function (pointer) { this.clearTint(); }) 3. Via general input check but with with checking, turning on/off listeners https://www.youtube.com/watch?v=t56DvozbZX4&ab_channel=WClarkson var dot = this.add.image(xx, yy, \"dot\" +i dot.setInteractive() } this.input.on('pointerdown', this.startDrag, this) } startDrag(pointer, targets){ this.input.off('pointerdown', this.startDrag, this) // turn off input when there is already a target(!) this.dragObj = targets[0] //first gameObject that is hit by the mouse pointer this.input.on('pointermove', this.doDrag, this) this.input.on('pointerup', this.stopDrag, this) } doDrag(pointer) { this.dragObj.x = pointer.x this.dragObj.y = pointer.y } stopDrag(){ this.input.on('pointerdown', this.startDrag, this) // turn back on input for pointerdown(!) this.input.off('pointermove', this.doDrag, this) // turn off drag this.input.off('pointerup', this.stopDrag, this) }","title":"Dragging"},{"location":"2.%20research%20notes/phaser3/Dragging/#via-general-purpose-thisinputondrag","text":"var container = this.add.container(400, 300, [ bg, text ]); container.setSize(bg.width, bg.height); container.setInteractive(); this.input.setDraggable(container); this.input.on('drag', function (pointer, gameObject, dragX, dragY) { gameObject.x = dragX; gameObject.y = dragY; });","title":"Via general purpose this.input.on(\u2018drag\u2019"},{"location":"2.%20research%20notes/phaser3/Dragging/#2-via-per-object-setinteractive-draggable-true","text":"this.mario_star.setInteractive({ draggable: true }) this.mario_star.on('dragstart', function (pointer) { this.setTint(0xff0000); }) this.mario_star.on('drag', function (pointer, dragX, dragY) { this.x = dragX; this.y = dragY; }) this.mario_star.on('dragend', function (pointer) { this.clearTint(); })","title":"2. Via per object .setInteractive( { draggable: true })"},{"location":"2.%20research%20notes/phaser3/Dragging/#3-via-general-input-check-but-with-with-checking-turning-onoff-listeners","text":"https://www.youtube.com/watch?v=t56DvozbZX4&ab_channel=WClarkson var dot = this.add.image(xx, yy, \"dot\" +i dot.setInteractive() } this.input.on('pointerdown', this.startDrag, this) } startDrag(pointer, targets){ this.input.off('pointerdown', this.startDrag, this) // turn off input when there is already a target(!) this.dragObj = targets[0] //first gameObject that is hit by the mouse pointer this.input.on('pointermove', this.doDrag, this) this.input.on('pointerup', this.stopDrag, this) } doDrag(pointer) { this.dragObj.x = pointer.x this.dragObj.y = pointer.y } stopDrag(){ this.input.on('pointerdown', this.startDrag, this) // turn back on input for pointerdown(!) this.input.off('pointermove', this.doDrag, this) // turn off drag this.input.off('pointerup', this.stopDrag, this) }","title":"3. Via general input check but with with checking, turning on/off listeners"},{"location":"2.%20research%20notes/phaser3/Drawing-ideas-and-examples-Phaser/","text":"Drawing with rope: https://phaser.io/examples/v3/view/game-objects/rope/draw-rope-gradient Draw on live texture: https://phaser.io/examples/v3/view/game-objects/render-texture/draw-on-texture erase part of texture: https://phaser.io/examples/v3/view/game-objects/render-texture/erase-part-of-render-texture Draw with sprites: https://phaser.io/examples/v3/view/input/pointer/draw-sprites color picker: https://phaser.io/examples/v3/view/game-objects/shapes/iso-draw Draw with interpolation: https://phaser.io/examples/v3/view/game-objects/render-texture/paint-interpolated Draw (with mouse or shapes) in a RenderTexture A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and draw them all to this one texture, which can they be used as the texture for other Game Object\u2019s. It\u2019s a way to generate dynamic textures at run-time that are WebGL friendly and don\u2019t invoke expensive GPU uploads. Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that to the Render Texture. https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.RenderTexture.htmlhttps://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.RenderTexture.html Example: https://phaser.io/examples/v3/view/game-objects/render-texture/shape-to-render-texture# Draw on live texture: https://phaser.io/examples/v3/view/game-objects/render-texture/draw-on-texture","title":"Drawing ideas and examples Phaser"},{"location":"2.%20research%20notes/phaser3/Drawing-ideas-and-examples-Phaser/#draw-with-mouse-or-shapes-in-a-rendertexture","text":"A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and draw them all to this one texture, which can they be used as the texture for other Game Object\u2019s. It\u2019s a way to generate dynamic textures at run-time that are WebGL friendly and don\u2019t invoke expensive GPU uploads. Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that to the Render Texture. https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.RenderTexture.htmlhttps://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.RenderTexture.html Example: https://phaser.io/examples/v3/view/game-objects/render-texture/shape-to-render-texture# Draw on live texture: https://phaser.io/examples/v3/view/game-objects/render-texture/draw-on-texture","title":"Draw (with mouse or shapes) in a RenderTexture"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/","text":"Grid var g1 = this.add.grid(0, 0, 3200, 3200, 32, 32, 0xFFFFFF) Map with dot as Tileset The map is still generated as an image, so there is no benefit when zooming in. Dot repeating with grid methods let group = this.add.group({ key: 'dot', repeat: 8000, setX: { x: 0, y: 0, stepX: 64 } }); Phaser.Actions.GridAlign(group.getChildren(), { width: 100, height: 200, cellWidth: 64, cellHeight: 64, x: 16, y: 16 }); There is not a sharpness advantage, because the SVG is being converted to an image when loading. You can preload the SVG scaled, that will actually create a scaled up image. See: https://phaser.io/examples/v3/view/loader/svg/load-svg-with-scale graphics elements let circles = [] <br><br>const graphics = this.add.graphics();<br><br>graphics.fillStyle(0xffffff); <br>graphics.fillRect(0, 0, 3000, 3000);<br><br>graphics.fillStyle(color, alpha); const offset = 50 <br>for (let i = 0; i &lt; 2000; i += offset) { <br>for (let j = 0; j &lt; 2000; j += offset) { <br>circles[i] = graphics.fillCircle(i, j, 2); This works but there is slowness when loading the array, and when the player is moving accross the field the graphics scrolling is not smooth This works really well: Here is a way to generate patterns on a texture with an array: et cross = [ '.....', '..1..', '.111.', '..1..', '.....', ] //generate the texture from the array this.textures.generate('cross', { data: cross, pixelWidth: 4 }); //display the texture on an image const gridWidth = 4000 const offset = 40 for (let i=0;i< gridWidth; i += offset){ for (let j=0;j< gridWidth; j += offset){ this.add.image(i, j, 'cross').setOrigin(0, 1); } } Draw a shape to a texture, and repeat it there. Slow to generate, but fast after that. // //display the texture on an image const gridWidth = 4000 const offset = 50 let rt = this.add.renderTexture(0, 0, gridWidth, gridWidth); let circle = this.add.circle(-1000, -1000, 6, 0x6666ff) for (let i = 0; i < gridWidth; i += offset) { for (let j = 0; j < gridWidth; j += offset) { rt.draw(circle, i, j); } } let cross = [ '.....', '..1..', '.111.', '..1..', '.....', ] //generate the texture from the array this.textures.generate('cross', { data: cross, pixelWidth: 2 }); //display the texture on an image const gridWidth = 4000 const offset = 50 for (let i = 0; i < gridWidth; i += offset) { for (let j = 0; j < gridWidth; j += offset) { this.add.image(i, j, 'cross').setOrigin(0, 1); } } let graphics = this.add.graphics(); graphics.fillStyle(0x0000ff, 1); graphics.fillCircle(800, 300, 200); for (let i = 0; i < 250; i += 60) { graphics.lineStyle(5, 0xFF00FF, 1.0); graphics.beginPath(); graphics.moveTo(800, 200 + i); graphics.lineTo(1200, 200 + i); graphics.closePath(); graphics.strokePath(); } for (let i = 0; i < 250; i += 60) { graphics.lineStyle(5, 0xFF00FF, 1.0); graphics.beginPath(); graphics.moveTo(900 + i, 150); graphics.lineTo(900 + i, 550); graphics.closePath(); graphics.strokePath(); } let rectangle = this.add.graphics(); rectangle.setVisible(false); rectangle.fillGradientStyle(0xff0000, 0xff0000, 0xffff00, 0xffff00, 1); rectangle.fillRect(0, 0, 400, 400); let rt = this.add.renderTexture(200, 100, 600, 600); let rt2 = this.add.renderTexture(100, 600, 600, 600); rt.draw(rectangle); rt2.draw(rectangle); let eraser = this.add.circle(0, 0, 190, 0x000000); eraser.setVisible(false); rt.erase(eraser, 200, 200); rt2.erase(rt, 0, 0) rt2.x = 400 rt2.y = 600","title":"Experimenting with different backgrounds"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#grid","text":"var g1 = this.add.grid(0, 0, 3200, 3200, 32, 32, 0xFFFFFF)","title":"Grid"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#map-with-dot-as-tileset","text":"The map is still generated as an image, so there is no benefit when zooming in.","title":"Map with dot as Tileset"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#dot-repeating-with-grid-methods","text":"let group = this.add.group({ key: 'dot', repeat: 8000, setX: { x: 0, y: 0, stepX: 64 } }); Phaser.Actions.GridAlign(group.getChildren(), { width: 100, height: 200, cellWidth: 64, cellHeight: 64, x: 16, y: 16 }); There is not a sharpness advantage, because the SVG is being converted to an image when loading. You can preload the SVG scaled, that will actually create a scaled up image. See: https://phaser.io/examples/v3/view/loader/svg/load-svg-with-scale","title":"Dot repeating with grid methods"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#graphics-elements","text":"let circles = [] <br><br>const graphics = this.add.graphics();<br><br>graphics.fillStyle(0xffffff); <br>graphics.fillRect(0, 0, 3000, 3000);<br><br>graphics.fillStyle(color, alpha); const offset = 50 <br>for (let i = 0; i &lt; 2000; i += offset) { <br>for (let j = 0; j &lt; 2000; j += offset) { <br>circles[i] = graphics.fillCircle(i, j, 2); This works but there is slowness when loading the array, and when the player is moving accross the field the graphics scrolling is not smooth","title":"graphics elements"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#this-works-really-well","text":"","title":"This works really well:"},{"location":"2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/#here-is-a-way-to-generate-patterns-on-a-texture-with-an-array","text":"et cross = [ '.....', '..1..', '.111.', '..1..', '.....', ] //generate the texture from the array this.textures.generate('cross', { data: cross, pixelWidth: 4 }); //display the texture on an image const gridWidth = 4000 const offset = 40 for (let i=0;i< gridWidth; i += offset){ for (let j=0;j< gridWidth; j += offset){ this.add.image(i, j, 'cross').setOrigin(0, 1); } } Draw a shape to a texture, and repeat it there. Slow to generate, but fast after that. // //display the texture on an image const gridWidth = 4000 const offset = 50 let rt = this.add.renderTexture(0, 0, gridWidth, gridWidth); let circle = this.add.circle(-1000, -1000, 6, 0x6666ff) for (let i = 0; i < gridWidth; i += offset) { for (let j = 0; j < gridWidth; j += offset) { rt.draw(circle, i, j); } } let cross = [ '.....', '..1..', '.111.', '..1..', '.....', ] //generate the texture from the array this.textures.generate('cross', { data: cross, pixelWidth: 2 }); //display the texture on an image const gridWidth = 4000 const offset = 50 for (let i = 0; i < gridWidth; i += offset) { for (let j = 0; j < gridWidth; j += offset) { this.add.image(i, j, 'cross').setOrigin(0, 1); } } let graphics = this.add.graphics(); graphics.fillStyle(0x0000ff, 1); graphics.fillCircle(800, 300, 200); for (let i = 0; i < 250; i += 60) { graphics.lineStyle(5, 0xFF00FF, 1.0); graphics.beginPath(); graphics.moveTo(800, 200 + i); graphics.lineTo(1200, 200 + i); graphics.closePath(); graphics.strokePath(); } for (let i = 0; i < 250; i += 60) { graphics.lineStyle(5, 0xFF00FF, 1.0); graphics.beginPath(); graphics.moveTo(900 + i, 150); graphics.lineTo(900 + i, 550); graphics.closePath(); graphics.strokePath(); } let rectangle = this.add.graphics(); rectangle.setVisible(false); rectangle.fillGradientStyle(0xff0000, 0xff0000, 0xffff00, 0xffff00, 1); rectangle.fillRect(0, 0, 400, 400); let rt = this.add.renderTexture(200, 100, 600, 600); let rt2 = this.add.renderTexture(100, 600, 600, 600); rt.draw(rectangle); rt2.draw(rectangle); let eraser = this.add.circle(0, 0, 190, 0x000000); eraser.setVisible(false); rt.erase(eraser, 200, 200); rt2.erase(rt, 0, 0) rt2.x = 400 rt2.y = 600","title":"Here is a way to generate patterns on a texture with an array:"},{"location":"2.%20research%20notes/phaser3/Groups-vs-containers/","text":"We want to get a list of all Network Players. getChildren() can be called Groups can be used to get the members with getChildren() Children of the group can\u2019t be moved with the grouping Containers can be used to move members. does not work: * this.getChildren() * this.scene.getChildren() * this.Scene.getChildren() Works: * Group.getChildren() group.create(400, 300, \u2018phaser\u2019); // The above is a short-cut for: // var sprite = this.add.sprite(400, 300, 'phaser'); // group.add(sprite); Sprite pool example https://phaser.io/examples/v3/view/game-objects/group/sprite-pool Group createCallback group = this.add.group({ defaultKey: \u2018alien\u2019, maxSize: 100, createCallback: function (alien) { alien.setName(\u2018alien\u2019 + this.getLength()); console.log(\u2018Created\u2019, alien.name); }, removeCallback: function (alien) { console.log(\u2018Removed\u2019, alien.name); } this.time.addEvent({ delay: 100, loop: true, callback: addAlien }); group.children.iterate // Find first inactive sprite in group or add new sprite, and set position const alien = group.get(x, y);","title":"Groups vs containers"},{"location":"2.%20research%20notes/phaser3/How-to-manage-lots-of-particle-emitter-managers/","text":"https://phaser.discourse.group/t/how-to-manage-lots-of-particle-emitter-managers/12654 You could pool them, but you might not have to. For most situations you need only one manager per particle texture. You can create as many emitters as you need from one manager. Remove an emitter you never want to use again. To disable an emitter temporarily, you can set its on = false and visible = false .","title":"Note: How to manage lots of Particle Emitter (Managers)?"},{"location":"2.%20research%20notes/phaser3/Infinite-world/","text":"Top-down Infinite Terrain Generation with Phaser 3 https://learn.yorkcs.com/2019/02/25/top-down-infinite-terrain-generation-with-phaser-3/ How to Create an Infinite Climbing Game in Phaser https://www.joshmorony.com/how-to-create-an-infinite-climbing-game-in-phaser/ How to Make an Infinitely Scrolling Game with Phaser https://gamedevacademy.org/how-to-make-an-infinitely-scrolling-game-with-phaser/ Performance of really big tile maps https://phaser.discourse.group/t/performance-of-really-big-tile-maps/1192/9","title":"Infinite world"},{"location":"2.%20research%20notes/phaser3/LoaderPlugin-feedback/","text":"LoaderPlugin Good info: https://rexrainbow.github.io/phaser3-rex-notes/docs/site/loader/ When queue has loaded and completed, it can be found through the key of the event listener: this.load.once(\"complete\", (key) => {}) The key shows properties such as: totalToLoad: 5 totalFailed: 0 totalComplete: 5 Getting loading completion feedback this.load.image(key) will put the file in the queue this.load.start() starts the queue this.load.image('cakewalk'); this.load.image('flectrum'); this.load.image('fork'); this.load.start() this.load.on('complete', ...) fires when the queue is done loading all the images. this.load.on('complete', subLoadCompleted, this); function subLoadCompleted () { console.log('Load Complete') } Feedback about the download progress of a specific file this.load.on('fileprogress', function (file, value) { if (file.key === 'goldrunner') { progress.clear(); progress.fillStyle(0xffffff, 0.4); progress.fillRect(450, 500 - (value * 400), 200, value * 400); } }) this.load.on('complete', function () { progress.destroy() }) Get filecomplete on a specific file name!!! this.load.on('filecomplete-image-taikodrummaster', addImage, this) function addImage (key, file) { this.add.image(400, 300, key) } For a spritesheet: this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) { // Your handler code }) Phaser.Loader.Events FILE_COMPLETE https://phaser.io/examples/v3/view/loader/loader-events/file-complete-event-with-key https://phaser.io/examples/v3/view/loader/loader-events/file-complete-event# Loader key object animation: \u0192 (key, url, dataKey, xhrSettings) aseprite: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) atlas: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) atlasXML: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) audio: \u0192 (key, urls, config, xhrSettings) audioSprite: \u0192 (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) baseURL: \"\" binary: \u0192 (key, url, dataType, xhrSettings) bitmapFont: \u0192 (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) cacheManager: CacheManager {game: Game, binary: BaseCache, bitmapFont: BaseCache, json: BaseCache, physics: BaseCache, \u2026} crossOrigin: undefined css: \u0192 (key, url, xhrSettings) glsl: \u0192 (key, url, shaderType, xhrSettings) html: \u0192 (key, url, xhrSettings) htmlTexture: \u0192 (key, url, width, height, xhrSettings) image: \u0192 (key, url, xhrSettings) inflight: Set {entries: Array(0)} json: \u0192 (key, url, dataKey, xhrSettings) list: Set {entries: Array(0)} maxParallelDownloads: 32 multiKeyIndex: 0 multiatlas: \u0192 (key, atlasURL, path, baseURL, atlasXhrSettings) obj: \u0192 (key, objURL, matURL, flipUVs, xhrSettings) pack: \u0192 (key, url, packKey, xhrSettings) path: \"\" plugin: \u0192 (key, url, start, mapping, xhrSettings) prefix: \"\" progress: 1 queue: Set {entries: Array(0)} scene: ArtworldAmsterdam {sys: Systems, worldSize: Vector2, debug: false, gameStarted: false, phaser: ArtworldAmsterdam, \u2026} sceneFile: \u0192 (key, url, xhrSettings) sceneManager: SceneManager {game: Game, keys: {\u2026}, scenes: Array(12), _pending: Array(0), _start: Array(0), \u2026} scenePlugin: \u0192 (key, url, systemKey, sceneKey, xhrSettings) script: \u0192 (key, url, xhrSettings) scripts: \u0192 (key, url, xhrSettings) spritesheet: \u0192 (key, url, frameConfig, xhrSettings) state: 3 svg: \u0192 (key, url, svgConfig, xhrSettings) systems: Systems {scene: ArtworldAmsterdam, config: 'ArtworldAmsterdam', settings: {\u2026}, game: Game, sceneUpdate: \u0192, \u2026} text: \u0192 (key, url, xhrSettings) textureManager: TextureManager {_events: Events, _eventsCount: 0, game: Game, name: 'TextureManager', list: {\u2026}, \u2026} tilemapCSV: \u0192 (key, url, xhrSettings) tilemapImpact: \u0192 (key, url, xhrSettings) tilemapTiledJSON: \u0192 (key, url, xhrSettings) totalComplete: 5 totalFailed: 0 totalToLoad: 5 unityAtlas: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) video: \u0192 (key, urls, loadEvent, asBlob, noAudio, xhrSettings) xhr: {responseType: '', async: true, user: '', password: '', timeout: 0, \u2026} xml: \u0192 (key, url, xhrSettings) _deleteQueue: Set {entries: Array(0)} _events: Events {progress: Array(2), fileprogress: Array(2), complete: Array(2)} _eventsCount: 3","title":"LoaderPlugin feedback"},{"location":"2.%20research%20notes/phaser3/LoaderPlugin-feedback/#loaderplugin","text":"Good info: https://rexrainbow.github.io/phaser3-rex-notes/docs/site/loader/ When queue has loaded and completed, it can be found through the key of the event listener: this.load.once(\"complete\", (key) => {}) The key shows properties such as: totalToLoad: 5 totalFailed: 0 totalComplete: 5","title":"LoaderPlugin"},{"location":"2.%20research%20notes/phaser3/LoaderPlugin-feedback/#getting-loading-completion-feedback","text":"this.load.image(key) will put the file in the queue this.load.start() starts the queue this.load.image('cakewalk'); this.load.image('flectrum'); this.load.image('fork'); this.load.start() this.load.on('complete', ...) fires when the queue is done loading all the images. this.load.on('complete', subLoadCompleted, this); function subLoadCompleted () { console.log('Load Complete') } Feedback about the download progress of a specific file this.load.on('fileprogress', function (file, value) { if (file.key === 'goldrunner') { progress.clear(); progress.fillStyle(0xffffff, 0.4); progress.fillRect(450, 500 - (value * 400), 200, value * 400); } }) this.load.on('complete', function () { progress.destroy() })","title":"Getting loading completion feedback"},{"location":"2.%20research%20notes/phaser3/LoaderPlugin-feedback/#get-filecomplete-on-a-specific-file-name","text":"this.load.on('filecomplete-image-taikodrummaster', addImage, this) function addImage (key, file) { this.add.image(400, 300, key) } For a spritesheet: this.load.on('filecomplete-spritesheet-GAMEOVERExplosion', function (key, type, data) { // Your handler code }) Phaser.Loader.Events FILE_COMPLETE https://phaser.io/examples/v3/view/loader/loader-events/file-complete-event-with-key https://phaser.io/examples/v3/view/loader/loader-events/file-complete-event#","title":"Get filecomplete on a specific file name!!!"},{"location":"2.%20research%20notes/phaser3/LoaderPlugin-feedback/#loader-key-object","text":"animation: \u0192 (key, url, dataKey, xhrSettings) aseprite: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) atlas: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) atlasXML: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) audio: \u0192 (key, urls, config, xhrSettings) audioSprite: \u0192 (key, jsonURL, audioURL, audioConfig, audioXhrSettings, jsonXhrSettings) baseURL: \"\" binary: \u0192 (key, url, dataType, xhrSettings) bitmapFont: \u0192 (key, textureURL, fontDataURL, textureXhrSettings, fontDataXhrSettings) cacheManager: CacheManager {game: Game, binary: BaseCache, bitmapFont: BaseCache, json: BaseCache, physics: BaseCache, \u2026} crossOrigin: undefined css: \u0192 (key, url, xhrSettings) glsl: \u0192 (key, url, shaderType, xhrSettings) html: \u0192 (key, url, xhrSettings) htmlTexture: \u0192 (key, url, width, height, xhrSettings) image: \u0192 (key, url, xhrSettings) inflight: Set {entries: Array(0)} json: \u0192 (key, url, dataKey, xhrSettings) list: Set {entries: Array(0)} maxParallelDownloads: 32 multiKeyIndex: 0 multiatlas: \u0192 (key, atlasURL, path, baseURL, atlasXhrSettings) obj: \u0192 (key, objURL, matURL, flipUVs, xhrSettings) pack: \u0192 (key, url, packKey, xhrSettings) path: \"\" plugin: \u0192 (key, url, start, mapping, xhrSettings) prefix: \"\" progress: 1 queue: Set {entries: Array(0)} scene: ArtworldAmsterdam {sys: Systems, worldSize: Vector2, debug: false, gameStarted: false, phaser: ArtworldAmsterdam, \u2026} sceneFile: \u0192 (key, url, xhrSettings) sceneManager: SceneManager {game: Game, keys: {\u2026}, scenes: Array(12), _pending: Array(0), _start: Array(0), \u2026} scenePlugin: \u0192 (key, url, systemKey, sceneKey, xhrSettings) script: \u0192 (key, url, xhrSettings) scripts: \u0192 (key, url, xhrSettings) spritesheet: \u0192 (key, url, frameConfig, xhrSettings) state: 3 svg: \u0192 (key, url, svgConfig, xhrSettings) systems: Systems {scene: ArtworldAmsterdam, config: 'ArtworldAmsterdam', settings: {\u2026}, game: Game, sceneUpdate: \u0192, \u2026} text: \u0192 (key, url, xhrSettings) textureManager: TextureManager {_events: Events, _eventsCount: 0, game: Game, name: 'TextureManager', list: {\u2026}, \u2026} tilemapCSV: \u0192 (key, url, xhrSettings) tilemapImpact: \u0192 (key, url, xhrSettings) tilemapTiledJSON: \u0192 (key, url, xhrSettings) totalComplete: 5 totalFailed: 0 totalToLoad: 5 unityAtlas: \u0192 (key, textureURL, atlasURL, textureXhrSettings, atlasXhrSettings) video: \u0192 (key, urls, loadEvent, asBlob, noAudio, xhrSettings) xhr: {responseType: '', async: true, user: '', password: '', timeout: 0, \u2026} xml: \u0192 (key, url, xhrSettings) _deleteQueue: Set {entries: Array(0)} _events: Events {progress: Array(2), fileprogress: Array(2), complete: Array(2)} _eventsCount: 3","title":"Loader key object"},{"location":"2.%20research%20notes/phaser3/Loading-and-preloading/","text":"Create a preloading scene, show percentage loaded: https://gamedevacademy.org/creating-a-preloading-screen-in-phaser-3/?a=13 dealing cards example https://blog.ourcade.co/posts/2020/phaser3-load-images-dynamically/ phaser loader events https://newdocs.phaser.io/docs/3.55.2/events FILE_KEY_COMPLETE event https://newdocs.phaser.io/docs/3.55.2/Phaser.Loader.Events.FILE_KEY_COMPLETE FILE_PROGRESS event https://newdocs.phaser.io/docs/3.55.2/Phaser.Loader.Events.FILE_PROGRESS Loading User Avatar - during runtime his.load.image( this.playerAvatarName, manageSession.playerObjectSelf.url ); } this.load.once(Phaser.Loader.Events.COMPLETE, () => { // texture loaded so use instead of the placeholder this.player.setTexture(this.playerAvatarKey) console.log(\u201cplayer avatar has loaded \u201c) }) } this.load.start(); // load the image in memory The event to load a image or sprite works. I need to see if my method is save enough; I set a flag when the player is created (this.createdPlayer = true) Maybe it is saver to first create a general player, and then when the avatar is loaded, replace the image or sprite with this.player.setTexture(key, frame) heart1.setTexture(key [, frame]) https://www.html5gamedevs.com/topic/41170-how-can-i-change-the-image-of-a-sprite-during-update-function/ img.setTexture(key, frame) https://phaser.discourse.group/t/how-to-switch-sprites-of-a-game-object/297/3 See also phaser API: https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Image.html https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html","title":"Loading and preloading"},{"location":"2.%20research%20notes/phaser3/Loading-and-preloading/#loading-user-avatar-during-runtime","text":"his.load.image( this.playerAvatarName, manageSession.playerObjectSelf.url ); } this.load.once(Phaser.Loader.Events.COMPLETE, () => { // texture loaded so use instead of the placeholder this.player.setTexture(this.playerAvatarKey) console.log(\u201cplayer avatar has loaded \u201c) }) } this.load.start(); // load the image in memory The event to load a image or sprite works. I need to see if my method is save enough; I set a flag when the player is created (this.createdPlayer = true) Maybe it is saver to first create a general player, and then when the avatar is loaded, replace the image or sprite with this.player.setTexture(key, frame) heart1.setTexture(key [, frame]) https://www.html5gamedevs.com/topic/41170-how-can-i-change-the-image-of-a-sprite-during-update-function/ img.setTexture(key, frame) https://phaser.discourse.group/t/how-to-switch-sprites-of-a-game-object/297/3 See also phaser API: https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Image.html https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.Sprite.html","title":"Loading User Avatar - during runtime"},{"location":"2.%20research%20notes/phaser3/No-Physics-possible-between-Scenes/","text":"are separate in that way... (tried it)","title":"No Physics possible between Scenes"},{"location":"2.%20research%20notes/phaser3/Pause-and-resume-a-scene/","text":"sleep and wake scene https://phaser.io/examples/v3/view/scenes/sleep-and-wake","title":"Pause and resume a scene"},{"location":"2.%20research%20notes/phaser3/Pausing-game-engine/","text":"The closest would be this.game.loop.sleep(); in v3.60 there will be this.game.pause(); https://phaser.discourse.group/t/pausing-game-engine/12793/4","title":"Note:  Pausing game engine"},{"location":"2.%20research%20notes/phaser3/Phaser---timed-Events/","text":"Run a function on a timer, optionally looped timedEvent = this.time.addEvent({ delay: 50, callback: reduceHealth, callbackScope: this, loop: true }); Remove the timed event: timedEvent.remove(); Pass extra arguments to the timed event: this.time.addEvent({ delay: 2000, callback: this.enterLocationDialogBox, args: [player, location, show], loop: false }) standard javascript delay: setTimeout(this.enterLocationDialogBox(player, location, show), 5000); Rex Plugin: https://rexrainbow.github.io/phaser3-rex-notes/docs/site/timer/","title":"Phaser   timed Events"},{"location":"2.%20research%20notes/phaser3/Physics---overlap/","text":"Standard use: GameObject1, GameObject2, functions, (processCallback), scope function: An optional callback function that is called if the objects collide. processCallback An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then collideCallback will only be called if this callback returns true. Example: this.physics.add.overlap(this.player, this.location2, this.confirmEnterLocation, null, this); The 2 Objects are automatically passed as arguments, the sprite as the first (https://phaser.discourse.group/t/passing-argments-into-functions/4411/2) So this is passed on to the function as such: confirmEnterLocation(player, location) { console.log(player) //Object 1 console.log(location) //Object 2 } OVERLAP ZONE: https://phaser.io/examples/v3/view/physics/arcade/overlap-zone","title":"Physics   overlap"},{"location":"2.%20research%20notes/phaser3/Scaling-the-game---res-and-ppi/","text":"The best summary: https://www.joshmorony.com/how-to-scale-a-game-for-all-device-sizes-in-phaser/ ```game = new Phaser.Game( window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio, Phaser.CANVAS, 'gameArea' ); Scaling Game Assets The other issue we run into when scaling is with the size of graphical assets (i.e player sprites, objects and so on). If you create some object at 300 x 300 pixels and it looks great on a device with a DPR of 1 (i.e your desktop computer or an iPhone 4) it will probably look teeny tiny on devices with a higher DPR. Take the iPhone 5 for example again, although the object is 300 x 300 pixels it will only look like it's 150 x 150 pixels. We need the asset to be twice as big for iPhone 5's, so how do we handle this? What you can do is create the object to suit the highest DPR you are supporting, which will likely be 3. This means that your 300 x 300 object should actually be 900 x 900. Then we scale it down in game to suit the device that it is actually on. On a device with a DPR of 3 we do nothing, with a DPR of 2 we will scale it down to 2/3rds of it's original size and for a device with a DPR of 1 we will scale it down to 1/3rd of its original size. To do this, first you need to figure out what this scaleRatio is. Create a new globally stored variable with the following code: scaleRatio = window.devicePixelRatio / 3 and now whenever you add a new asset to the game, call the following method to scale it appropriately: myAsset.scale.setTo(scaleRatio, scaleRatio) ``` Now your asset will scale appropriately no matter what device your game is loaded on. many examples of fitting and scaling, resizing: https://phaser.io/examples/v3/category/scalemanager Basics to Deal with Multiple Resolutions & Device Pixel Density in Phaser 3","title":"Scaling the game   res and ppi"},{"location":"2.%20research%20notes/phaser3/Sending-data-to-scenes/","text":"passing data to a scene https://phaser.io/examples/v3/view/scenes/passing-data-to-a-scene sending events to scenes: https://phaser.io/examples/v3/view/scenes/ui-scene","title":"Sending data to scenes"},{"location":"2.%20research%20notes/phaser3/Separate-UI-with-a-overlay-Scene/","text":"More on mixing scenes: https://phaser.io/examples/v3/view/input/dragging/multiple-scene-drag\">https://phaser.io/examples/v3/view/input/dragging/multiple-scene-drag","title":"Separate UI with a overlay Scene"},{"location":"2.%20research%20notes/phaser3/Speech-bubble-GRAPHIC-across-SCENES/","text":"function createSpeechBubble (scene, x, y, width, height, quote) { var bubbleWidth = width; var bubbleHeight = height; var bubblePadding = 10; var arrowHeight = bubbleHeight / 3; var bubble = scene.add.graphics({ x: x, y: y }); // Bubble shadow bubble.fillStyle(0x222222, 0.5); bubble.fillRoundedRect(6, 6, bubbleWidth, bubbleHeight, 16); // Bubble color bubble.fillStyle(0xffffff, 1); // Bubble outline line style bubble.lineStyle(4, 0x565656, 1); // Bubble shape and outline bubble.strokeRoundedRect(0, 0, bubbleWidth, bubbleHeight, 16); bubble.fillRoundedRect(0, 0, bubbleWidth, bubbleHeight, 16); // Calculate arrow coordinates var point1X = Math.floor(bubbleWidth / 4); var point1Y = bubbleHeight; var point2X = Math.floor((bubbleWidth / 4) * 1.4); var point2Y = bubbleHeight; var point3X = Math.floor(bubbleWidth / 4); var point3Y = Math.floor(bubbleHeight + arrowHeight); // Bubble arrow shadow bubble.lineStyle(4, 0x222222, 0.5); bubble.lineBetween(point2X - 1, point2Y + 6, point3X + 2, point3Y); // Bubble arrow fill bubble.fillTriangle(point1X, point1Y, point2X, point2Y, point3X, point3Y); bubble.lineStyle(2, 0x565656, 1); bubble.lineBetween(point2X, point2Y, point3X, point3Y); bubble.lineBetween(point1X, point1Y, point3X, point3Y); var content = scene.add.text(0, 0, quote, { fontFamily: 'Arial', fontSize: 20, color: '#000000', align: 'center', wordWrap: { width: bubbleWidth - (bubblePadding * 2) } }); var b = content.getBounds(); content.setPosition(bubble.x + (bubbleWidth / 2) - (b.width / 2), bubble.y + (bubbleHeight / 2) - (b.height / 2)); var container = scene.add.container(); container.add([ bubble, content ]); return container; } class SceneA extends Phaser.Scene { constructor () { super('sceneA'); } preload () { this.load.atlas('jellies', 'assets/atlas/jellies.png', 'assets/atlas/jellies.json'); } create () { let jelly = this.add.image(150, 500, 'jellies', 'WithShadow/Jelly1').setScale(0.5); let bubble1 = createSpeechBubble(this, 20, 30, 220, 80, \"Scene A\\nKey.on\").setVisible(false); let bubble2 = createSpeechBubble(this, 20, 160, 220, 80, \"Scene A\\nkeydown_SPACE\").setVisible(false); let bubble3 = createSpeechBubble(this, 20, 290, 220, 80, \"Scene A\\nkeydown\").setVisible(false); let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); // Phase 1: Key event. // Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object. // Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene. // Call stopPropagation to stop it reaching any other Scene. spaceKey.on('down', function (key, event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble1.setVisible(true); }); // Phase 2: Global keydown + keycode handler. // Emits only on the SPACE BAR keycode event, but dispatches globally. // Call stopImmediatePropagation to stop it reaching the global handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown_SPACE', function (event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble2.setVisible(true); }); // Phase 3: Global keydown handler. // Fires on ANY key press, so we need to check the keyCode internally. // Calling stopImmediatePropagation has no effect here, as it's the least specific handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown', function (event) { if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) { // event.stopPropagation(); bubble3.setVisible(true); } }); // Launch the other 2 Scenes, so they are running in parallel to SceneA. this.scene.launch('sceneB'); this.scene.launch('sceneC'); } } class SceneB extends Phaser.Scene { constructor () { super('sceneC'); } create () { let jelly = this.add.image(650, 500, 'jellies', 'WithShadow/Jelly3').setScale(0.5); let bubble1 = createSpeechBubble(this, 560, 30, 220, 80, \"Scene C\\nKey.on\").setVisible(false); let bubble2 = createSpeechBubble(this, 560, 160, 220, 80, \"Scene C\\nkeydown_SPACE\").setVisible(false); let bubble3 = createSpeechBubble(this, 560, 290, 220, 80, \"Scene C\\nkeydown\").setVisible(false); let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); // Phase 1: Key event. // Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object. // Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene. // Call stopPropagation to stop it reaching any other Scene. spaceKey.on('down', function (key, event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble1.setVisible(true); }); // Phase 2: Global keydown + keycode handler. // Emits only on the SPACE BAR keycode event, but dispatches globally. // Call stopImmediatePropagation to stop it reaching the global handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown_SPACE', function (event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble2.setVisible(true); }); // Phase 3: Global keydown handler. // Fires on ANY key press, so we need to check the keyCode internally. // Calling stopImmediatePropagation has no effect here, as it's the least specific handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown', function (event) { if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) { // event.stopPropagation(); bubble3.setVisible(true); } }); } } class SceneC extends Phaser.Scene { constructor () { super('sceneC'); } create () { let jelly = this.add.image(650, 500, 'jellies', 'WithShadow/Jelly3').setScale(0.5); let bubble1 = createSpeechBubble(this, 560, 30, 220, 80, \"Scene C\\nKey.on\").setVisible(false); let bubble2 = createSpeechBubble(this, 560, 160, 220, 80, \"Scene C\\nkeydown_SPACE\").setVisible(false); let bubble3 = createSpeechBubble(this, 560, 290, 220, 80, \"Scene C\\nkeydown\").setVisible(false); let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); // Phase 1: Key event. // Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object. // Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene. // Call stopPropagation to stop it reaching any other Scene. spaceKey.on('down', function (key, event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble1.setVisible(true); }); // Phase 2: Global keydown + keycode handler. // Emits only on the SPACE BAR keycode event, but dispatches globally. // Call stopImmediatePropagation to stop it reaching the global handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown_SPACE', function (event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble2.setVisible(true); }); // Phase 3: Global keydown handler. // Fires on ANY key press, so we need to check the keyCode internally. // Calling stopImmediatePropagation has no effect here, as it's the least specific handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown', function (event) { if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) { // event.stopPropagation(); bubble3.setVisible(true); } }); } } const config = { type: Phaser.AUTO, width: 800, height: 600, parent: 'phaser-example', backgroundColor: '#0072bc', scene: [ SceneA, SceneB, SceneC ] }; let game = new Phaser.Game(config); constructor () { super('sceneB'); } create () { let jelly = this.add.image(400, 500, 'jellies', 'WithShadow/Jelly2').setScale(0.5); let bubble1 = createSpeechBubble(this, 290, 30, 220, 80, \"Scene B\\nKey.on\").setVisible(false); let bubble2 = createSpeechBubble(this, 290, 160, 220, 80, \"Scene B\\nkeydown_SPACE\").setVisible(false); let bubble3 = createSpeechBubble(this, 290, 290, 220, 80, \"Scene B\\nkeydown\").setVisible(false); let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); // Phase 1: Key event. // Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object. // Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene. // Call stopPropagation to stop it reaching any other Scene. spaceKey.on('down', function (key, event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble1.setVisible(true); }); // Phase 2: Global keydown + keycode handler. // Emits only on the SPACE BAR keycode event, but dispatches globally. // Call stopImmediatePropagation to stop it reaching the global handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown_SPACE', function (event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble2.setVisible(true); }); // Phase 3: Global keydown handler. // Fires on ANY key press, so we need to check the keyCode internally. // Calling stopImmediatePropagation has no effect here, as it's the least specific handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown', function (event) { if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) { // event.stopPropagation(); bubble3.setVisible(true); } }); } } class SceneC extends Phaser.Scene { constructor () { super('sceneC'); } create () { let jelly = this.add.image(650, 500, 'jellies', 'WithShadow/Jelly3').setScale(0.5); let bubble1 = createSpeechBubble(this, 560, 30, 220, 80, \"Scene C\\nKey.on\").setVisible(false); let bubble2 = createSpeechBubble(this, 560, 160, 220, 80, \"Scene C\\nkeydown_SPACE\").setVisible(false); let bubble3 = createSpeechBubble(this, 560, 290, 220, 80, \"Scene C\\nkeydown\").setVisible(false); let spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE); // Phase 1: Key event. // Emits only when the SPACE BAR is pressed down, and dispatches from the local Key object. // Call stopImmediatePropagation to stop it reaching the two global handlers in this Scene. // Call stopPropagation to stop it reaching any other Scene. spaceKey.on('down', function (key, event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble1.setVisible(true); }); // Phase 2: Global keydown + keycode handler. // Emits only on the SPACE BAR keycode event, but dispatches globally. // Call stopImmediatePropagation to stop it reaching the global handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown_SPACE', function (event) { // event.stopPropagation(); // event.stopImmediatePropagation(); bubble2.setVisible(true); }); // Phase 3: Global keydown handler. // Fires on ANY key press, so we need to check the keyCode internally. // Calling stopImmediatePropagation has no effect here, as it's the least specific handler in this Scene. // Call stopPropagation to stop it reaching any other Scene. this.input.keyboard.on('keydown', function (event) { if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) { // event.stopPropagation(); bubble3.setVisible(true); } }); } } const config = { type: Phaser.AUTO, width: 800, height: 600, parent: 'phaser-example', backgroundColor: '#0072bc', scene: [ SceneA, SceneB, SceneC ] }; let game = new Phaser.Game(config);","title":"Speech bubble GRAPHIC across SCENES"},{"location":"2.%20research%20notes/phaser3/Starting-and-stopping-scenes/","text":"scenes can be loaden on top of each other Data can be sent and gotten from a scene Scenes can be paused, restarted, launched or transitioned to https://rexrainbow.github.io/phaser3-rex-notes/docs/site/scenemanager/","title":"Starting and stopping scenes"},{"location":"2.%20research%20notes/phaser3/TextureManager/","text":"The problem with loading players avatars was that they are stored in cache after load. So we have to check whether the image is already in cache. We have to find a way to check the cache Images are stored in the TextureManager The list of all loaded assets in the TextureManager can be get with: this.textures.list This returns an object, will all the kays We can check against existing loaded images with: this.textures.exists(keyName)) You can get the raw image data like this: var tex = this.textures.get('key'); tex.getSourceImage(); You can pass getSourceImage a frame key, should the texture span multiple image files (like in a multi-texture set-up) If you\u2019ve assigned an image asset to a game object, you can find it in object.texture.source[0].image Assign a new image to an existing GameObject with: GameObject.setTexture(KeyName) https://blog.ourcade.co/posts/2020/phaser3-load-images-dynamically/","title":"TextureManager"},{"location":"2.%20research%20notes/phaser3/Using-classes-for-GameObjects-and-extending-Phaser-Classes/","text":"Phaser example extending arcade sprite: https://phaser.io/examples/v3/view/physics/arcade/extending-arcade-sprite Extending sprite with object as arguments: https://phasergames.com/extend-a-sprite-in-phaser-3/?mc_cid=3f4ee26e5d&mc_eid=a4d9ee0291 Creating a button with the extended container class: https://braelynnn.medium.com/extending-a-phaser-class-to-make-reusable-game-objects-93c11326787e","title":"Using classes for GameObjects and extending Phaser Classes"},{"location":"3.%20features/done/Download-flipbooks/","text":"download stopmotion put stopmotion in memory cut stopmotion in frames repeat the frames at least until 24 total, and finish the last remainder (24/x ) round up = pages per frame indicate sheet no / cell no with dots also make a sheet per 8 download all sheets flipbook calculations https://docs.google.com/spreadsheets/d/1VdhPDLWH2CBSFVM77cHzO1YU78DRSl_G1FIJza1O4qE/edit#gid=0 old version, new version below: async function downloadFlipbook() { // we put the user name and displayName in the file name // retrieve those details const userProfile = get(Profile); let filename = `${userProfile.username}`; // if a display_name exists we also add that to the filename if (userProfile.display_name) { filename += `_${userProfile.display_name}`; } filename += `_${file.key}_${displayName}.png`; await saveFlipbookHandler(filename); } export async function saveFlipbookHandler(filename) { const flipbookCanvasWidth = 2480; const flipbookCanvasHeight = 3508; const numRows = 4; const numCols = 2; let currentTemplateFrame = 0; const offsetX = 468; const offsetY = 123; const templateImageWidth = 730; // const totalCanvases = 1; const totalCanvases = Math.ceil((numRows * numCols) / framesArray.length); dlog('totalCanvases: ', totalCanvases); /* load all images before the loop to avoid waiting first we load the flipbooktemplate image then we load the frames into a new array */ const flipbookTemplate = new Image(); await new Promise((resolve) => { flipbookTemplate.onload = function () { resolve(); }; flipbookTemplate.src = './assets/printSheet/fb_00_leeg.png'; }); const imgPromises = framesArray.map((frame) => new Promise((resolve) => { const img = new Image(); img.onload = () => { resolve(img); }; img.src = frame; })); const images = await Promise.all(imgPromises); const mainContainer = document.querySelector('.drawing-app'); for (let i = 0; i < totalCanvases; i++) { const canvas = document.createElement('canvas'); canvas.className = 'flipbook-canvas'; // Set the class name canvas.id = (i + 1).toString(); // Set the id // Hide the canvas canvas.style.display = 'none'; if (mainContainer) { mainContainer.parentNode.insertBefore(canvas, mainContainer); } const ctx = canvas.getContext('2d'); canvas.width = flipbookCanvasWidth; // Set canvas width canvas.height = flipbookCanvasHeight; // Set canvas height // /* load the template image into the canvas */ ctx.drawImage( flipbookTemplate, 0, 0, ); for (let j = 0; j < numRows; j++) { for (let k = 0; k < numCols; k++) { const x = k * templateImageWidth + offsetX * (k + 1); const y = j * templateImageWidth + offsetY * (j + 1); ctx.drawImage( images[currentTemplateFrame], x, y, templateImageWidth, templateImageWidth, ); currentTemplateFrame++; if (currentTemplateFrame === framesArray.length) currentTemplateFrame = 0; } } // Create a button element for downloading the canvas const downloadButton = document.createElement('button'); downloadButton.textContent = `flipbook_${canvas.id}`; downloadButton.style.position = 'absolute'; const topDistance = `${canvas.id}00px`; downloadButton.style.top = topDistance; downloadButton.addEventListener('click', () => { downloadFlipbookCanvas(canvas, `_${canvas.id}_FB_${filename}`); // Remove the download button and canvas after download downloadButton.remove(); canvas.remove(); }); // Append the container to the mainContainer mainContainer.appendChild(downloadButton); // Trigger a click event on the download button downloadButton.click(); } } function downloadFlipbookCanvas(canvas, downloadFileName) { canvas.toBlob((blob) => { const link = document.createElement('a'); link.download = downloadFileName; link.href = URL.createObjectURL(blob); link.click(); }, 'image/png'); } New version: async function downloadFlipbook() { // we put the user name and displayName in the file name // retrieve those details const userProfile = get(Profile); let filename = `${userProfile.username}`; // if a display_name exists we also add that to the filename if (userProfile.display_name) { filename += `_${userProfile.display_name}`; } filename += `_${file.key}_${displayName}.png`; await saveFlipbookHandler(filename); } export async function saveFlipbookHandler(filename) { const flipbookCanvasWidth = 2480; const flipbookCanvasHeight = 3508; const numRows = 4; const numCols = 2; const minNumSheets = 3; // printing 3 sheets of stopmotion was the norm let currentTemplateFrame = 0; const offsetX = 468; const offsetY = 123; const templateImageWidth = 730; // how many repeats fit in 3 sheets, then round up const repeatsRoundedUp = Math.ceil((numRows * numCols * minNumSheets) / framesArray.length); // total of frames we will be using const framesTotal = repeatsRoundedUp * framesArray.length; let framesTotalSoFar = 0; const totalCanvases = Math.ceil(framesTotal / (numRows * numCols)); // const totalCanvases = Math.ceil((numRows * numCols) / framesArray.length); /* load all images before the loop to avoid waiting first we load the flipbooktemplate image then we load the frames into a new array */ const flipbookTemplate = new Image(); await new Promise((resolve) => { flipbookTemplate.onload = function () { resolve(); }; flipbookTemplate.src = './assets/printSheet/fb_00_leeg.png'; }); const imgPromises = framesArray.map((frame) => new Promise((resolve) => { const img = new Image(); img.onload = () => { resolve(img); }; img.src = frame; })); const images = await Promise.all(imgPromises); const mainContainer = document.querySelector('.drawing-app'); for (let i = 0; i < totalCanvases; i++) { const canvas = document.createElement('canvas'); canvas.className = 'flipbook-canvas'; // Set the class name canvas.id = (i + 1).toString(); // Set the id // Hide the canvas canvas.style.display = 'none'; if (mainContainer) { mainContainer.parentNode.insertBefore(canvas, mainContainer); } const ctx = canvas.getContext('2d'); canvas.width = flipbookCanvasWidth; // Set canvas width canvas.height = flipbookCanvasHeight; // Set canvas height /* load the template image into the canvas */ ctx.drawImage( flipbookTemplate, 0, 0, ); for (let j = 0; j < numRows; j++) { for (let k = 0; k < numCols; k++) { const x = k * templateImageWidth + offsetX * (k + 1); const y = j * templateImageWidth + offsetY * (j + 1); // if we reach the framesTotal, we stop adding frames to the sheet if (framesTotalSoFar >= framesTotal) break; ctx.drawImage( images[currentTemplateFrame], x, y, templateImageWidth, templateImageWidth, ); // if we reach the framesTotal, we stop adding frames to the sheet framesTotalSoFar++; // we cycle through the available frames of the stopmotion currentTemplateFrame++; if (currentTemplateFrame === framesArray.length) currentTemplateFrame = 0; } } // Create a button element for downloading the canvas const downloadButton = document.createElement('button'); downloadButton.textContent = `flipbook_${canvas.id}`; downloadButton.style.position = 'absolute'; const topDistance = `${canvas.id}00px`; downloadButton.style.top = topDistance; downloadButton.addEventListener('click', () => { downloadFlipbookCanvas(canvas, `_${canvas.id}_FB_${filename}`); // Remove the download button and canvas after download downloadButton.remove(); canvas.remove(); }); // Append the container to the mainContainer mainContainer.appendChild(downloadButton); // Trigger a click event on the download button downloadButton.click(); } } function downloadFlipbookCanvas(canvas, downloadFileName) { canvas.toBlob((blob) => { const link = document.createElement('a'); link.download = downloadFileName; link.href = URL.createObjectURL(blob); link.click(); }, 'image/png'); }","title":"Feature: download FLIPBOOKS"},{"location":"3.%20features/done/Illustrations-fire-world/","text":"hier zijn de illustraties voor de vuurwereld. voorlopig is het nog niet voorbereid op animatie ingedeeld in layers. https://drive.google.com/drive/folders/1uCgWzyLWe-trLsBn9nQiLLIK74ENrlIH?usp=sharing","title":"Illustrations Fire World"},{"location":"3.%20features/done/Illustrations-robot-world/","text":"hier zijn de illustraties voor de wereld Robot. In de map \"_ZonderAnimatie_robot wereld\" staan alle elementen die niet meer geanimeerd kunnen worden/hoeven te worden. In de andere mappen zijn de elementen die geanimeerd kunnen worden onderverdeeld in hun layers. Wereld ROBOT: https://drive.google.com/drive/folders/1ETYE80FGyhTbHacqqwOdqHHSYnuslp3N?usp=sharing","title":"Illustrations Robot World"},{"location":"3.%20features/done/Implement-robotworld-2022-12-20/","text":"3de8bc 169876 In RobotWorld: backPortal background Gradient place objects place lines","title":"Log: implement RobotWorld 2022.12.20"},{"location":"3.%20features/done/Implement-robotworld-2022-12-20/#3de8bc","text":"","title":"3de8bc"},{"location":"3.%20features/done/Implement-robotworld-2022-12-20/#169876","text":"In RobotWorld: backPortal background Gradient place objects place lines","title":"169876"},{"location":"3.%20features/done/Merging-2023-01-20/","text":"ChallengeFlowerField = removal of unnecessary code Artworld = Amsterdam -> GreenSquare Player = Amsterdam -> GreenSquare animalChallenge: dlog off house.svelte: Amsterdam -> GreenSquare update.svelte: import { SCENE_INFO } from '../../constants'; let Azc = 'GreenSquare'; const Locaties = SCENE_INFO.map((i) => i.scene); do last check with async function update() { // get metadata if ($Profile.meta.Role.toLowerCase() === 'admin') { meta.Azc = Azc; meta.Role = role; } dlog('meta', meta); // check if the update happens correctly!!! // await setFullAccount(id, username, password, email, meta); } Check Moderate.svelte! for linting! and: import { runInNewContext } from 'vm'; Check Update.svelte for import { runInNewContext } from 'vm'; admin.svelte import { SCENE_INFO } from '../../constants'; const Locaties = SCENE_INFO.map((i) => i.scene); profile.svelte: $Profile.meta.Azc || 'GreenSquare', nakama.svelte: betworld TEST imagePicker: stock house and stock avatar BUG update Account (in console) PASSED admin page bug","title":"Merging 2023-01-20"},{"location":"3.%20features/done/Physics-debug-in-gameedit-mode/","text":"https://phaser.discourse.group/t/turn-on-off-debug-at-runtime/3681 Implemented in GameEdit Mode.","title":"Log: feature - physics debug in gameEdit mode"},{"location":"3.%20features/done/Place-visitor-next-to-house/","text":"current user -> profile: {id: 'f011a5dc-901a-42c0-9589-587b389d1e3e', username: 'user11', avatar_url: 'avatar/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-03T21_08_17_WitKaaiman.png', lang_tag: 'en', metadata: '{\"Azc\": \"GreenSquare\", \"PosX\": -1635, \"PosY\": 749,\u2026eAnimalGarden\", \"TotalPlayTime\": 398437367465947}', \u2026} avatar_url : \"avatar/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-03T21_08_17_WitKaaiman.png\" create_time : \"2022-05-11T12:18:13Z\" edge_count : 2 id : \"f011a5dc-901a-42c0-9589-587b389d1e3e\" lang_tag : \"en\" meta : Azc : \"GreenSquare\" Location : \"ChallengeAnimalGarden\" PosX : -1635 PosY : 749 Role : \"speler\" TotalPlayTime : 398437367465947 User_id : \"\" [[Prototype]]: Object metadata : \"{\\\"Azc\\\": \\\"GreenSquare\\\", \\\"PosX\\\": -1635, \\\"PosY\\\": 749, \\\"Role\\\": \\\"speler\\\", \\\"User_id\\\": \\\"\\\", \\\"Location\\\": \\\"ChallengeAnimalGarden\\\", \\\"TotalPlayTime\\\": 398437367465947}\" update_time : \"2023-01-09T14:39:58Z\" url : \"https://d1p8yo0yov6nht.cloudfront.net/fit-in/1800x150/filters:format(png)/avatar/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-03T21_08_17_WitKaaiman.png?signature=67efc42a243ded09f3acde439217b6d4abf81f6f71694dd4bfd4dd23b4e8a547\" username : \"user11\" 'Other' user: nakama object house with user id $SelectedOnlinePlayer => in svelte store in session.js $SelectedOnlinePlayer.meta.Azc = 'Greensquare' $SelectedOnlinePlayer.meta.PosX = 10 $SelectedOnlinePlayer.meta.PosY = -30 In selectedOnlinePlayerBar.svelte Cases where we click on a house and want to be taken next to house itemsBar currentPlayer, left, house icon itemsBar selectedOnlinePlayer, house icon Case 1: current player itemsbar.svelte <button on:click=\"{() => { goHome(); }}\" class=\"avatar\" > <img src=\"{$myHome.url}\" alt=\"My Home\" /> </button> async function goHome(id) { if (typeof id === 'string') { SceneSwitcher.switchScene('DefaultUserHome', id); } else if ($ShowItemsBar) { SceneSwitcher.switchScene( 'DefaultUserHome', ManageSession.userProfile.id, ); } } We can switch to the scene where the home is (Profile.meta.Azc), we can get the PosX and PosY of the home by querying the Home object, then pass push(`/?location=${SCENE}&x=0&y=0`); Home Object is being loaded in the beginning as userHouseObject userHouseObject = { \"collection\": \"home\", \"key\": \"GreenSquare\", \"permission_read\": 2, \"permission_write\": 1, \"value\": { \"url\": \"house/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-03T21_08_34_BlauwChirurgVis.png\", \"posX\": -1085.2499376200167, \"posY\": 84.58334073217338, \"version\": 2, \"username\": \"user11\" }, \"version\": \"c812e30ac619377abdf4522374739a7f\", \"user_id\": \"f011a5dc-901a-42c0-9589-587b389d1e3e\", \"create_time\": \"2022-08-07T09:20:32Z\", \"update_time\": \"2023-01-03T21:09:04Z\" } There is a bug in switching user from location to location that has to be fixed first https://artworlddev.maartenvanderglas.com/?p=180 This bug has been fixed. Switching Scenes is maybe a bit 'too reactive' still in some cases","title":"Log: feature - place visitor next to house"},{"location":"3.%20features/done/Save%20an%20ARTWORK%20as%20an%20other%20OBJECT/","text":"For example: save a drawing as a house a house as a drawing a stopmotion as an avatar a stopmotion as an animal an avatar as a stopmotion etc There should be a concept about what is a drawing and what is a stopmotion stopmotion object example userID: f011a5dc-901a-42c0-9589-587b389d1e3e key:1661448025760_zilverBear value: { \"url\":\"stopmotion/f011a5dc-901a-42c0-9589-587b389d1e3e/4_1661448025760_zilverBear.png\", \"version\":\"0\", \"previewUrl\":\"https://d1p8yo0yov6nht.cloudfront.net/fit-in/1800x150/filters:format(png)/stopmotion/f011a5dc-901a-42c0-9589-587b389d1e3e/4_1661448025760_zilverBear.png?signature=c43f701a0e54c74b5ff9fcc201b1f298ace3b40bc871ea68caa8e593f40b2e6f\", \"displayname\":\"holiMoly\" } drawing object example userID: f011a5dc-901a-42c0-9589-587b389d1e3e key:2023-02-15T11_50_40_GroenVleermuis value: {\"url\":\"drawing/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-02-15T11_50_40_GroenVleermuis.png\", \"version\":0, \"previewUrl\":\"https://d1p8yo0yov6nht.cloudfront.net/fit-in/1800x150/filters:format(png)/drawing/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-02-15T11_50_40_GroenVleermuis.png?signature=0099cb5599dff8836c2366ab5d00f2a1c2d0bf07e736582af47b01a728546c8a\", \"displayname\":\"GroenVleermuis\" } house object example (the image for a home) userID: f011a5dc-901a-42c0-9589-587b389d1e3e key:2023-02-17T10_31_38_toren value: { \"url\":\"house/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-02-17T10_31_38_toren.png\", \"version\":0, \"displayname\":\"toren\" } avatar object example userID: f011a5dc-901a-42c0-9589-587b389d1e3e key:2023-01-02T14_29_17_WitKaaiman value: { \"url\":\"avatar/f011a5dc-901a-42c0-9589-587b389d1e3e/0_2023-01-02T14_29_17_WitKaaiman.png\", \"version\":0, \"displayname\":\"WitKaaiman\" } drawing and stopmotion have a preview-url. When and where is that generated? clean way to transfer: get the image data (raw, largest) save it with a new key, with same display name do the url's get generated? In Apploader.svelte loading and making new files is handled A new function/ state should be defined: transferFile() currentFile contains all the information about the file CurrentApp should also contain animalGarden, flowerGarden etc if ( isValidLoaderApp($CurrentApp) && // Dont run on the game isValidQuery(parsedQuery) // AND when the query is valid (to open an existing file) ) { loadFile(); } else if (isValidLoaderApp($CurrentApp)) { newFile(); } }); async function loadFile() { currentFile.loaded = false; const userId = parsedQuery?.userId ?? null; const key = parsedQuery?.key ?? null; const loadFromCollection = $CurrentApp; currentFile = await getFileInformation(loadFromCollection, userId, key); dlog('currentFile loaded: ', currentFile); } async function newFile() { const saveToCollection = $CurrentApp; displayName = await getRandomName(); const tempKey = await getDateAndTimeFormatted(); currentFile = { userId: $Profile.id, loaded: false, new: true, displayName, key: `${tempKey}_${displayName}`, type: saveToCollection, status: PERMISSION_READ_PUBLIC, }; } in drawing.svelte the image data is loaded function createframeBuffer(img) { dlog('baseSize: ', baseSize); loadCanvas.width = baseSize; loadCanvas.height = baseSize; const ctx = loadCanvas.getContext('2d'); for (let index = 0; index < frames; index++) { ctx.drawImage( img, index * img.height, 0, img.height, img.height, 0, 0, baseSize, baseSize, ); framesArray[index] = loadCanvas.toDataURL('image/png'); // clear the loadingCanvas ctx.clearRect(0, 0, baseSize, baseSize); } We don't need to create a frameBuffer (we don't need to devide the stopmotion in frames for example). We just need to load the image in a loadCanvas and then save it with the right info. // Was there an image to load? Do so if (file?.url) { dlog('load file url drawing'); const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = (e) => { frames = Math.floor(e.target.width / e.target.height); createframeBuffer(img); // disabled looking for error }; img.src = file.url; setLoader(false); } else { // new image frames = 1; setLoader(false); } function createframeBuffer(img) { dlog('baseSize: ', baseSize); loadCanvas.width = baseSize; loadCanvas.height = baseSize; const ctx = loadCanvas.getContext('2d'); for (let index = 0; index < frames; index++) { ctx.drawImage( img, index * img.height, 0, img.height, img.height, 0, 0, baseSize, baseSize, ); } // clear the loadingCanvas ctx.clearRect(0, 0, baseSize, baseSize); // make the loadingCanvas 0 loadCanvas.width = 0;","title":"Feature: save an ARTWORK as an other OBJECT"},{"location":"3.%20features/done/User-can-change-name/","text":"user_name cannot be changed, but display_name can User can change display_name once, if there is a mistake admin or moderator can change it to \"\", then the user can set it's display_name again display_name shown in: itemsBar > profile.svelte in the game: the home discriptor in the selectedOnlinePlayerItemsBar in the friends list Update account https://heroiclabs.com/docs/nakama/concepts/user-accounts/ When a user is registered most of their profile is setup with default values. A user can update their own profile to change fields but cannot change any other user\u2019s profile. CLIENT 1 2 3 4 5 await client . updateAccount ( session , { display_name : \"My new name\" , avatar_url : \"http://graph.facebook.com/avatar_url\" , location : \"San Francisco\" }); Example code: export async function setAvatar(avatar_url) { const session = get(Session); await client.updateAccount(session, { avatar_url, }); const Image = await convertImage( avatar_url, DEFAULT_PREVIEW_HEIGHT, DEFAULT_PREVIEW_HEIGHT * STOPMOTION_MAX_FRAMES, 'png', ); // Profile.update((n) => { n.url = Image; return n }); getAccount(); Success.set(true); setLoader(false); return Image; } Try code: export async function setDisplayName(display_name) { const session = get(Session); await client.updateAccount(session, { display_name, }); getAccount(); Success.set(true); setLoader(false); } Location of the code: profile.svelte I implemented if account.display_name is empty string, then the user can set the display_name. If a user has set a display_name, the display_name cannot be changed. nakamaHelpers.js > getAllHouses includes user_displayname friends.svelte addFriend also with display_name -> not possible without rewriting the search function, so the search is removed for now getAccount(id) krijgt nu meta en metadata terug, is dat nieuw? Voorheen was het altijd meta.... friends.svelte friends are listed with display_name or username const columns = [ { key: 'status', title: '', value: (v) => { if (v.user.online) { return '<div class=\"online\"/>'; } return '<div class=\"offline\"/>'; }, }, { key: 'avatar', title: '', renderComponent: { component: ArtworkLoader, props: {}, }, }, { key: 'Username', title: 'Username', value: (v) => `<p class=\"link\">${v.user.display_name || v.user.username}<p>`, sortable: true, }, { key: 'action', title: '', renderComponent: { component: FriendAction, props: { load, }, }, }, ];","title":"Feature: user can change name"},{"location":"3.%20features/done/User-can-change-name/#update-account","text":"https://heroiclabs.com/docs/nakama/concepts/user-accounts/ When a user is registered most of their profile is setup with default values. A user can update their own profile to change fields but cannot change any other user\u2019s profile. CLIENT 1 2 3 4 5 await client . updateAccount ( session , { display_name : \"My new name\" , avatar_url : \"http://graph.facebook.com/avatar_url\" , location : \"San Francisco\" }); Example code: export async function setAvatar(avatar_url) { const session = get(Session); await client.updateAccount(session, { avatar_url, }); const Image = await convertImage( avatar_url, DEFAULT_PREVIEW_HEIGHT, DEFAULT_PREVIEW_HEIGHT * STOPMOTION_MAX_FRAMES, 'png', ); // Profile.update((n) => { n.url = Image; return n }); getAccount(); Success.set(true); setLoader(false); return Image; } Try code: export async function setDisplayName(display_name) { const session = get(Session); await client.updateAccount(session, { display_name, }); getAccount(); Success.set(true); setLoader(false); } Location of the code: profile.svelte I implemented if account.display_name is empty string, then the user can set the display_name. If a user has set a display_name, the display_name cannot be changed. nakamaHelpers.js > getAllHouses includes user_displayname friends.svelte addFriend also with display_name -> not possible without rewriting the search function, so the search is removed for now getAccount(id) krijgt nu meta en metadata terug, is dat nieuw? Voorheen was het altijd meta.... friends.svelte friends are listed with display_name or username const columns = [ { key: 'status', title: '', value: (v) => { if (v.user.online) { return '<div class=\"online\"/>'; } return '<div class=\"offline\"/>'; }, }, { key: 'avatar', title: '', renderComponent: { component: ArtworkLoader, props: {}, }, }, { key: 'Username', title: 'Username', value: (v) => `<p class=\"link\">${v.user.display_name || v.user.username}<p>`, sortable: true, }, { key: 'action', title: '', renderComponent: { component: FriendAction, props: { load, }, }, }, ];","title":"Update account"},{"location":"3.%20features/ideas/Bug-no-home-object/","text":"When there is no home object to load, then there is no home image to show. When going to edit the home image (the house) the plus button does not respond. But even if we would be able to draw a house (which should be possible), the admin still has to set the home position. So on this error an email has to be send to the admin account!","title":"Log: bug: no home Object"},{"location":"3.%20features/working%20on/Update-phaser-from-3-55-to-3-70-0/","text":"The update from 3.55 to 3.60 is actually the breaking update. broken Fabric UPGRADE PHASER with Fabric Fabric with eraser breaks Possible solution: https://github.com/fabricjs/fabric.js/issues/7171 https://www.npmjs.com/package/fabric-with-erasing RexPlugins Swiper Svelte Working: Vite + Phaser 3.70.0 Breaking point: ManageSession.js:48 Uncaught TypeError: Cannot read properties of undefined (reading 'Math') at new ManageSession (ManageSession.js:48:35) at ManageSession.js:399:16 ManageSession @ ManageSession.js:48 this.swipeAmount = new Phaser.Math.Vector2(0, 0); (anonymous) @ ManageSession.js:399 fix: import * as Phaser from 'phaser'; replaced const { Phaser } = window; in many files import * as Phaser from 'phaser'; Breaking point: RegisterPostPipeline.js:4 Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'renderer') at RegisterPostPipeline (RegisterPostPipeline.js:4:17) Turned off Outliner plugin Breaking: FlamengoWereld.js:85 Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'sizeX') at FlamengoWereld.create (FlamengoWereld.js:85:34) temp fix ( hack ): this.worldSize.x = 5500; this.worldSize.y = 5000;","title":"Log: update Phaser from 3.55 to 3.70.0"},{"location":"4.%20bugs/fixed/Bug-aanpassen-touch-targets-werelden-fixed/","text":"this.location. width & height => de width & height van het originele plaatje this.location.displayWidth => de width hoe het getoond wordt scaleX en scaleY zetten de displayHeight correct de hitTarget wordt ook automatisch goed gezet, behalve bij de icoBox, die wordt daarom gecorrigeerd. \\================================================================= const hitAreaWidth = this.location.width; const hitAreaheight = this.location.height; if (hitAreaWidth !== hitAreaheight) { // Coordinates are relative from the top-left, so we want out hit area to be // an extra 60 pixels around the texture, so -30 from the x/y and + 60 to the texture width and height // extend the isobox hitarea this.location.input.hitArea.setTo( -hitAreaWidth / 3, -hitAreaWidth / 1.3, hitAreaWidth * 1.4, hitAreaWidth * 1.5, ); } \\================================================================= this.location.body height en width is de target tussen andere physics bodies \\================================================================= TODO: naambordjes correct plaatsen [done] this.location.displayWidth: 300 this.location.width: 1141 width: 300 this.location.height: 629 this.location.displayWidth: 200 this.location.width: 720 width: 200 this.location.height: 720 this.location.displayWidth: 200.00000000000003 this.location.width: 699 width: 200 this.location.height: 860 this.location.displayWidth: 200 this.location.width: 482 width: 200 this.location.height: 755 this.location.displayWidth: 200 this.location.width: 200 width: 200 this.location.height: 142.85714285714286","title":"BugFix: Aanpassen \u2018touch targets\u2019 werelden [fixed]"},{"location":"4.%20bugs/fixed/Bug-cant-edit-avatar/","text":"When loading an old avatar, and drawing over it. The Avatar does not get saved. Open OLD AVATAR Draw over the OLD AVATAR Save (close) We don't see the EDITED AVATAR in the Profile Page, we don't see it in the game We do see the EDITED AVATAR when we edit again, we do see it on AWS, and the OLD AVATAR is overwritten. When Saving and Edit should be: save under a new name (2) In AWS I still see a 0_ in front of the name, why is this? Versioning is abolished... (1) So the EDIT gets saved on server, but not on local STORE? When making a new avatar: Avatar saveData Upload currentFile.key, currentFile.type, currentFile.status, currentFile.displayName,: 2022-12-23T10_09_00_CyaanFregata avatar true CyaanFregata appLoader.svelte:141 Avatar saveData Upload result: avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-23T10_09_00_CyaanFregata.png appLoader.svelte:143 A NEW AVATAR is overwriting the previous AVATAR!! Not showing in the list EASY fix: make a new AVATAR when you edit the AVATAR async function newFile() { const saveToCollection = $CurrentApp; const displayName = await getRandomName(); currentFile = { userId: $Profile.id, loaded: false, new: true, displayName, key: `${getDateMillis()}_${displayName}`, type: saveToCollection, status: true, }; currentFile: loaded: true new: false setting 'new' to true, so it load it as a new file Getting an error: nakama-js.esm.mjs:618 PUT http://193.187.129.81:7350/v2/account? 400 (Bad Request) setAvatarPromise error Response {type: 'cors', url: 'http://193.187.129.81:7350/v2/account?', redirected: false, status: 400, ok: false, \u2026} body : (...) bodyUsed : false headers : Headers {} ok : false redirected : false status : 400 statusText : \"Bad Request\" type : \"cors\" url : \"http://193.187.129.81:7350/v2/account?\" Het werkt, alleen je moet 2x klikken op de close button, hij maakt dan wel 2x een avatar The problem is that the upload URL is not generated the first time Let's look how a successful save happens Apploader.svelte saveData() uploadPromise()) blobData UploadImage(currentFile .key, type, blobData, status, 0 (version), displayName displayName : \"PaarsInktvis\" key : \"2022-12-30T13_10_38_PaarsInktvis\" loaded : false new : true status : true type : \"stopmotion\" uploadUrl : \"stopmotion/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_10_38_PaarsInktvis.png\" userId : \"fcbcc269-a109-4a4b-a570-5ccafc5308d8\" -> url jpegURL , stopmotion/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_10_38_PaarsInktvis.png jpegLocation https://artworld01.s3.eu-central-1.amazonaws.com/stopmotion/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_10_38_PaarsInktvis.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA3VY3XUKP6SYAM4OK%2F20221230%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20221230T131048Z&X-Amz-Expires=900&X-Amz-SignedHeaders=host&X-Amz-Signature=80511b2db9dab86b9717b26d225c9fc256c95e38c6702fc3c2ec4c422898af96 stopmotion/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_10_38_PaarsInktvis.png -->resolve(url) When saving an AVATAR (edited) we begin with: displayName : \"ZilverKikker\" frames : 1 key : \"2022-12-30T13_33_40_ZilverKikker\" loaded : true new : true status : true type : \"avatar\" uploadUrl : \"avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_33_40_ZilverKikker.png\" url : \"https://artworld01.s3.eu-central-1.amazonaws.com/avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T12_57_56_ZilverKikker.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA3VY3XUKP6SYAM4OK%2F20221230%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20221230T133314Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=a8d50b2362c6980bcd953542664dd315690f0ddbe3a25ef45452ab7191873ee3\" userId : \"fcbcc269-a109-4a4b-a570-5ccafc5308d8\" flagging an edited file as new displayName : \"ZilverKikker\" frames : 1 key : \"2022-12-30T13_33_40_ZilverKikker\" loaded : true new : true status : true type : \"avatar\" uploadUrl : \"avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T13_33_40_ZilverKikker.png\" url : \"https://artworld01.s3.eu-central-1.amazonaws.com/avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-30T12_57_56_ZilverKikker.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA3VY3XUKP6SYAM4OK%2F20221230%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20221230T133314Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=a8d50b2362c6980bcd953542664dd315690f0ddbe3a25ef45452ab7191873ee3\" userId : \"fcbcc269-a109-4a4b-a570-5ccafc5308d8\" (so no change yet!)","title":"Log: Bug - can't edit AVATAR"},{"location":"4.%20bugs/fixed/Bug-fix-players-are-lost-when-switching-location/","text":"Player are visible when first coming online (when the game is fresh). but when going to a new location players are lost. Reason: when switching locations they are not logged in to a stream switchScene(targetScene, targetHouse) { PlayerLocation.set({ house: targetHouse, scene: targetScene, }); } What is the reactiveness on PlayerLocation? The problem is fixed in sceneSwitcher the switchScene function was missing doSwitchScene() at the end in the sceneSwitcher, added a function to switch nakama streams, with call back and used that function in 3 places. This fixed the home button bug where going back home didn't leave and join a stream as it should The sceneSwitcher is so reactive that it is firing twice in some cases, seems that then calling the function directly is not needed: find out when this happens The multiple firing of switching scene only happens when using the home (goto artworld in the middle) button. I think this is fixed: check","title":"Log: bug Fix - players are lost when switching location"},{"location":"4.%20bugs/fixed/Bug-load-assets-per-scene-with-error-handling/","text":"I moved the this.load.on('loaderror') to each scene as it gave an error on scenes when it was in UIscene Possible solutions: 1. keep preloadscene running 2. this.load.on in UI scene 3. put a this.load.on('loaderror' in each scene ad 1. If PreloadScene is running with the error handler, and I load a file in CloudWorld that doesn't resolve, it doesn't throw an error. I don't really understand why there is correct error handling in UserHomes ad 2. does this catch all load errors? No it doesn't catch an error in CloudWorld for instance. ad 3. Now only on 'complete' there is a check if all images are downloaden We now have an 'onerror' checker in each scene. But we now can go back to prev scene when current scene is still loading... this gives errors. CHECK: https://rexrainbow.github.io/phaser3-rex-notes/docs/site/loader/ 'filecomplete-image-${filename}'.on -> the files is not fully loaded when this fires! progress and complete are acting strange, and are not useful.... My custom way of checking if all items of an array are loaded works best: before loading save the number of items. On 'complete' increment 'downloaded', when downloaded is the same size as the nrOfItems then it is finished Svelte is loading assets again and again. Maybe use this: https://github.com/bluwy/svelte-preprocess-import-assets off(event [, fn] [, context] [, once]) Remove the listeners of a given event. Parameters: Name Type Argument Description event string symbol fn function Only remove the listeners that match this function. context * Only remove the listeners that have this context. once boolean Only remove one-time listeners. In a world with houses, when the loading of the houses is interrupted. There is an error when the image is already loaded, but the house is 'in the making'. We get a On Error: Uncaught TypeError: Cannot read properties of null (reading 'image') But we cannot help this: the images as loaded, but the creation of the houses is interrupted. We can't put a check on that.","title":"BugFix: load assets per scene, with error handling"},{"location":"4.%20bugs/fixed/Bug-load-assets-per-scene-with-error-handling/#offevent-fn-context-once","text":"Remove the listeners of a given event.","title":"off(event [, fn] [, context] [, once])"},{"location":"4.%20bugs/fixed/Bug-load-assets-per-scene-with-error-handling/#parameters","text":"Name Type Argument Description event string symbol fn function Only remove the listeners that match this function. context * Only remove the listeners that have this context. once boolean Only remove one-time listeners. In a world with houses, when the loading of the houses is interrupted. There is an error when the image is already loaded, but the house is 'in the making'. We get a On Error: Uncaught TypeError: Cannot read properties of null (reading 'image') But we cannot help this: the images as loaded, but the creation of the houses is interrupted. We can't put a check on that.","title":"Parameters:"},{"location":"4.%20bugs/fixed/Bug-tracking-100-cpu-usage/","text":"Solution: graphics shouldn't be bigger then 1024x1024. For a gradient background the solution is quite easy: make a 1024 square image and scale it up to the appropriate size. For the dotted background: create a tilemap with the dot as a tile. 100% CPU, also on older branch from july 2022 disabling: fixedStep: true, fps: 60, No change Changing the world size to 1000x1000 from 6000x6000 dramatically reduces CPU usage Investigate further: is it maybe the input feel within the big world. So make the world 6000x6000 again but disable input graphic disable handlePlayerMovement() in artworld.js but keep it big: again 100% CPU Test where the limit of the world size is 2000 x 2000 3000 x 3000 4000 x 4000 5000 x 5000 6000 x 6000 So setting a max of 2000 x 2000 for the world (effectively reducing it with factor 3) will increase performance dramatically. All assets have to be loaded 3x times smaller And the x and y also needs to be divided by 3. Further investigation: disabling the big background and the input graphic 6000 x 6000 No background with dots, and no input graphic 6000 x 6000 No background, with input graphic The input graphic seems ok, because it is not visible, so it is not rendered. When I turn off the dots but keep the white background: With the dots the CPU is very high. I didn't expect that, as the dots are small images that are repeated many times when the background is a big rectangle: Optimizing worlds and backgrounds: tilemaps create tilemaps on the fly https://labs.phaser.io/edit.html?src=src\\tilemap\\put%20tiles.js // Creating a blank tilemap with the specified dimensions map = this.make.tilemap({ tileWidth: 16, tileHeight: 16, width: 25, height: 20}); var tiles = map.addTilesetImage('tiles'); var layer = map.createBlankLayer('layer1', tiles); layer.setScale(2); // Add a simple scene with some random element layer.fill(58, 0, 13, 25, 1); // Surface of the water layer.fill(77, 0, 14, 25, 5); // Body of the water layer.randomize(0, 0, 25, 13, [ 44, 45, 46, 47, 48 ]); // Wall above the water switch (objectToPlace) { case 'flower': // You can place an individal tile by index (or by passing in a Tile object) map.putTileAt(15, pointerTileX, pointerTileY); break; case 'platform': // You can place a row of tile indexes at a location map.putTilesAt([ 104, 105, 106, 107 ], pointerTileX, pointerTileY); break; case 'tiki': // You can also place a 2D array of tiles at a location map.putTilesAt([ [ 49, 50 ], [ 51, 52 ] ], pointerTileX, pointerTileY); break; default: break; } To make a background with this method, would be: create an image you want to repeat create an empty tilemap with the dimensions of the image create a layer in the map layer.fill to fill the map with images tilemaps with arrays https://labs.phaser.io/edit.html?src=src\\tilemap\\create%20from%20array.js All TileMap examples https://labs.phaser.io/index.html?dir=tilemap/&q= All the graphic elements where also a big problem: all the Houses had hit targets, name plates etc with graphics. So I refactored them to use prerendered images: To change to an image: base size rect: 256pix enterArea (rectangle) - invisible debugRectXMargin (rect) - color1 0x7300ED debugRect(rect) - color2 - 0xE8E8E8 namePlate (roundRect) - grey/beige 0xE8E8E8 .fillRoundedRect( // 0 - (locationDescription.width + namePlateMargin) / 2, // width / 2 - textPlateOffset, // locationDescription.width + namePlateMargin, // text's width + 10 (to have space between border and text) // namePlateMargin * 2, // 10, // ).setDepth(31); baseSize Circle: 64 numberBubble (circle) - grey/beige 0xE8E8E8 entershadow (circle) - purple 0x7300ED greyCircle_64 purpleCircle_64 greySquare_264 purpleSquare_264 On Android devices there is now still a crash: the big backgrounds still cause a problem. So try: make an 1024 x 1024 image and then scale that to the appropriate size. This works! This is the best solution for gradient backGrounds","title":"Log: bug tracking 100% CPU usage"},{"location":"4.%20bugs/fixed/Bug-tracking-100-cpu-usage/#test-where-the-limit-of-the-world-size-is","text":"2000 x 2000 3000 x 3000 4000 x 4000 5000 x 5000 6000 x 6000 So setting a max of 2000 x 2000 for the world (effectively reducing it with factor 3) will increase performance dramatically. All assets have to be loaded 3x times smaller And the x and y also needs to be divided by 3.","title":"Test where the limit of the world size is"},{"location":"4.%20bugs/fixed/Bug-tracking-100-cpu-usage/#further-investigation-disabling-the-big-background-and-the-input-graphic","text":"6000 x 6000 No background with dots, and no input graphic 6000 x 6000 No background, with input graphic The input graphic seems ok, because it is not visible, so it is not rendered. When I turn off the dots but keep the white background: With the dots the CPU is very high. I didn't expect that, as the dots are small images that are repeated many times when the background is a big rectangle: Optimizing worlds and backgrounds: tilemaps create tilemaps on the fly https://labs.phaser.io/edit.html?src=src\\tilemap\\put%20tiles.js // Creating a blank tilemap with the specified dimensions map = this.make.tilemap({ tileWidth: 16, tileHeight: 16, width: 25, height: 20}); var tiles = map.addTilesetImage('tiles'); var layer = map.createBlankLayer('layer1', tiles); layer.setScale(2); // Add a simple scene with some random element layer.fill(58, 0, 13, 25, 1); // Surface of the water layer.fill(77, 0, 14, 25, 5); // Body of the water layer.randomize(0, 0, 25, 13, [ 44, 45, 46, 47, 48 ]); // Wall above the water switch (objectToPlace) { case 'flower': // You can place an individal tile by index (or by passing in a Tile object) map.putTileAt(15, pointerTileX, pointerTileY); break; case 'platform': // You can place a row of tile indexes at a location map.putTilesAt([ 104, 105, 106, 107 ], pointerTileX, pointerTileY); break; case 'tiki': // You can also place a 2D array of tiles at a location map.putTilesAt([ [ 49, 50 ], [ 51, 52 ] ], pointerTileX, pointerTileY); break; default: break; } To make a background with this method, would be: create an image you want to repeat create an empty tilemap with the dimensions of the image create a layer in the map layer.fill to fill the map with images tilemaps with arrays https://labs.phaser.io/edit.html?src=src\\tilemap\\create%20from%20array.js All TileMap examples https://labs.phaser.io/index.html?dir=tilemap/&q= All the graphic elements where also a big problem: all the Houses had hit targets, name plates etc with graphics. So I refactored them to use prerendered images: To change to an image: base size rect: 256pix enterArea (rectangle) - invisible debugRectXMargin (rect) - color1 0x7300ED debugRect(rect) - color2 - 0xE8E8E8 namePlate (roundRect) - grey/beige 0xE8E8E8 .fillRoundedRect( // 0 - (locationDescription.width + namePlateMargin) / 2, // width / 2 - textPlateOffset, // locationDescription.width + namePlateMargin, // text's width + 10 (to have space between border and text) // namePlateMargin * 2, // 10, // ).setDepth(31); baseSize Circle: 64 numberBubble (circle) - grey/beige 0xE8E8E8 entershadow (circle) - purple 0x7300ED greyCircle_64 purpleCircle_64 greySquare_264 purpleSquare_264 On Android devices there is now still a crash: the big backgrounds still cause a problem. So try: make an 1024 x 1024 image and then scale that to the appropriate size. This works! This is the best solution for gradient backGrounds","title":"Further investigation: disabling the big background and the input graphic"},{"location":"4.%20bugs/fixed/Bugfix-drawing-over-the-edge/","text":"WE DONT HAVE ENOUGH TIME TO REFACTOR TO PAINTERRO so I am trying to implement a new solution: DrawingCanvas SaveCanvas This workes and is done, after this is it still good to refactor to Painterro, because performance is lacking on an iPad for instance. Working code so far: var canvas = new fabric.Canvas(document.getElementById('canvasId')) var canvas2 = new fabric.Canvas(document.getElementById('canvasId2')) var canvas3 = new fabric.Canvas(document.getElementById('canvasId3')) canvas.isDrawingMode = true; canvas.freeDrawingBrush.width = 5; canvas.freeDrawingBrush.color = '#00aeff'; canvas2.isDrawingMode = true; canvas2.freeDrawingBrush.width = 10; canvas2.freeDrawingBrush.color = '#ffaeff'; canvas.on('path:created', function(e) { e.path.set(); canvas.renderAll(); const preview = canvas.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview, (img) => { canvas3.add(img.set({ left: 0, top: 0, height: 400, width: 400 })) },{ crossOrigin: 'anonymous' }, ); }); canvas2.on('path:created', function(e) { e.path.set(); canvas2.renderAll(); const preview2 = canvas2.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview2, (img) => { canvas3.add(img.set({ left: 400, top: 0, height: 400, width: 400 })) },{ crossOrigin: 'anonymous' }, ); }); code with 2 canvas and filtering out the last drawing (other wise fabric adds an image each time when having drawn, in effect creating an undo /redo stack! var canvas = new fabric.Canvas(document.getElementById('canvasId')) var clearCanvas = document.getElementById('clear-canvas'); var canvas2 = new fabric.Canvas(document.getElementById('canvasId2')) var canvas3 = new fabric.Canvas(document.getElementById('canvasId3')) canvas.isDrawingMode = true; canvas.freeDrawingBrush.width = 5; canvas.freeDrawingBrush.color = '#00aeff'; canvas2.isDrawingMode = true; canvas2.freeDrawingBrush.width = 10; canvas2.freeDrawingBrush.color = '#ffaeff'; clearCanvas.onclick = function() { canvas.clear(); pushCanvasToPreview(canvas, 0); }; function pushCanvasToPreview(_canvas, frameNumber) { const previewCanvasObjects = canvas3.getObjects(); //remnove all objects with frame: frameNumber // that way there is only 1; the last one previewCanvasObjects.forEach((element) => { if (element.frame === frameNumber){ canvas3.remove(element); } }) const leftOffset = frameNumber * 400 const preview = _canvas.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview, (img) => { canvas3.add(img.set({ left: leftOffset, top: 0, height: 400, width: 400, frame: frameNumber})) },{ crossOrigin: 'anonymous' }, ); const canvasObjects = canvas3.getObjects(); console.log(canvasObjects) return preview; } canvas.on('path:created', function(e) { e.path.set(); canvas.renderAll(); pushCanvasToPreview(canvas, 0) }); canvas2.on('path:created', function(e) { e.path.set(); canvas2.renderAll(); pushCanvasToPreview(canvas2, 1); }); Select between drawing canvas: var canvas = new fabric.Canvas(document.getElementById('canvasId')) var clearCanvas = document.getElementById('clear-canvas'); var selectedCanvas = 1; var selectedCanvas1 = document.getElementById('selectCanvas1'); var selectedCanvas2 = document.getElementById('selectCanvas2'); // var canvas2 = new fabric.Canvas(document.getElementById('canvasId2')) var canvas3 = new fabric.Canvas(document.getElementById('previewCanvas')) canvas.isDrawingMode = true; canvas.freeDrawingBrush.width = 5; canvas.freeDrawingBrush.color = '#00aeff'; canvas.on('path:created', function(e) { e.path.set(); canvas.renderAll(); pushCanvasToPreview(canvas, selectedCanvas) }); clearCanvas.onclick = function() { canvas.clear(); pushCanvasToPreview(canvas, selectedCanvas); }; selectedCanvas1.onclick = function () { selectedCanvas = 0; canvas.clear(); }; selectedCanvas2.onclick = function () { selectedCanvas = 1; canvas.clear(); }; function pushCanvasToPreview(_canvas, frameNumber) { const previewCanvasObjects = canvas3.getObjects(); //remnove all objects with frame: frameNumber // that way there is only 1 image layer; the last one previewCanvasObjects.forEach((element) => { if (element.frame === frameNumber){ canvas3.remove(element); } }) const leftOffset = frameNumber * 400 const preview = _canvas.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview, (img) => { canvas3.add(img.set({ left: leftOffset, top: 0, height: 400, width: 400, frame: frameNumber})) },{ crossOrigin: 'anonymous' }, ); const canvasObjects = canvas3.getObjects(); console.log(canvasObjects) return preview; } Working code for drawing canvas, SaveCanvas, can switch between canvas and keep drawing. Undo is disabled (filtered out), but could be turned on again var canvas = new fabric.Canvas(document.getElementById('canvasId')) var clearCanvas = document.getElementById('clear-canvas'); var selectedCanvas = 0; var selectedCanvas1 = document.getElementById('selectCanvas1'); var selectedCanvas2 = document.getElementById('selectCanvas2'); // var canvas2 = new fabric.Canvas(document.getElementById('canvasId2')) var canvas3 = new fabric.Canvas(document.getElementById('previewCanvas')) canvas.isDrawingMode = true; canvas.freeDrawingBrush.width = 5; canvas.freeDrawingBrush.color = '#00aeff'; canvas.on('path:created', function(e) { e.path.set(); canvas.renderAll(); pushCanvasToPreview(canvas, selectedCanvas) }); clearCanvas.onclick = function() { canvas.clear(); pushCanvasToPreview(canvas, selectedCanvas); }; selectedCanvas1.onclick = function () { selectedCanvas = 0; canvas.clear(); // get the object for frame1 of the renderCanvas pushImageFromSaveCanvasToDrawingCanvas() }; selectedCanvas2.onclick = function () { selectedCanvas = 1; canvas.clear(); // get the object for frame1 of the renderCanvas pushImageFromSaveCanvasToDrawingCanvas() }; function pushImageFromSaveCanvasToDrawingCanvas(){ const previewCanvasObjects = canvas3.getObjects(); // remnove all objects with frame: frameNumber // that way there is only 1 image layer; the last one previewCanvasObjects.forEach((element) => { if (element.frame === selectedCanvas){ const cloned = canvas3.clone(element); canvas.add(element.set({ left: 0, top: 0, height: 400, width: 400})) } }) } function getCroppedImageFromCanvas(ToCanvas, frameNumber){ var cropped = new Image(); cropped.src = canvas3.toDataURL({ left: 400, top: 0, width: 400, height: 400 }); fabric.Image.fromURL(preview, (img) => { ToCanvas.add(img.set({ left: 0, top: 0, height: 400, width: 400})) },{ crossOrigin: 'anonymous' }); }; function pushCanvasToPreview(_canvas, frameNumber) { const previewCanvasObjects = canvas3.getObjects(); //remnove all objects with frame: frameNumber // that way there is only 1 image layer; the last one previewCanvasObjects.forEach((element) => { if (element.frame === frameNumber){ canvas3.remove(element); } }) const leftOffset = frameNumber * 400 const preview = _canvas.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview, (img) => { canvas3.add(img.set({ left: leftOffset, top: 0, height: 400, width: 400, frame: frameNumber})) },{ crossOrigin: 'anonymous' } ); //show how many objects there are in canvas3 const canvasObjects = canvas3.getObjects(); console.log(canvasObjects) return preview; } Next step: make SaveCanvas invisible use it to make previews Load in imagebefore on the saveCanvas, then push a crop back to the drawCanvas var canvas = new fabric.Canvas(document.getElementById('canvasId')) var clearCanvas = document.getElementById('clear-canvas'); // button var selectedCanvas = 0; var selectedCanvas1 = document.getElementById('selectCanvas1'); // button var selectedCanvas2 = document.getElementById('selectCanvas2'); // button var saveCanvas = new fabric.Canvas(document.getElementById('previewCanvas')) canvas.isDrawingMode = true; canvas.freeDrawingBrush.width = 5; canvas.freeDrawingBrush.color = '#00aeff'; canvas.on('path:created', function(e) { e.path.set(); canvas.renderAll(); pushCanvasToPreview(canvas, selectedCanvas) }); clearCanvas.onclick = function() { canvas.clear(); pushCanvasToPreview(canvas, selectedCanvas); }; selectedCanvas1.onclick = function () { selectedCanvas = 0; canvas.clear(); // get the object for frame1 of the renderCanvas // pushImageFromSaveCanvasToDrawingCanvas() getCroppedImageFromCanvas(canvas, selectedCanvas) }; selectedCanvas2.onclick = function () { selectedCanvas = 1; canvas.clear(); // get the object for frame1 of the renderCanvas // pushImageFromSaveCanvasToDrawingCanvas() getCroppedImageFromCanvas(canvas, selectedCanvas) }; function pushImageFromSaveCanvasToDrawingCanvas(){ const previewCanvasObjects = saveCanvas.getObjects(); // remnove all objects with frame: frameNumber // that way there is only 1 image layer; the last one previewCanvasObjects.forEach((element) => { if (element.frame === selectedCanvas){ const cloned = saveCanvas.clone(element); canvas.add(element.set({ left: 0, top: 0, height: 400, width: 400})) } }) } function getCroppedImageFromCanvas(ToCanvas, frameNumber){ const leftOffset = frameNumber * 400 // var cropped = new Image(); const cropped = saveCanvas.toDataURL({ left: leftOffset, top: 0, width: 400, height: 400 }); fabric.Image.fromURL(cropped, (img) => { ToCanvas.add(img.set({ left: 0, top: 0, height: 400, width: 400})) },{ crossOrigin: 'anonymous' }); }; function pushCanvasToPreview(_canvas, frameNumber) { const previewCanvasObjects = saveCanvas.getObjects(); //remnove all objects with frame: frameNumber // that way there is only 1 image layer; the last one previewCanvasObjects.forEach((element) => { if (element.frame === frameNumber){ saveCanvas.remove(element); } }) const leftOffset = frameNumber * 400 const preview = _canvas.toDataURL({ format: 'png', height: 400, width: 400, }); fabric.Image.fromURL(preview, (img) => { saveCanvas.add(img.set({ left: leftOffset, top: 0, height: 400, width: 400, frame: frameNumber})) },{ crossOrigin: 'anonymous' } ); //show how many objects there are in canvas3 const canvasObjects = saveCanvas.getObjects(); console.log(canvasObjects) return preview; } HTML: <canvas id=\"canvasId\" width=\"400\" height=\"400\"></canvas> <button id=\"clear-canvas\" class=\"btn btn-info\">Clear</button><br> <button id=\"selectCanvas1\" class=\"btn btn-info\">selectCanvas1</button><br> <button id=\"selectCanvas2\" class=\"btn btn-info\">selectCanvas2</button><br> <canvas hidden id=\"previewCanvas\" width=\"400\" height=\"400\" ></canvas> This version works with cropping the SaveCanvas back to the DrawingCanvas: this should work with loaded images and the like; Konva was pretty slow, so not a good replacement. So we switched to: SPAINTER a basic paixel based canvas drawing framework. https://github.com/akoidan/spainter Painterro is also an option: https://github.com/devforth/painterro I fixed the \"drawing over the border\" bug by by adding a clipPath to each frame, and then clipping each stroke to that clipPath (sort of a mask). That worked, but fell apart when erasing. The eraser also uses something like a clipPath, but it gets all wonky when erasing. The stack order doesn't make sense and the erase stroke is applied to other objects etc. And when I would turn off the clipPath before erasing, the eraser would be able to erase in the adjacent frames. I could try to implement eraser my self and see what is going on... I looked into creating a mask and using it both for the eraser and for the frame. But before trying that I tried another method: removing the points that are outside the frame after drawing. This works! But now also has to be implemented for the eraser. Because we are changing the paths after execution, we have to undo the erase and then do it again with the adjusted path. let lineWidth = 25; let drawingColor = '#000000'; let currentTab = null; make this pencil so we don't have to click twice in the beginning let applyBrush; where / for what is this used? let selectedBrush = 'Pencil'; Alternative ideas Wat als je een verse clippath maakt nadat de eraser bezig is geweest? Dus bij het selecteren van een brush Dus: er is een clipPath en alles, er wordt geerased. Er wordt weer getekend: de clipPath wordt weer vers aangemaakt en op alle lijnen weer toegepast? Werkt niet, want: erasen over de clipPath, in het eerste frame wordt er sowieso een groot deel van de linkerbovenhoek af geknipt Dus dan zou de clipPath eerst op null gezet moeten worden als er erased wordt... Andere methode: esare = bush en die deel uit laten maken van clipPath group: https://jsfiddle.net/almozdmr/yjmx6751/ Deze mask methode? https://jsfiddle.net/Fidel90/md6rwg4b/ This does not work: canvas.freeDrawingBrush.limitedToCanvasSize = true; Because the canvas is spread across frames. Alternatief voor de erase tool? //eraser canvas.on('path:created', function (opt) { opt.path.globalCompositeOperation = 'destination-out'; opt.path.lineWidth = strokeWidth; opt.path.stroke = 'rgba(0,0,0,0)'; //opt.path.fill = 'black'; canvas.requestRenderAll(); }); //draw canvas.on('path:created', function (opt) { opt.path.globalCompositeOperation = 'source-over'; opt.path.lineWidth = strokeWidth; opt.path.stroke = 'black'; //opt.path.fill = 'black'; canvas.requestRenderAll(); }); Trying to implement the eraser as a special brush: // Set frameNumber on object, to refer to when deleting frames canvas.on('path:created', (e) => { const idx = canvas.getObjects().length - 1; const index = currentFrame - 1; // is e and the last item the same? - no; e is the path of the item console.log(\"canvas.item(idx), e\", canvas.item(idx), e) const obj = e.path; canvas.item(idx).frameNumber = currentFrame; canvas.item(idx).eraser = 'false' if (currentTab === 'erase'){ canvas.item(idx).eraser = 'true' // // console.log(\"eraser: canvas.item(idx)\", canvas.item(idx)) // const top = canvas.item(idx).top; // const left = canvas.item(idx).left; // // de eraser vernietigen en weer maken met meer properties // canvas.remove(obj); // const newObj = new fabric.Path(obj.path, { // fill: '', // top: top, // left: left, // absolutePositioned: true, // stroke: 'white', // strokeWidth: lineWidth, // name: 'erase_clipPath', // hasControls: false, // hasBorders: false, // objectCaching: false, // // globalCompositionOperation: 'destination-out', // controlsAboveOverlay: true, // perPixelTargetFind: true, // }); // canvas.add(newObj); // const allCanvasObjects = canvas.getObjects() // console.log(\"allCanvasObjects\", allCanvasObjects) // allCanvasObjects.forEach((element) => { // if (element.frameNumber === currentFrame && element.eraser === 'false'){ // console.log(\"element\", element) // console.log(\"element.clipPath\", element.clipPath) // element.clipPath = null; // element.clipPath = newObj; // } // }) e.path.globalCompositionOperation = 'destination-out'; canvas.remove(canvas.item(idx)); const newObj = new fabric.Path(obj.path, { fill: '', // top: top, // left: left, // absolutePositioned: true, stroke: 'white', strokeWidth: lineWidth, name: 'erase_clipPath', hasControls: false, hasBorders: false, objectCaching: false, globalCompositionOperation: 'destination-out', controlsAboveOverlay: true, perPixelTargetFind: true, }); canvas.add(newObj); } else if (currentTab ==='draw'){ // clip the path with the canvasClipper so as to not draw into the next frame canvas.item(idx).clipPath = canvasClipperArray[index]; console.log(\"canvas.item(idx).clipPath\", canvas.item(idx).clipPath) } // start fix for drawing over the edge // const obj = e.path; // console.log(\"obj\", obj); // console.log(\"selectedBrush\", selectedBrush) // // different burshes have different line types // let points // if (selectedBrush === 'Pencil' || selectedBrush === 'Pattern'){ // points = [...obj.path]; // } else if (selectedBrush === 'Circle' || selectedBrush === 'Spray'){ // points = [...obj.lineCoords]; // } // for (let i = 0; i < points.length; i++) { // const element = points[i]; // if ( // element[1] < baseSize * (currentFrame - 1) || // element[2] < 0 || // element[1] > baseSize * currentFrame || // element[2] > baseSize // ) { // console.log('points[i]', points[i]); // points.splice(i, 1); // } // if ( // obj.left < baseSize * (currentFrame - 1) || // obj.top < 0 || // obj.left + obj.width > baseSize * currentFrame || // obj.top + obj.height > baseSize // ) { // // clip borders // console.log('outside of acceptable borders'); // for (let i = 0; i < points.length; i++) { // const element = points[i]; // if ( // element[1] < baseSize * (currentFrame - 1) || // element[2] < 0 || // element[1] > baseSize * currentFrame || // element[2] > baseSize // ) { // console.log('points[i]', points[i]); // points.splice(i, 1); // } // } // // update value if > or < then border, ajust value to border value ( -line width) // } // } // obj.set({ path: points }); // obj.setCoords(); // const modObj = obj; // // console.log('after', obj.path.length); // // console.log('obj', obj); // // console.log('obj.path', obj.path); // canvas.remove(obj); // const newObj = new fabric.Path(modObj.path, { // fill: '', // stroke: drawingColor, // strokeWidth: lineWidth, // name: 'line', // hasControls: false, // hasBorders: false, // objectCaching: false, // }); // canvas.add(newObj); }); - perPixelTargetFind: true ? An other framework that has an eraser implemented: KONVA https://konvajs.org/docs/index.html Free drawing with erase: https://konvajs.org/docs/sandbox/Free_Drawing.html undo /redo : https://codesandbox.io/s/0o9xmkno0 Transparent layers/ groups: https://konvajs.org/docs/sandbox/Transparent_Group.html Zooming the stage https://longviewcoder.com/2021/07/12/konva-zooming-the-stage-under-the-mouse/ https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html https://konvajs.org/docs/sandbox/Responsive_Canvas.html Flood Fill and Line Tool for HTML Canvas (also color picker) https://cantwell-tom.medium.com/flood-fill-and-line-tool-for-html-canvas-65e08e31aec6 https://ben.akrin.com/an-html5-canvas-flood-fill-that-doesnt-kill-the-browser/ http://www.williammalone.com/projects/html5-canvas-javascript-drawing-app-with-bucket-tool/ Color picker in svelte https://www.npmjs.com/package/svelte-awesome-color-picker https://svelte.dev/repl/8b00804d417b4fe89f42f90d6ed485e7?version=3.47.0 Chips oude implementatie van de stopmotion/ drawing app: git checkout 4d3f4a6be6e1659aa6175415e530fafb6fc9c5d4 <script> import { fabric } from \"./fabric\"; import { location, replace } from \"svelte-spa-router\"; import { onMount, beforeUpdate, onDestroy } from \"svelte\"; import { uploadImage, user, uploadAvatar, uploadHouse, getObject, setLoader, convertImage, updateObject, } from \"../../api.js\"; import { client } from \"../../nakama.svelte\"; import { Session, Profile, tutorial } from \"../../session.js\"; import { Achievements } from \"../../storage\"; import NameGenerator from \"../components/nameGenerator.svelte\"; import MouseIcon from \"svelte-icons/fa/FaMousePointer.svelte\"; import Avatar from \"../components/avatar.svelte\"; import ManageSession from \"../game/ManageSession\"; let scaleRatio, lastImg, lastValue, lastWidth; let params = { user: $location.split(\"/\")[2], name: $location.split(\"/\")[3] }; let invalidTitle = true; let history = [], historyCurrent; let canv, _clipboard, Cursor, cursor, drawingColorEl; let saveCanvas, savecanvas, videoCanvas; // saving = false; let videoWidth; let canvas, video, lineWidth = 25; let json, drawingColor = \"#000000\"; let shadowOffset = 0, shadowColor = \"#ffffff\", shadowWidth = 0; let title, answer, showBackground = true; let fillColor = \"#f00\", fillTolerance = 2; let current = \"draw\"; if (!!params.name) title = params.name; let saved = false, saveToggle = false, savedURL = \"\", colorToggle = true; // const statussen = [true, false]; export let appType = $location.split(\"/\")[1]; let version = 0; let optionbox = true; let status = true; let displayName; let isDrawn = false; let isPreexistingArt = false; let isAlreadyUploaded = false; let isTitleChanged = false; let applyBrush; // declaring the variable to be available globally, onMount assinging a function to it let selectedBrush = \"Pencil\"; // by default the Pencil is chosen let Object = {}; let FrameObject = { type: \"image\", version: \"4.6.0\", originX: \"left\", originY: \"top\", left: -1024, top: 0, width: 0, height: 1024, fill: \"rgb(0,0,0)\", stroke: null, strokeWidth: 0, strokeDashArray: null, strokeLineCap: \"butt\", strokeDashOffset: 0, strokeLineJoin: \"miter\", strokeUniform: false, strokeMiterLimit: 4, scaleX: 1, scaleY: 1, angle: 0, flipX: false, flipY: false, opacity: 1, shadow: null, visible: true, backgroundColor: \"\", fillRule: \"nonzero\", paintFirst: \"fill\", globalCompositeOperation: \"source-over\", skewX: 0, skewY: 0, erasable: true, cropX: 0, cropY: 0, src: \"\", crossOrigin: \"anonymous\", filters: [], }; var fab = function (id) { return document.getElementById(id); }; function adaptCanvasSize() { // the canvas size is set by the least of two (width / height) const canvasSize = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth; // setting default width and height canvas.setWidth(canvasSize); canvas.setHeight(canvasSize); cursor.setWidth(canvasSize); cursor.setHeight(canvasSize); const canvasReductionAmount = 200; // for medium screens if (canvasSize < 1008 && canvasSize > 640) { canvas.setWidth(canvasSize - canvasReductionAmount); canvas.setHeight(canvasSize - canvasReductionAmount); cursor.setWidth(canvasSize - canvasReductionAmount); cursor.setHeight(canvasSize - canvasReductionAmount); } // for mobile screens if (canvasSize <= 640) { canvas.setWidth(canvasSize - canvasReductionAmount * 0, 55); canvas.setHeight(canvasSize - canvasReductionAmount * 0, 55); cursor.setWidth(canvasSize - canvasReductionAmount * 0, 55); cursor.setHeight(canvasSize - canvasReductionAmount * 0, 55); } // for mobile screens if (canvasSize <= 540) { canvas.setWidth(canvasSize - canvasReductionAmount * 0, 4); canvas.setHeight(canvasSize - canvasReductionAmount * 0, 4); cursor.setWidth(canvasSize - canvasReductionAmount * 0, 4); cursor.setHeight(canvasSize - canvasReductionAmount * 0, 4); } // for correct and adapted scaling of the preexisting artworks scaleRatio = Math.min(canvas.width / 1024, canvas.width / 1024); cursor.setZoom(scaleRatio); canvas.setZoom(scaleRatio); } onMount(() => { setLoader(true); const autosave = setInterval(() => { if (!saved) { let data = {}; data.type = appType; data.name = title; if (appType == \"drawing\" || appType == \"house\") { data.drawing = canvas.toDataURL(\"image/png\", 1); } localStorage.setItem(\"Drawing\", JSON.stringify(data)); console.log(\"stored in localstorage\"); } }, 20000); cursor = new fabric.StaticCanvas(Cursor); canvas = new fabric.Canvas(canv, { isDrawingMode: true, }); // always adapting the canvas size on screen size change window.onresize = () => { adaptCanvasSize(); }; MouseIcon; savecanvas = new fabric.Canvas(saveCanvas, { isDrawingMode: true, }); getImage(); setLoader(false); fabric.Object.prototype.transparentCorners = false; var drawingModeEl = fab(\"drawing-mode\"), selectModeEl = fab(\"select-mode\"), //fillModeEl = fab(\"fill-mode\"), drawingOptionsEl = fab(\"drawing-mode-options\"), eraseModeEl = fab(\"erase-mode\"), drawingColorEl = fab(\"drawing-color\"), //drawingShadowColorEl = fab(\"drawing-shadow-color\"), drawingLineWidthEl = fab(\"drawing-line-width\"), //drawingShadowWidth = fab(\"drawing-shadow-width\"), //drawingShadowOffset = fab(\"drawing-shadow-offset\"); clearEl = fab(\"clear-canvas\"); clearEl.onclick = function () { // if anything is drawn on the canvas and it has not been uploaded, // save the artwork and clear the canvas if (isDrawn && !isAlreadyUploaded) { upload(); isDrawn = false; } canvas.clear(); localStorage.setItem(\"Drawing\", \"\"); }; drawingModeEl.onclick = function () { // console.log(\"mouse is down\"); switchOption(\"draw\"); canvas.isDrawingMode = true; console.log(drawingColor); floodFill(false); }; selectModeEl.onclick = function () { canvas.isDrawingMode = false; switchOption(\"select\"); floodFill(false); }; // fillModeEl.onclick = function () { // current = \"fill\"; // floodFill(true); // }; eraseModeEl.onclick = function () { // erase functie kapot? recompile: http://fabricjs.com/build/ var eraseBrush = new fabric.EraserBrush(canvas); canvas.freeDrawingBrush = eraseBrush; canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1; canvas.isDrawingMode = true; switchOption(\"erase\"); floodFill(false); }; if (fabric.PatternBrush) { var vLinePatternBrush = new fabric.PatternBrush(canvas); vLinePatternBrush.getPatternSrc = function () { var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = 10; var ctx = patternCanvas.getContext(\"2d\"); ctx.strokeStyle = this.color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(10, 5); ctx.closePath(); ctx.stroke(); return patternCanvas; }; var hLinePatternBrush = new fabric.PatternBrush(canvas); hLinePatternBrush.getPatternSrc = function () { var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = 10; var ctx = patternCanvas.getContext(\"2d\"); ctx.strokeStyle = this.color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(5, 10); ctx.closePath(); ctx.stroke(); return patternCanvas; }; var squarePatternBrush = new fabric.PatternBrush(canvas); squarePatternBrush.getPatternSrc = function () { var squareWidth = 10, squareDistance = 2; var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = squareWidth + squareDistance; var ctx = patternCanvas.getContext(\"2d\"); ctx.fillStyle = this.color; ctx.fillRect(0, 0, squareWidth, squareWidth); return patternCanvas; }; var diamondPatternBrush = new fabric.PatternBrush(canvas); diamondPatternBrush.getPatternSrc = function () { var squareWidth = 10, squareDistance = 5; var patternCanvas = fabric.document.createElement(\"canvas\"); var rect = new fabric.Rect({ width: squareWidth, height: squareWidth, angle: 45, fill: this.color, }); var canvasWidth = rect.getBoundingRect().width; patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance; rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 }); var ctx = patternCanvas.getContext(\"2d\"); rect.render(ctx); return patternCanvas; }; } // fab(\"drawing-mode-selector\").onchange = () => changebrush(); // function changebrush() { // brush = fab(\"drawing-mode-selector\"); // console.log(brush); // if (brush.value === \"hline\") { // canvas.freeDrawingBrush = vLinePatternBrush; // } else if (brush.value === \"vline\") { // canvas.freeDrawingBrush = hLinePatternBrush; // } else if (brush.value === \"square\") { // canvas.freeDrawingBrush = squarePatternBrush; // } else if (brush.value === \"diamond\") { // canvas.freeDrawingBrush = diamondPatternBrush; // } else if (brush.value === \"texture\") { // canvas.freeDrawingBrush = texturePatternBrush; // } else { // canvas.freeDrawingBrush = new fabric[brush.value + \"Brush\"](canvas); // } // if (canvas.freeDrawingBrush) { // var brush = canvas.freeDrawingBrush; // brush.color = drawingColorEl.value; // if (brush.getPatternSrc) { // brush.source = brush.getPatternSrc.call(brush); // } // brush.width = parseInt(drawingLineWidthEl.value, 10) || 1; // // brush.shadow = new fabric.Shadow({ // // blur: parseInt(drawingShadowWidth.value, 10) || 0, // // offsetX: 0, // // offsetY: 0, // // affectStroke: true, // // color: drawingShadowColorEl.value, // // }); // } // } drawingColorEl.onchange = function () { var brush = canvas.freeDrawingBrush; brush.color = this.value; if (brush.getPatternSrc) { brush.source = brush.getPatternSrc.call(brush); } }; // drawingShadowColorEl.onchange = function () { // canvas.freeDrawingBrush.shadow.color = this.value; // }; drawingLineWidthEl.onchange = function () { canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1; this.previousSibling.innerHTML = this.value; }; if (canvas.freeDrawingBrush) { canvas.freeDrawingBrush.color = drawingColorEl.value; // canvas.freeDrawingBrush.source = canvas.freeDrawingBrush.getPatternSrc.call(this); canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1; // canvas.freeDrawingBrush.shadow = new fabric.Shadow({ // blur: parseInt(drawingShadowWidth.value, 10) || 0, // offsetX: 0, // offsetY: 0, // affectStroke: true, // color: drawingShadowColorEl.value, // }); } console.log(params); canvas.on(\"mouse:up\", function () { // once there is anything is drawn on the canvas isDrawn = true; isPreexistingArt = false; isAlreadyUploaded = false; mouseEvent(); }); //////////////// mouse circle //////////////////////////// //mouse cursor layer var cursorOpacity = 0.5; //create cursor and place it off screen var mousecursor = new fabric.Circle({ left: -100, top: -100, radius: canvas.freeDrawingBrush.width / 2, fill: \"rgba(0,0,0,\" + cursorOpacity + \")\", stroke: \"black\", originX: \"center\", originY: \"center\", }); cursor.add(mousecursor); //redraw cursor on new mouse position when moved canvas.on(\"mouse:move\", function (evt) { if (current == \"select\") return mousecursor .set({ top: -100, left: -100 }) .setCoords() .canvas.renderAll(); var mouse = this.getPointer(evt.e); mousecursor .set({ top: mouse.y, left: mouse.x, }) .setCoords() .canvas.renderAll(); }); //while brush size is changed show cursor in center of canvas document.getElementById(\"drawing-line-width\").oninput = () => { changeBrushSize(); }; document.getElementById(\"erase-line-width\").oninput = () => { changeBrushSize(); }; function changeBrushSize() { var size = parseInt(lineWidth, 10); canvas.freeDrawingBrush.width = size; mousecursor // .center() .set({ radius: size / 2, top: 500, left: 1300, }) .setCoords() .canvas.renderAll(); } //change drawing color drawingColorEl.onchange = function () { console.log(\"color\"); canvas.freeDrawingBrush.color = this.value; var bigint = parseInt(this.value.replace(\"#\", \"\"), 16); var r = (bigint >> 16) & 255; var g = (bigint >> 8) & 255; var b = bigint & 255; // mousecursor.fill = \"rgba(\" + [r,g,b,cursorOpacity].join(\",\") + \")\" mousecursor .set({ fill: \"rgba(\" + [r, g, b, cursorOpacity].join(\",\") + \")\", }) .canvas.renderAll(); }; //////////////// mouse circle //////////////////////////// //////////////// drawing challenge //////////////////////// if (appType == \"drawingchallenge\") { // each mouse-up event sends the drawing canvas.on(\"mouse:up\", () => { // get the drawing from the canvas in the format of SVG const canvasData = canvas.toSVG(); // convert SVG into the HTML format in order to be able to manipulate inner data const parsedSVG = new DOMParser().parseFromString( canvasData, \"text/html\" ); // all <g> tags contain drawing action const gTagElement = parsedSVG.getElementsByTagName(\"g\"); // loop through <g> tags, remove all previous drawings and leave only the last one for (let i = gTagElement.length - 2; i >= 0; --i) { gTagElement[i].remove(); } // get the position of the drawing const positionObject = canvas.toJSON().objects; // needed SVG is stored inside of body which we want to send only const body = parsedSVG.getElementsByTagName(\"BODY\")[0].innerHTML; // all data to send const location = \"drawingchallenge\"; const JSONToSend = `{ \"action\": ${JSON.stringify( body )}, \"location\": \"${location}\", \"posX\": ${ positionObject[positionObject.length - 1].left }, \"posY\": ${positionObject[positionObject.length - 1].top}}`; // send data ManageSession.socket.rpc(\"move_position\", JSONToSend); }); // listening to the stream to get actions of other person's drawing ManageSession.socket.onstreamdata = (streamdata) => { let data = JSON.parse(streamdata.data); if ($Session.user_id != data.user_id) { // apply drawings to the canvas if only it is received from other participant fabric.loadSVGFromString(data.action, function (objects) { objects.forEach(function (svg) { console.log(\"svg\", svg); svg.set({ scaleX: 1, scaleY: 1, left: data.posX, top: data.posY, }); canvas.add(svg).renderAll(); }); }); } else { console.log(\"The same user!\"); } }; } //////////////// drawing challenge //////////////////////// adaptCanvasSize(); applyBrush = (brushType) => { if (typeof brushType == \"string\") selectedBrush = brushType; canvas.freeDrawingBrush = new fabric[selectedBrush + \"Brush\"](canvas); if (canvas.freeDrawingBrush) { var brush = canvas.freeDrawingBrush; brush.color = drawingColorEl.value; if (brush.getPatternSrc) { brush.source = brush.getPatternSrc.call(brush); } brush.width = parseInt(drawingLineWidthEl.value, 10) || 1; } }; }); /////////////////// end onMount /////////////////////// // to change visible/hidden status of the artwork const changeVisibility = async () => { setLoader(true); status = !status; if (isPreexistingArt) { // we update the name of the preexisting artwork await updateObject(Object.collection, Object.key, Object.value, status); } setLoader(false); }; const upload = async () => { if (!invalidTitle) return; // we upload the artwork if either something added to the art itself or when it is title changed if (isDrawn || isTitleChanged) { version = version + 1; // with every new update of the artwork, it is version gets +1 setLoader(true); if (appType == \"drawing\") { var Image = canvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); if (!!!title) { title = Date.now() + \"_\" + displayName; } // replace(`${$location}/${$Session.user_id}/${displayName}`); await uploadImage( title, appType, blobData, status, version, displayName ).then((url) => { // in every appType we assign url to the savedURL variable, it is needed for downloading // by default savedURL equals \"\" savedURL = url; setLoader(false); }); } if (appType == \"house\") { var Image = canvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); await uploadHouse(blobData).then((response) => { savedURL = response; }); setLoader(false); } if (appType == \"stopmotion\") { await createStopmotion(); setLoader(false); } if (appType == \"avatar\") { createAvatar().then((resp) => { setLoader(false); }); } isAlreadyUploaded = true; // once it is uploaded, we don't have to upload it again on the close button click isTitleChanged = false; } }; onDestroy(() => { // upload the artwork on the close button click, // if it is not uploaded yet or if the title has been changed if (!isAlreadyUploaded || isTitleChanged) { upload(); } }); async function download() { // check first if we are dealing with preexisting artwork // if it is the case, simply download from the url of the artwork on the addressbar if (isPreexistingArt) { if (!savedURL) { let url = lastImg; window.location = url; return; // don't proceed } } // start the process of downloading, only if something is drawn on the canvas if (isDrawn) { // if the user missed clicking the save button (upload function), then upload it first if (!isAlreadyUploaded) { await upload(); } if (appType == \"stopmotion\") { // the stopmotion function is not awaiting properly, a further investigation is needed (!) // once fixed, there is no need to use setTimeout setTimeout(async () => { const url = await convertImage(savedURL); window.location = url; }, 4500); } else { // for the rest of appTypes no need to set Timeout const url = await convertImage(savedURL); window.location = url; } } } const updateFrame = () => { frames[currentFrame] = canvas.toJSON(); console.log(\"currentFrame\", currentFrame) frames = frames; backgroundFrames[currentFrame] = canvas.toDataURL(\"image/png\", 1); backgroundFrames = backgroundFrames; }; const getImage = async () => { let localStore = JSON.parse(localStorage.getItem(\"Drawing\")); if (!!localStore) { console.log(localStore); console.log(\"store \" + localStore.name); console.log(\"param \" + params.name); if (localStore.name == params.name && typeof params.name != \"undefined\") { console.log(localStore.type); // isDrawn = true; // console.log(\"localstorage isDrawn\", isDrawn); if (localStore.type == \"drawing\") { console.log(\"test\"); // canvas.loadFromJSON( // localStore.drawing, // canvas.renderAll.bind(canvas) // ); fabric.Image.fromURL( localStore.drawing, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); canvas.add(oImg); }, { crossOrigin: \"anonymous\" } ); } // if (localStore.type == \"stopmotion\") { // frames = localStore.frames; // canvas.loadFromJSON( // localStore.frames[0], // canvas.renderAll.bind(canvas) // ); // } } } if (!!!params.name && (appType == \"stopmotion\" || appType == \"drawing\")) return setLoader(false); console.log(\"appType\", appType); // get images if (appType == \"avatar\") { lastImg = await convertImage($Profile.avatar_url, \"1024\", \"10000\"); isPreexistingArt = true; } else if (appType == \"house\") { let Object = await getObject(\"home\", $Profile.meta.Azc, $Profile.user_id); lastImg = await convertImage(Object.value.url, \"1024\", \"1024\"); lastValue = Object.value; title = Object.key; status = Object.permission_read == 2 ? true : false; isPreexistingArt = true; } else { Object = await getObject(appType, params.name, params.user); console.log(\"object\", Object); displayName = Object.value.displayname; title = Object.key; status = Object.permission_read == 2 ? true : false; console.log(\"status in getImage\", status); version = Object.value.version; console.log(\"displayName\", displayName); lastImg = await convertImage(Object.value.url); isPreexistingArt = true; } // put images on canvas if (appType == \"avatar\" || appType == \"stopmotion\") { console.log(\"avatar\"); let frameAmount; var framebuffer = new Image(); framebuffer.src = lastImg; framebuffer.onload = function () { console.log(\"img\", this.width); lastWidth = this.width; frameAmount = lastWidth / 1024; FrameObject.src = lastImg; FrameObject.width = lastWidth; frames = []; for (let i = 0; i < frameAmount; i++) { FrameObject.left = 0; FrameObject.width = 1024; FrameObject.cropX = i * 1024; // FrameObject.clipTo = function (ctx) { // // origin is the center of the image // // var x = rectangle.left - image.getWidth() / 2; // // var y = rectangle.top - image.getHeight() / 2; // // ctx.rect(i * -1024, 1024, (i * -1024)+1024, 1024); // ctx.rect(0,-1024,1024,1024) // }; // FrameObject.setCoords(); frames.push({ version: \"4.6.0\", objects: [{ ...FrameObject }], }); } frames = frames; console.log(\"frames\", frames); currentFrame = 0; canvas.loadFromJSON(frames[0], function () { canvas.renderAll.bind(canvas);}); }; } if (appType == \"drawing\" || appType == \"house\") { fabric.Image.fromURL( lastImg, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); canvas.add(oImg); }, { crossOrigin: \"anonymous\" } ); } if (!!!params.user) { console.log(window.location.pathname); replace(\"/\" + appType + \"/\" + $Session.user_id + \"/\" + displayName); } setLoader(false); }; function dataURItoBlob(dataURI) { var binary = atob(dataURI.split(\",\")[1]); var array = []; for (var i = 0; i < binary.length; i++) { array.push(binary.charCodeAt(i)); } return new Blob([new Uint8Array(array)], { type: \"image/png\" }); } async function getDataUrl(img) { // // Set width and height // savecanvas.width = img.width; // savecanvas.height = img.height; // // Draw the image // savecanvas.drawImage(img, 0, 0); // return savecanvas.toDataURL('image/jpeg'); // Create canvas let image; console.log(\"img\", img); await fabric.Image.fromURL(img, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); console.log(oImg); console.log(canvas); savecanvas.add(oImg); }); image = savecanvas.toDataURL(\"image/png\", 1); return image; } function mouseEvent() { setTimeout(() => { updateFrame(); saveHistory(); }, 200); } function zoomIt(factor) { // canvas.setHeight(canvas.getHeight() * factor); // canvas.setWidth(canvas.getWidth() * factor); if (canvas.backgroundImage) { // Need to scale background images as well var bi = canvas.backgroundImage; bi.width = bi.width * factor; bi.height = bi.height * factor; } var objects = canvas.getObjects(); for (var i in objects) { var scaleX = objects[i].scaleX; var scaleY = objects[i].scaleY; var left = objects[i].left; var top = objects[i].top; var tempScaleX = scaleX * factor; var tempScaleY = scaleY * factor; var tempLeft = left * factor; var tempTop = top * factor; objects[i].scaleX = tempScaleX; objects[i].scaleY = tempScaleY; objects[i].left = tempLeft; objects[i].top = tempTop; objects[i].setCoords(); } canvas.renderAll(); canvas.calcOffset(); } ////////////////////////// stop motion functie //////////////////////////////////////// let frames = [{}]; let backgroundFrames = [{}]; let maxFrames = 100; let currentFrame = 0; let play = false; // Create a new instance of the Image class var img = new Image(); // When the image loads, set it as background image if (showBackground) { img.onload = function () { var f_img = new fabric.Image(img); let options; let scale = 1024 / canvas.height; if (canvas.width <= canvas.height) { scale = 1024 / canvas.width; } if (!play) options = { opacity: 0.5, width: 1024, height: 1024, scaleX: scale, scaleY: scale, }; else options = {}; canvas.setBackgroundImage(f_img, canvas.renderAll.bind(canvas), options); canvas.renderAll(); }; } const changeFrame = (newFrame) => { console.log(\"newFrame\", newFrame); if (!play) { console.log(frames); // save frame // put as background of button canvas.clear(); // load frame canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas)); if (showBackground) img.src = backgroundFrames[newFrame - 1]; // change current frame currentFrame = newFrame; frames[newFrame].backgroundImage; } if (play || !showBackground) { canvas.clear(); frames[newFrame].backgroundImage = {}; canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas)); } }; const deleteFrame = (Frame) => { console.log(\"Frame\", Frame); for (var i = 0; i < frames.length; i++) { console.log(\"frames[i], Frame\", frames[i], Frame); if (i == Frame) { console.log(\"i\", i); if (i > 0) { frames.splice(i, 1); currentFrame = i - 1; frames[currentFrame].backgroundImage = {}; changeFrame(currentFrame); } else { frames.shift(); frames[0].backgroundImage = {}; currentFrame = 0; changeFrame(0); } } } }; async function addFrame() { await updateFrame(); if (frames.length >= maxFrames) return; console.log(\"click\"); frames.push({}); frames = frames; await changeFrame(frames.length - 1); let framebar = document.getElementById(\"frame-bar\"); framebar.scrollTo({ left: 0, top: framebar.scrollHeight }); } function playFrames() { if (currentFrame < frames.length - 1) currentFrame++; else currentFrame = 0; changeFrame(currentFrame); } let playint; function setPlay(bool) { if (bool) { playint = window.setInterval(playFrames, 500); } else { window.clearInterval(playint); } } ///////////////////// select functions ///////////////////////////////// function Copy() { // clone what are you copying since you // may want copy and paste on different moment. // and you do not want the changes happened // later to reflect on the copy. canvas.getActiveObject().clone(function (cloned) { _clipboard = cloned; }); } function Paste() { // clone again, so you can do multiple copies. _clipboard.clone(function (clonedObj) { canvas.discardActiveObject(); clonedObj.set({ left: clonedObj.left + 10, top: clonedObj.top + 10, evented: true, }); if (clonedObj.type === \"activeSelection\") { // active selection needs a reference to the canvas. clonedObj.canvas = canvas; clonedObj.forEachObject(function (obj) { canvas.add(obj); }); // this should solve the unselectability clonedObj.setCoords(); } else { canvas.add(clonedObj); } _clipboard.top += 10; _clipboard.left += 10; canvas.setActiveObject(clonedObj); canvas.requestRenderAll(); }); } function Delete() { // clone what are you copying since you // may want copy and paste on different moment. // and you do not want the changes happened // later to reflect on the copy. var curSelectedObjects = canvas.getActiveObjects(); canvas.discardActiveObject(); for (var i = 0; i < curSelectedObjects.length; i++) { canvas.remove(curSelectedObjects[i]); } } /////////////// select functions end ////////////////// ///////////////////// stop motion functies end ////////////////////////////// //////////////////// avatar functies ///////////////////////////////// if (appType == \"avatar\") { maxFrames = 5; } async function createAvatar() { let size = 1024; savecanvas.setHeight(size); savecanvas.setWidth(size * frames.length); savecanvas.renderAll(); savecanvas.clear(); let data = { objects: [] }; for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; const newFrames = frames[i].objects.map((object, index) => { //if (object.type == \"image\") return; const newObject = { ...object }; newObject.top = newObject.top; newObject.left += size * i; // newObject.scaleX = scaleRatio/1024; // newObject.scaleY = scaleRatio/1024; data.objects.push(newObject); }); } FrameObject.left = 0; // data.objects = [{ ...FrameObject }].concat(data.objects); console.log(\"data\", data); await savecanvas.loadFromJSON(data, savecanvas.renderAll.bind(savecanvas)); await savecanvas.calcOffset(); //var Image = savecanvas.toDataURL(\"image/png\", 0.2); // console.log(Image); // var blobData = dataURItoBlob(Image); setTimeout(async () => { var Image = savecanvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); json = JSON.stringify(frames); Image = await uploadAvatar(blobData, json, version); }, 5000); } async function createStopmotion() { console.log(\"111\"); // console.log(\"saved\"); json = JSON.stringify(frames); // console.log(\"json\", json); // var blobData = dataURItoBlob(frames); // uploadImage(title, appType, json, blobData, status); let size = 1024; savecanvas.setHeight(size); savecanvas.setWidth(size * frames.length); savecanvas.renderAll(); savecanvas.clear(); let data = { objects: [] }; for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; const newFrames = frames[i].objects.map((object, index) => { //if (object.type == \"image\") return; const newObject = { ...object }; newObject.top = newObject.top; newObject.left += size * i; // newObject.scaleX = scaleRatio/1024; // newObject.scaleY = scaleRatio/1024; data.objects.push(newObject); }); } FrameObject.left = 0; // data.objects = [{ ...FrameObject }].concat(data.objects); // console.log(\"data\", data); savecanvas.loadFromJSON(data, async () => { console.log(\"222\"); savecanvas.renderAll.bind(savecanvas); savecanvas.calcOffset(); var saveImage = await savecanvas.toDataURL(\"image/png\", 1); // console.log(\"savedImage\", saveImage); var blobData = dataURItoBlob(saveImage); // console.log(\"blobData\", blobData); if (!!!title) { title = Date.now() + \"_\" + displayName; } await uploadImage( title, appType, blobData, status, version, displayName ).then((url) => { console.log(\"333\"); savedURL = url; console.log(\"savedURL stopmotion\", savedURL); // saving = false; setLoader(false); }); //Profile.update(n => n.url = Image); }); } //////////////////// avatar functies end ///////////////////////////////// //////////////////// camera functies /////////////////////////////// function camera() { current = \"camera\"; if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) { navigator.mediaDevices .getUserMedia({ video: true }) .then(function (stream) { video.srcObject = stream; video.play(); }) .catch((err) => { console.log(err); alert(err); }); } } async function capturePicture() { let videocanv = new fabric.Canvas(videoCanvas, { isDrawingMode: false, }); videocanv.setHeight(videoWidth / 1.33); videocanv.setWidth(videoWidth); let vidContext = videocanv.getContext(\"2d\"); vidContext.drawImage(video, 0, 0, videoWidth, videoWidth / 1.33); var uri = videoCanvas.toDataURL(\"image/png\", 1); fabric.Image.fromURL(uri, function (oImg) { oImg.scale(1); oImg.set({ left: 0, top: 0 }); canvas.add(oImg); }); video.srcObject.getTracks()[0].stop(); current = \"select\"; } //////////////////// camera functies end /////////////////////////// //////////////////// redo/undo function /////////////////////////// const saveHistory = () => {}; const undo = () => { let lastObject = canvas.toJSON().objects[canvas.toJSON().objects.length - 1]; history.push(lastObject); let newFile = canvas.toJSON(); newFile.objects.pop(); canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas)); // once all previously drawn objects are deleted, isDrawn is set to false if (canvas.toJSON().objects.length == 0) { isDrawn = false; } }; const redo = () => { let newFile = canvas.toJSON(); newFile.objects.push(history[history.length - 1]); history.pop(); canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas)); // once the elements that has been removed are brought back, isDrawn is set back to true if (canvas.toJSON().objects.length > 0) { isDrawn = true; } }; //////////////////// redo/undo function end /////////////////////////// /////////////////// fill functie ////////////////////////////////////// var FloodFill = { // Compare subsection of array1's values to array2's values, with an optional tolerance withinTolerance: function (array1, offset, array2, tolerance) { var length = array2.length, start = offset + length; tolerance = tolerance || 0; // Iterate (in reverse) the items being compared in each array, checking their values are // within tolerance of each other while (start-- && length--) { if (Math.abs(array1[start] - array2[length]) > tolerance) { return false; } } return true; }, // The actual flood fill implementation fill: function ( imageData, getPointOffsetFn, point, color, target, tolerance, width, height ) { var directions = [ [1, 0], [0, 1], [0, -1], [-1, 0], ], coords = [], points = [point], seen = {}, key, x, y, offset, i, x2, y2, minX = -1, maxX = -1, minY = -1, maxY = -1; // Keep going while we have points to walk while (!!(point = points.pop())) { x = point.x; y = point.y; offset = getPointOffsetFn(x, y); // Move to next point if this pixel isn't within tolerance of the color being filled if (!FloodFill.withinTolerance(imageData, offset, target, tolerance)) { continue; } if (x > maxX) { maxX = x; } if (y > maxY) { maxY = y; } if (x < minX || minX == -1) { minX = x; } if (y < minY || minY == -1) { minY = y; } // Update the pixel to the fill color and add neighbours onto stack to traverse // the fill area i = directions.length; while (i--) { // Use the same loop for setting RGBA as for checking the neighbouring pixels if (i < 4) { imageData[offset + i] = color[i]; coords[offset + i] = color[i]; } // Get the new coordinate by adjusting x and y based on current step x2 = x + directions[i][0]; y2 = y + directions[i][1]; key = x2 + \",\" + y2; // If new coordinate is out of bounds, or we've already added it, then skip to // trying the next neighbour without adding this one if (x2 < 0 || y2 < 0 || x2 >= width || y2 >= height || seen[key]) { continue; } // Push neighbour onto points array to be processed, and tag as seen points.push({ x: x2, y: y2 }); seen[key] = true; } } return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, coords: coords, }; }, }; // End FloodFill function hexToRgb(hex, opacity) { opacity = Math.round(opacity * 255) || 255; hex = hex.replace(\"#\", \"\"); var rgb = [], re = new RegExp(\"(.{\" + hex.length / 3 + \"})\", \"g\"); hex.match(re).map(function (l) { rgb.push(parseInt(hex.length % 2 ? l + l : l, 16)); }); return rgb.concat(opacity); } function floodFill(enable) { if (!enable) { canvas.off(\"mouse:down\"); canvas.selection = true; canvas.forEachObject(function (object) { object.selectable = true; }); return; } canvas.discardActiveObject(); canvas.renderAll(); canvas.selection = false; canvas.forEachObject(function (object) { object.selectable = false; }); canvas.on({ \"mouse:down\": function (e) { var mouseX = Math.round(e.e.layerX), mouseY = Math.round(e.e.layerY), //canvas = canvas.lowerCanvasEl, context = canvas.getContext(\"2d\"), parsedColor = hexToRgb(fillColor), imageData = context.getImageData(0, 0, canvas.width, canvas.height), getPointOffset = function (x, y) { return 4 * (y * imageData.width + x); }, targetOffset = getPointOffset(mouseX, mouseY), target = imageData.data.slice(targetOffset, targetOffset + 4); if (FloodFill.withinTolerance(target, 0, parsedColor, fillTolerance)) { // Trying to fill something which is (essentially) the fill color return; } // Perform flood fill var data = FloodFill.fill( imageData.data, getPointOffset, { x: mouseX, y: mouseY }, parsedColor, target, fillTolerance, imageData.width, imageData.height ); if (0 == data.width || 0 == data.height) { return; } var tmpCanvas = document.createElement(\"canvas\"), tmpCtx = tmpCanvas.getContext(\"2d\"); tmpCanvas.width = canvas.width; tmpCanvas.height = canvas.height; var palette = tmpCtx.getImageData( 0, 0, tmpCanvas.width, tmpCanvas.height ); // x, y, w, h palette.data.set(new Uint8ClampedArray(data.coords)); // Assuming values 0..255, RGBA tmpCtx.putImageData(palette, 0, 0); // Repost the data. var imgData = tmpCtx.getImageData( data.x, data.y, data.width, data.height ); // Get cropped image tmpCanvas.width = data.width; tmpCanvas.height = data.height; tmpCtx.putImageData(imgData, 0, 0); // Convert canvas back to image: var img = new Image(); img.onload = function () { canvas.add( new fabric.Image(img, { left: data.x, top: data.y, selectable: false, }) ); }; img.src = tmpCanvas.toDataURL(\"image/png\", 1); canvas.add( new fabric.Image(tmpCanvas, { left: data.x, top: data.y, selectable: false, }) ); }, }); } ///////////////// fill functie end /////////////////////// function backgroundHide() { showBackground = !showBackground; if (!showBackground) { for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; } canvas.loadFromJSON(frames[currentFrame], canvas.renderAll.bind(canvas)); frames = frames; } else { img.src = backgroundFrames[currentFrame - 1]; } } function switchOption(option) { if (current === option) { optionbox = !optionbox; } else { optionbox = false; current = option; } } let transition = { y: 200, duration: 500 }; if (window.screen.width >= 600) { transition = { x: 200, duration: 500 }; } </script> <main on:mouseup={mouseEvent}> <div class=\"main-container\"> <div class=\"canvas-frame-container\"> {#if current == \"camera\"} <video bind:this={video} autoplay /> <button on:click={capturePicture} class=\"videoButton\" /> <div class=\"videocanvas\"> <canvas bind:this={videoCanvas} /> </div> {/if} <!-- <div class=\"topbar\"> <div> <a on:click={undo}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CCW.svg\"></a> <a on:click={redo}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CW.svg\"></a> </div> </div> --> <div class=\"canvas-box\" class:hidden={current === \"camera\"}> <canvas bind:this={canv} class=\"canvas\" /> <canvas bind:this={Cursor} id=\"cursor\" /> </div> <div class=\"savecanvas\"> <canvas bind:this={saveCanvas} /> </div> <div class=\"frame-box\"> {#if appType == \"stopmotion\" || appType == \"avatar\"} <div id=\"frame-bar\"> {#each frames as frame, index} <div> <div id={index} class:selected={currentFrame === index} on:click={() => { changeFrame(index); console.log(\"debug index of frame:\", index); //remove debug }} style=\"background-image: url({backgroundFrames[index]})\" > <div>{index + 1}</div> </div> {#if currentFrame === index && frames.length > 1} <img class=\"icon\" on:click={() => { deleteFrame(index); }} src=\"assets/SHB/svg/AW-icon-trash.svg\" /> {/if} </div> {/each} {#if frames.length < maxFrames} <div> <div id=\"frameNew\" on:click={addFrame}><div>+</div></div> </div> {/if} </div> <div class=\"frame-buttons\"> {#if play} <a id=\"playPause\" on:click={() => { play = false; setPlay(false); }} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pause.svg\" /></a > {:else} <a id=\"playPause\" on:click={() => { play = true; setPlay(true); }}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-play.svg\" /></a > {/if} <a on:click={backgroundHide} ><img class=\"icon\" class:unselected={!showBackground} src=\"assets/SHB/svg/AW-icon-onion.svg\" /></a > </div> {/if} </div> </div> </div> <div class=\"optionbox-container\"> <div class=\"optionbox\"> <div class=\"optionbar\" class:hidden={optionbox}> <div class=\"colorTab\" class:hidden={current != \"draw\"}> <div class=\"drawing-options-container\"> <img on:click={() => applyBrush(\"Pencil\")} class=\"icon\" class:selected={selectedBrush == \"Pencil\"} src=\"assets/svg/drawing_pencil2.svg\" /> <img on:click={() => applyBrush(\"Circle\")} class=\"icon\" class:selected={selectedBrush == \"Circle\"} src=\"assets/svg/drawing_circle2.svg\" /> <img on:click={() => applyBrush(\"Spray\")} class=\"icon\" class:selected={selectedBrush == \"Spray\"} src=\"assets/svg/drawing_spray.svg\" /> <img on:click={() => applyBrush(\"Pattern\")} class=\"icon\" class:selected={selectedBrush == \"Pattern\"} src=\"assets/svg/drawing_pattern.svg\" /> </div> <!-- <div id=\"drawing-mode-options\"> <select id=\"drawing-mode-selector\"> <option>Pencil</option> <option>Circle</option> <option>Spray</option> <option>Pattern</option> <option>hline</option> <option>vline</option> <option>square</option> <option>diamond</option> <option>texture</option> </select> </div> --> <!-- <div class=\"widthBox\" style=\"background-color: {drawingColor};\" on:click={() => { drawingColorEl.click(); }} > </div> --> <input type=\"color\" bind:value={drawingColor} bind:this={drawingColorEl} id=\"drawing-color\" /> <!-- <img class=\"colorIcon\" src=\"assets/SHB/svg/AW-icon-paint.svg\" /> --> <!-- <span class=\"info\">{lineWidth}</span> --> <div class=\"range-container\"> <div class=\"circle-box-small\" /> <input type=\"range\" min=\"10\" max=\"500\" id=\"drawing-line-width\" bind:value={lineWidth} /> <div class=\"circle-box-big\" /> </div> <!-- <label for=\"drawing-shadow-color\">Shadow color:</label> <input type=\"color\" bind:value={shadowColor} id=\"drawing-shadow-color\" /> <label for=\"drawing-shadow-width\">Shadow width:</label> <span class=\"info\">0</span><input type=\"range\" bind:value={shadowWidth} min=\"0\" max=\"50\" id=\"drawing-shadow-width\" /> <label for=\"drawing-shadow-offset\">Shadow offset:</label> <span class=\"info\">0</span><input type=\"range\" bind:value={shadowOffset} min=\"0\" max=\"50\" id=\"drawing-shadow-offset\" /> --> </div> <div class=\"eraseTab\" class:hidden={current != \"erase\"}> <!-- <div class=\"widthBox\"> <div class=\"lineWidth\" style=\"background-color: black;margin: 0px auto;\" /> </div> <span class=\"info\">{lineWidth}</span> --> <div class=\"range-container\"> <div class=\"circle-box-small\" /> <input type=\"range\" min=\"10\" max=\"500\" id=\"erase-line-width\" bind:value={lineWidth} /> <div class=\"circle-box-big\" /> </div> </div> <div class=\"fillTab\" class:hidden={current != \"fill\"}> <input type=\"color\" bind:value={fillColor} id=\"fill-color\" /> </div> <div class=\"selectTab\" class:hidden={current != \"select\"}> <a on:click={Copy} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-copy.svg\" /></a > <a on:click={Paste} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-paste.svg\" /></a > <a on:click={Delete} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-trash.svg\" /></a > </div> <div class=\"saveBox\" class:hidden={current != \"saveToggle\"}> <div class=\"saveTab\"> {#if appType != \"avatar\" && appType != \"house\"} <label for=\"title\">Title</label> <NameGenerator bind:value={displayName} bind:invalidTitle bind:isTitleChanged /> {/if} <!-- <label for=\"status\">Status</label> <select bind:value={status} on:change={() => (answer = \"\")}> {#each statussen as status} <option value={status}> {status} </option> {/each} </select> --> <div class=\"status-save-download-container\"> {#if appType != \"avatar\" && appType != \"house\"} <div on:click={changeVisibility}> {#if status} <img class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-visible.svg\" /> {:else} <img class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-invisible.svg\" /> {/if} </div> {/if} <div> <!-- {#if saving} --> <!-- <img on:click={upload} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-history.svg\" /> --> <!-- {:else if saved} --> <img on:click={upload} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-check.svg\" /> <!-- {/if} --> </div> <!-- <button on:click={upload} >{#if saving}Saving{:else if saved} Saved{:else}Save{/if}</button > --> <div> <!-- {#if saved} --> <img on:click={download} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-save.svg\" /> <!-- {/if} --> </div> </div> <!-- {#if saved} <button >Download</button> {/if} --> </div> </div> </div> <div class=\"iconbox\"> <a on:click={undo} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CCW.svg\" /></a > <a on:click={redo} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CW.svg\" /></a > <a on:click={applyBrush} id=\"drawing-mode\" class:currentSelected={current === \"draw\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pen.svg\" /></a > <a id=\"erase-mode\" class:currentSelected={current === \"erase\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-erase.svg\" /></a > <!-- <button class=\"icon\" id=\"fill-mode\" class:currentSelected={current === \"fill\"}><BucketIcon /></button > --> <a id=\"select-mode\" class:currentSelected={current === \"select\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pointer.svg\" /></a > <!-- {#if \"mediaDevices\" in navigator && \"getUserMedia\" in navigator.mediaDevices} <button class=\"icon\" id=\"camera-mode\" class:currentSelected={current == \"camera\"} on:click={camera}><CameraIcon /></button > {/if} --> <!-- <button id=\"clear-canvas\" class=\"btn btn-info icon\"> <TrashIcon /> </button> --> <!-- svelte-ignore a11y-missing-attribute --> <a class:currentSelected={current === \"saveToggle\"} on:click={() => { // console.log(\"saving is clicked\"); // console.log(\"length\", canvas.toJSON().objects); if ( appType == \"drawing\" || appType == \"stopmotion\" || appType == \"house\" || appType == \"avatar\" ) { saveToggle = !saveToggle; switchOption(\"saveToggle\"); } }}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-save.svg\" /></a > </div> </div> </div> <div id=\"clear-canvas\"><img src=\"assets/SHB/svg/AW-icon-reset.svg\" /></div> {#if appType == \"avatar\"} <div id=\"avatarBox\"> <Avatar /> </div> {/if} </main> <style> * { box-sizing: border-box; padding: 0; margin: 0; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .main-container { display: flex; align-items: center; margin-left: 60px; justify-content: flex-end; /* justify-content: space-around; */ margin: 20px 20px 0 0; } #cursor { pointer-events: none !important; width: 100vw; height: 100vw; margin: 0px; position: absolute; user-select: none; top: 0px; left: 0px; pointer-events: none; } .topbar { width: 100vw; margin: 0px auto; } .selected { box-shadow: 3px 3px #7300ed; } .colorTab { display: flex; flex-direction: column; align-items: center; } .saveTab { min-width: 160px; bottom: 50px; z-index: 1; } .savecanvas { display: none; } .saveTab > * { padding: 12px 16px; text-decoration: none; display: block; } .saveBox { position: relative; display: inline-block; } .saveBox:hover .saveTab { display: block; color: green; } .iconbox { width: 50px; position: relative; display: flex; justify-content: center; align-items: center; flex-direction: column; flex-wrap: wrap; transition: all 0.5s ease-in-out; } .optionbar { margin-left: 10px; border-right: 2px solid #7300ed; /* box-shadow: 10px 0px 5px 0px rgba(115,0,237,0.5); */ height: 100vh; background-color: white; transition: all 0.5s ease-in-out; width: fit-content; padding: 15px; transform: translateX(0%); width: 280px; display: flex; justify-content: center; align-items: center; flex-direction: column; flex-wrap: wrap; } .optionbar.hidden { width: 0px; transform: translateX(-160%); display: inline; padding: 0px; margin: 0px; } .optionbar.hidden > * { display: none; } .optionbar > * { /* margin: 5px auto; */ } .icon { min-width: 50px; height: 50px; border-radius: 50%; padding: 5px 0px 5px 0px; cursor: pointer; } #drawing-color, #drawing-shadow-color { padding: 0px; display: block; margin: 20px auto; } .optionbox { width: fit-content; display: flex; } .currentSelected { box-shadow: 0px 4px #7300ed; border-radius: 0% 50% 50% 0; height: 60px; display: block; width: 49px; padding: 0px; background-color: white; margin-left: -5px; } .hidden { display: none; } .videoButton { border-radius: 50%; padding: 25px; margin: 0 auto; background: red; display: block; } .lineWidth { border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .range-container { display: flex; flex-direction: row; flex-wrap: nowrap; align-items: center; } .circle-box-small { border: solid 2px black; border-radius: 50%; padding: 5px; } .circle-box-big { border: solid 2px black; border-radius: 50%; padding: 10px; } input[type=\"range\"] { -webkit-appearance: none; -moz-apperance: none; border-radius: 6px; border: 4px solid #7300ed; height: 4px; margin: 0 10px; } input[type=\"range\"]::-webkit-slider-thumb { -webkit-appearance: none !important; background-color: black; border: 1px solid black; border-radius: 50%; height: 15px; width: 15px; } /* .colorIcon { width: 32px; position: absolute; right: 5px; bottom: 5px; } */ .canvas-box { position: relative; background-color: white; border: 2px solid #7300ed; } .frame-box { display: flex; justify-content: center; align-items: center; position: relative; flex-direction: column; } #frame-bar { display: flex; flex-direction: column; max-height: 300px; width: 130px; overflow-y: auto; overscroll-behavior-y: contain; scroll-snap-type: y proximity; } #frame-bar > div { display: flex; justify-content: center; align-items: center; flex-direction: row; } #frame-bar > div > div { display: inline-block; width: 60px; height: 60px; margin: 5px; border: 2px solid #7300eb; font-size: 30px; text-align: center; background-position: center; background-repeat: no-repeat; background-size: contain; } #frame-bar > div > div:hover { cursor: pointer; } #frame-bar > div > div > div { height: 60px; display: flex; justify-content: center; align-items: center; } .frame-buttons { display: flex; flex-direction: column; } .frame-buttons > a > img { display: block; } #clear-canvas { position: fixed; left: 8px; top: 80px; z-index: 13; box-shadow: 5px 5px 0px #7300ed; cursor: pointer; padding: 0; margin: 0; border-radius: 50%; width: 40px; height: 40px; } #clear-canvas > img { width: 40px; } video { margin: 0 auto; display: block; } .canvas-frame-container { display: flex; flex-direction: row; } .topbar { width: unset; } .topbar { float: left; height: 100vh; } .topbar > div { display: inline-grid; position: relative; top: 50%; margin: 10px; -ms-transform: translateY(-50%); transform: translateY(-50%); } #frame-bar > div:last-child { overflow-anchor: auto; } .optionbox-container { margin: 0 10px 0 0; position: fixed; left: 0; top: 50vh; -ms-transform: translateY(-50%); transform: translateY(-50%); } .unselected { filter: grayscale(1) opacity(0.5); } #avatarBox { position: fixed; top: 130px; left: 20px; } .drawing-options-container { display: flex; flex-direction: row; flex-wrap: wrap; } .status-save-download-container { display: flex; flex-direction: column; /* justify-content: center; */ /* align-items: center; */ height: min-content; } /* medium size */ @media only screen and (max-width: 1007px) { .canvas-frame-container { flex-direction: column; } .frame-box { flex-direction: row; } #frame-bar { flex-direction: row; width: 250px; overflow-x: auto; overflow-y: none; overscroll-behavior-x: contain; scroll-snap-type: x proximity; } #frame-bar > div { flex-direction: column; } .frame-buttons { flex-direction: row; } } /* small */ @media only screen and (max-width: 640px) { .main-container { display: unset; align-items: unset; margin: 0; } .canvas-frame-container { justify-content: center; align-items: center; } .canvas-box { order: 2; } .frame-box { order: 1; flex-direction: row; /* width: 100%; */ justify-content: space-between; /* align-self: flex-end; */ } #frame-bar { max-width: 300px; height: 140px; margin-right: 10px; } #frame-bar > div { flex-direction: column-reverse; } .frame-buttons { flex-direction: column-reverse; margin: unset; align-self: center; } .optionbox { width: 100%; height: min-content; position: fixed; bottom: 0; display: block; } .optionbar { margin: 0; border-right: none; border-top: 2px solid #7300ed; box-shadow: 0px -5px 5px 0px #7300ed; height: min-content; width: 100%; padding: 0px; transition: none; animation: growup 0.3s ease-in-out forwards; transform-origin: bottom center; position: sticky; z-index: 40; align-items: flex-end; } .optionbar > * { margin: 20px 50px 20px 0; } .status-save-download-container { flex-direction: row; justify-content: space-between; } @keyframes growup { 0% { transform: scaleY(0); } 80% { transform: scaleY(1.1); } 100% { transform: scaleY(1); } } .optionbar.hidden { margin: 0; border-right: none; height: min-content; width: auto; transform: none; display: inline; animation: growdown 2s ease-in-out forwards; } @keyframes growdown { 0% { transform: scaleY(1); } 50% { transform: scaleY(0.5); } 100% { transform: scaleY(0); } } .optionbox-container { position: fixed; -ms-transform: initial; transform: initial; } .currentSelected { display: inline; } .iconbox { width: max-content; height: min-content; display: block; margin: 0 auto; } .currentSelected > img { border: 2px solid #7300ed; } .currentSelected { box-shadow: unset; } #clear-canvas { top: unset; bottom: 60px; } } </style> Het gaat vooral om deze componenten: let FrameObject = { type: \"image\", version: \"4.6.0\", originX: \"left\", originY: \"top\", left: -1024, top: 0, width: 0, height: 1024, fill: \"rgb(0,0,0)\", stroke: null, strokeWidth: 0, strokeDashArray: null, strokeLineCap: \"butt\", strokeDashOffset: 0, strokeLineJoin: \"miter\", strokeUniform: false, strokeMiterLimit: 4, scaleX: 1, scaleY: 1, angle: 0, flipX: false, flipY: false, opacity: 1, shadow: null, visible: true, backgroundColor: \"\", fillRule: \"nonzero\", paintFirst: \"fill\", globalCompositeOperation: \"source-over\", skewX: 0, skewY: 0, erasable: true, cropX: 0, cropY: 0, src: \"\", crossOrigin: \"anonymous\", filters: [], }; const updateFrame = () => { frames[currentFrame] = canvas.toJSON(); console.log(\"currentFrame\", currentFrame) frames = frames; backgroundFrames[currentFrame] = canvas.toDataURL(\"image/png\", 1); backgroundFrames = backgroundFrames; }; lastImg = await convertImage(Object.value.url); // dit moet ingeladen worden zonder convertImage, maar met de raw versie isPreexistingArt = true; let frameAmount; var framebuffer = new Image(); framebuffer.src = lastImg; framebuffer.onload = function () { console.log(\"img\", this.width); lastWidth = this.width; frameAmount = lastWidth / 2048; FrameObject.src = lastImg; FrameObject.width = lastWidth; frames = []; for (let i = 0; i < frameAmount; i++) { FrameObject.left = 0; FrameObject.width = 2048; FrameObject.cropX = i * 2048; frames.push({ version: \"4.6.0\", objects: [{ ...FrameObject }], });","title":"Log: BugFix: Drawing over the edge"},{"location":"4.%20bugs/fixed/Bugfix-drawing-over-the-edge/#alternative-ideas","text":"Wat als je een verse clippath maakt nadat de eraser bezig is geweest? Dus bij het selecteren van een brush Dus: er is een clipPath en alles, er wordt geerased. Er wordt weer getekend: de clipPath wordt weer vers aangemaakt en op alle lijnen weer toegepast? Werkt niet, want: erasen over de clipPath, in het eerste frame wordt er sowieso een groot deel van de linkerbovenhoek af geknipt Dus dan zou de clipPath eerst op null gezet moeten worden als er erased wordt... Andere methode: esare = bush en die deel uit laten maken van clipPath group: https://jsfiddle.net/almozdmr/yjmx6751/ Deze mask methode? https://jsfiddle.net/Fidel90/md6rwg4b/ This does not work: canvas.freeDrawingBrush.limitedToCanvasSize = true; Because the canvas is spread across frames. Alternatief voor de erase tool? //eraser canvas.on('path:created', function (opt) { opt.path.globalCompositeOperation = 'destination-out'; opt.path.lineWidth = strokeWidth; opt.path.stroke = 'rgba(0,0,0,0)'; //opt.path.fill = 'black'; canvas.requestRenderAll(); }); //draw canvas.on('path:created', function (opt) { opt.path.globalCompositeOperation = 'source-over'; opt.path.lineWidth = strokeWidth; opt.path.stroke = 'black'; //opt.path.fill = 'black'; canvas.requestRenderAll(); }); Trying to implement the eraser as a special brush: // Set frameNumber on object, to refer to when deleting frames canvas.on('path:created', (e) => { const idx = canvas.getObjects().length - 1; const index = currentFrame - 1; // is e and the last item the same? - no; e is the path of the item console.log(\"canvas.item(idx), e\", canvas.item(idx), e) const obj = e.path; canvas.item(idx).frameNumber = currentFrame; canvas.item(idx).eraser = 'false' if (currentTab === 'erase'){ canvas.item(idx).eraser = 'true' // // console.log(\"eraser: canvas.item(idx)\", canvas.item(idx)) // const top = canvas.item(idx).top; // const left = canvas.item(idx).left; // // de eraser vernietigen en weer maken met meer properties // canvas.remove(obj); // const newObj = new fabric.Path(obj.path, { // fill: '', // top: top, // left: left, // absolutePositioned: true, // stroke: 'white', // strokeWidth: lineWidth, // name: 'erase_clipPath', // hasControls: false, // hasBorders: false, // objectCaching: false, // // globalCompositionOperation: 'destination-out', // controlsAboveOverlay: true, // perPixelTargetFind: true, // }); // canvas.add(newObj); // const allCanvasObjects = canvas.getObjects() // console.log(\"allCanvasObjects\", allCanvasObjects) // allCanvasObjects.forEach((element) => { // if (element.frameNumber === currentFrame && element.eraser === 'false'){ // console.log(\"element\", element) // console.log(\"element.clipPath\", element.clipPath) // element.clipPath = null; // element.clipPath = newObj; // } // }) e.path.globalCompositionOperation = 'destination-out'; canvas.remove(canvas.item(idx)); const newObj = new fabric.Path(obj.path, { fill: '', // top: top, // left: left, // absolutePositioned: true, stroke: 'white', strokeWidth: lineWidth, name: 'erase_clipPath', hasControls: false, hasBorders: false, objectCaching: false, globalCompositionOperation: 'destination-out', controlsAboveOverlay: true, perPixelTargetFind: true, }); canvas.add(newObj); } else if (currentTab ==='draw'){ // clip the path with the canvasClipper so as to not draw into the next frame canvas.item(idx).clipPath = canvasClipperArray[index]; console.log(\"canvas.item(idx).clipPath\", canvas.item(idx).clipPath) } // start fix for drawing over the edge // const obj = e.path; // console.log(\"obj\", obj); // console.log(\"selectedBrush\", selectedBrush) // // different burshes have different line types // let points // if (selectedBrush === 'Pencil' || selectedBrush === 'Pattern'){ // points = [...obj.path]; // } else if (selectedBrush === 'Circle' || selectedBrush === 'Spray'){ // points = [...obj.lineCoords]; // } // for (let i = 0; i < points.length; i++) { // const element = points[i]; // if ( // element[1] < baseSize * (currentFrame - 1) || // element[2] < 0 || // element[1] > baseSize * currentFrame || // element[2] > baseSize // ) { // console.log('points[i]', points[i]); // points.splice(i, 1); // } // if ( // obj.left < baseSize * (currentFrame - 1) || // obj.top < 0 || // obj.left + obj.width > baseSize * currentFrame || // obj.top + obj.height > baseSize // ) { // // clip borders // console.log('outside of acceptable borders'); // for (let i = 0; i < points.length; i++) { // const element = points[i]; // if ( // element[1] < baseSize * (currentFrame - 1) || // element[2] < 0 || // element[1] > baseSize * currentFrame || // element[2] > baseSize // ) { // console.log('points[i]', points[i]); // points.splice(i, 1); // } // } // // update value if > or < then border, ajust value to border value ( -line width) // } // } // obj.set({ path: points }); // obj.setCoords(); // const modObj = obj; // // console.log('after', obj.path.length); // // console.log('obj', obj); // // console.log('obj.path', obj.path); // canvas.remove(obj); // const newObj = new fabric.Path(modObj.path, { // fill: '', // stroke: drawingColor, // strokeWidth: lineWidth, // name: 'line', // hasControls: false, // hasBorders: false, // objectCaching: false, // }); // canvas.add(newObj); }); - perPixelTargetFind: true ? An other framework that has an eraser implemented: KONVA https://konvajs.org/docs/index.html Free drawing with erase: https://konvajs.org/docs/sandbox/Free_Drawing.html undo /redo : https://codesandbox.io/s/0o9xmkno0 Transparent layers/ groups: https://konvajs.org/docs/sandbox/Transparent_Group.html Zooming the stage https://longviewcoder.com/2021/07/12/konva-zooming-the-stage-under-the-mouse/ https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html https://konvajs.org/docs/sandbox/Responsive_Canvas.html","title":"Alternative ideas"},{"location":"4.%20bugs/fixed/Bugfix-drawing-over-the-edge/#flood-fill-and-line-tool-for-html-canvas-also-color-picker","text":"https://cantwell-tom.medium.com/flood-fill-and-line-tool-for-html-canvas-65e08e31aec6 https://ben.akrin.com/an-html5-canvas-flood-fill-that-doesnt-kill-the-browser/ http://www.williammalone.com/projects/html5-canvas-javascript-drawing-app-with-bucket-tool/","title":"Flood Fill and Line Tool for HTML Canvas (also color picker)"},{"location":"4.%20bugs/fixed/Bugfix-drawing-over-the-edge/#color-picker-in-svelte","text":"https://www.npmjs.com/package/svelte-awesome-color-picker https://svelte.dev/repl/8b00804d417b4fe89f42f90d6ed485e7?version=3.47.0 Chips oude implementatie van de stopmotion/ drawing app: git checkout 4d3f4a6be6e1659aa6175415e530fafb6fc9c5d4 <script> import { fabric } from \"./fabric\"; import { location, replace } from \"svelte-spa-router\"; import { onMount, beforeUpdate, onDestroy } from \"svelte\"; import { uploadImage, user, uploadAvatar, uploadHouse, getObject, setLoader, convertImage, updateObject, } from \"../../api.js\"; import { client } from \"../../nakama.svelte\"; import { Session, Profile, tutorial } from \"../../session.js\"; import { Achievements } from \"../../storage\"; import NameGenerator from \"../components/nameGenerator.svelte\"; import MouseIcon from \"svelte-icons/fa/FaMousePointer.svelte\"; import Avatar from \"../components/avatar.svelte\"; import ManageSession from \"../game/ManageSession\"; let scaleRatio, lastImg, lastValue, lastWidth; let params = { user: $location.split(\"/\")[2], name: $location.split(\"/\")[3] }; let invalidTitle = true; let history = [], historyCurrent; let canv, _clipboard, Cursor, cursor, drawingColorEl; let saveCanvas, savecanvas, videoCanvas; // saving = false; let videoWidth; let canvas, video, lineWidth = 25; let json, drawingColor = \"#000000\"; let shadowOffset = 0, shadowColor = \"#ffffff\", shadowWidth = 0; let title, answer, showBackground = true; let fillColor = \"#f00\", fillTolerance = 2; let current = \"draw\"; if (!!params.name) title = params.name; let saved = false, saveToggle = false, savedURL = \"\", colorToggle = true; // const statussen = [true, false]; export let appType = $location.split(\"/\")[1]; let version = 0; let optionbox = true; let status = true; let displayName; let isDrawn = false; let isPreexistingArt = false; let isAlreadyUploaded = false; let isTitleChanged = false; let applyBrush; // declaring the variable to be available globally, onMount assinging a function to it let selectedBrush = \"Pencil\"; // by default the Pencil is chosen let Object = {}; let FrameObject = { type: \"image\", version: \"4.6.0\", originX: \"left\", originY: \"top\", left: -1024, top: 0, width: 0, height: 1024, fill: \"rgb(0,0,0)\", stroke: null, strokeWidth: 0, strokeDashArray: null, strokeLineCap: \"butt\", strokeDashOffset: 0, strokeLineJoin: \"miter\", strokeUniform: false, strokeMiterLimit: 4, scaleX: 1, scaleY: 1, angle: 0, flipX: false, flipY: false, opacity: 1, shadow: null, visible: true, backgroundColor: \"\", fillRule: \"nonzero\", paintFirst: \"fill\", globalCompositeOperation: \"source-over\", skewX: 0, skewY: 0, erasable: true, cropX: 0, cropY: 0, src: \"\", crossOrigin: \"anonymous\", filters: [], }; var fab = function (id) { return document.getElementById(id); }; function adaptCanvasSize() { // the canvas size is set by the least of two (width / height) const canvasSize = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth; // setting default width and height canvas.setWidth(canvasSize); canvas.setHeight(canvasSize); cursor.setWidth(canvasSize); cursor.setHeight(canvasSize); const canvasReductionAmount = 200; // for medium screens if (canvasSize < 1008 && canvasSize > 640) { canvas.setWidth(canvasSize - canvasReductionAmount); canvas.setHeight(canvasSize - canvasReductionAmount); cursor.setWidth(canvasSize - canvasReductionAmount); cursor.setHeight(canvasSize - canvasReductionAmount); } // for mobile screens if (canvasSize <= 640) { canvas.setWidth(canvasSize - canvasReductionAmount * 0, 55); canvas.setHeight(canvasSize - canvasReductionAmount * 0, 55); cursor.setWidth(canvasSize - canvasReductionAmount * 0, 55); cursor.setHeight(canvasSize - canvasReductionAmount * 0, 55); } // for mobile screens if (canvasSize <= 540) { canvas.setWidth(canvasSize - canvasReductionAmount * 0, 4); canvas.setHeight(canvasSize - canvasReductionAmount * 0, 4); cursor.setWidth(canvasSize - canvasReductionAmount * 0, 4); cursor.setHeight(canvasSize - canvasReductionAmount * 0, 4); } // for correct and adapted scaling of the preexisting artworks scaleRatio = Math.min(canvas.width / 1024, canvas.width / 1024); cursor.setZoom(scaleRatio); canvas.setZoom(scaleRatio); } onMount(() => { setLoader(true); const autosave = setInterval(() => { if (!saved) { let data = {}; data.type = appType; data.name = title; if (appType == \"drawing\" || appType == \"house\") { data.drawing = canvas.toDataURL(\"image/png\", 1); } localStorage.setItem(\"Drawing\", JSON.stringify(data)); console.log(\"stored in localstorage\"); } }, 20000); cursor = new fabric.StaticCanvas(Cursor); canvas = new fabric.Canvas(canv, { isDrawingMode: true, }); // always adapting the canvas size on screen size change window.onresize = () => { adaptCanvasSize(); }; MouseIcon; savecanvas = new fabric.Canvas(saveCanvas, { isDrawingMode: true, }); getImage(); setLoader(false); fabric.Object.prototype.transparentCorners = false; var drawingModeEl = fab(\"drawing-mode\"), selectModeEl = fab(\"select-mode\"), //fillModeEl = fab(\"fill-mode\"), drawingOptionsEl = fab(\"drawing-mode-options\"), eraseModeEl = fab(\"erase-mode\"), drawingColorEl = fab(\"drawing-color\"), //drawingShadowColorEl = fab(\"drawing-shadow-color\"), drawingLineWidthEl = fab(\"drawing-line-width\"), //drawingShadowWidth = fab(\"drawing-shadow-width\"), //drawingShadowOffset = fab(\"drawing-shadow-offset\"); clearEl = fab(\"clear-canvas\"); clearEl.onclick = function () { // if anything is drawn on the canvas and it has not been uploaded, // save the artwork and clear the canvas if (isDrawn && !isAlreadyUploaded) { upload(); isDrawn = false; } canvas.clear(); localStorage.setItem(\"Drawing\", \"\"); }; drawingModeEl.onclick = function () { // console.log(\"mouse is down\"); switchOption(\"draw\"); canvas.isDrawingMode = true; console.log(drawingColor); floodFill(false); }; selectModeEl.onclick = function () { canvas.isDrawingMode = false; switchOption(\"select\"); floodFill(false); }; // fillModeEl.onclick = function () { // current = \"fill\"; // floodFill(true); // }; eraseModeEl.onclick = function () { // erase functie kapot? recompile: http://fabricjs.com/build/ var eraseBrush = new fabric.EraserBrush(canvas); canvas.freeDrawingBrush = eraseBrush; canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1; canvas.isDrawingMode = true; switchOption(\"erase\"); floodFill(false); }; if (fabric.PatternBrush) { var vLinePatternBrush = new fabric.PatternBrush(canvas); vLinePatternBrush.getPatternSrc = function () { var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = 10; var ctx = patternCanvas.getContext(\"2d\"); ctx.strokeStyle = this.color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(0, 5); ctx.lineTo(10, 5); ctx.closePath(); ctx.stroke(); return patternCanvas; }; var hLinePatternBrush = new fabric.PatternBrush(canvas); hLinePatternBrush.getPatternSrc = function () { var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = 10; var ctx = patternCanvas.getContext(\"2d\"); ctx.strokeStyle = this.color; ctx.lineWidth = lineWidth; ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(5, 10); ctx.closePath(); ctx.stroke(); return patternCanvas; }; var squarePatternBrush = new fabric.PatternBrush(canvas); squarePatternBrush.getPatternSrc = function () { var squareWidth = 10, squareDistance = 2; var patternCanvas = fabric.document.createElement(\"canvas\"); patternCanvas.width = patternCanvas.height = squareWidth + squareDistance; var ctx = patternCanvas.getContext(\"2d\"); ctx.fillStyle = this.color; ctx.fillRect(0, 0, squareWidth, squareWidth); return patternCanvas; }; var diamondPatternBrush = new fabric.PatternBrush(canvas); diamondPatternBrush.getPatternSrc = function () { var squareWidth = 10, squareDistance = 5; var patternCanvas = fabric.document.createElement(\"canvas\"); var rect = new fabric.Rect({ width: squareWidth, height: squareWidth, angle: 45, fill: this.color, }); var canvasWidth = rect.getBoundingRect().width; patternCanvas.width = patternCanvas.height = canvasWidth + squareDistance; rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 }); var ctx = patternCanvas.getContext(\"2d\"); rect.render(ctx); return patternCanvas; }; } // fab(\"drawing-mode-selector\").onchange = () => changebrush(); // function changebrush() { // brush = fab(\"drawing-mode-selector\"); // console.log(brush); // if (brush.value === \"hline\") { // canvas.freeDrawingBrush = vLinePatternBrush; // } else if (brush.value === \"vline\") { // canvas.freeDrawingBrush = hLinePatternBrush; // } else if (brush.value === \"square\") { // canvas.freeDrawingBrush = squarePatternBrush; // } else if (brush.value === \"diamond\") { // canvas.freeDrawingBrush = diamondPatternBrush; // } else if (brush.value === \"texture\") { // canvas.freeDrawingBrush = texturePatternBrush; // } else { // canvas.freeDrawingBrush = new fabric[brush.value + \"Brush\"](canvas); // } // if (canvas.freeDrawingBrush) { // var brush = canvas.freeDrawingBrush; // brush.color = drawingColorEl.value; // if (brush.getPatternSrc) { // brush.source = brush.getPatternSrc.call(brush); // } // brush.width = parseInt(drawingLineWidthEl.value, 10) || 1; // // brush.shadow = new fabric.Shadow({ // // blur: parseInt(drawingShadowWidth.value, 10) || 0, // // offsetX: 0, // // offsetY: 0, // // affectStroke: true, // // color: drawingShadowColorEl.value, // // }); // } // } drawingColorEl.onchange = function () { var brush = canvas.freeDrawingBrush; brush.color = this.value; if (brush.getPatternSrc) { brush.source = brush.getPatternSrc.call(brush); } }; // drawingShadowColorEl.onchange = function () { // canvas.freeDrawingBrush.shadow.color = this.value; // }; drawingLineWidthEl.onchange = function () { canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1; this.previousSibling.innerHTML = this.value; }; if (canvas.freeDrawingBrush) { canvas.freeDrawingBrush.color = drawingColorEl.value; // canvas.freeDrawingBrush.source = canvas.freeDrawingBrush.getPatternSrc.call(this); canvas.freeDrawingBrush.width = parseInt(drawingLineWidthEl.value, 10) || 1; // canvas.freeDrawingBrush.shadow = new fabric.Shadow({ // blur: parseInt(drawingShadowWidth.value, 10) || 0, // offsetX: 0, // offsetY: 0, // affectStroke: true, // color: drawingShadowColorEl.value, // }); } console.log(params); canvas.on(\"mouse:up\", function () { // once there is anything is drawn on the canvas isDrawn = true; isPreexistingArt = false; isAlreadyUploaded = false; mouseEvent(); }); //////////////// mouse circle //////////////////////////// //mouse cursor layer var cursorOpacity = 0.5; //create cursor and place it off screen var mousecursor = new fabric.Circle({ left: -100, top: -100, radius: canvas.freeDrawingBrush.width / 2, fill: \"rgba(0,0,0,\" + cursorOpacity + \")\", stroke: \"black\", originX: \"center\", originY: \"center\", }); cursor.add(mousecursor); //redraw cursor on new mouse position when moved canvas.on(\"mouse:move\", function (evt) { if (current == \"select\") return mousecursor .set({ top: -100, left: -100 }) .setCoords() .canvas.renderAll(); var mouse = this.getPointer(evt.e); mousecursor .set({ top: mouse.y, left: mouse.x, }) .setCoords() .canvas.renderAll(); }); //while brush size is changed show cursor in center of canvas document.getElementById(\"drawing-line-width\").oninput = () => { changeBrushSize(); }; document.getElementById(\"erase-line-width\").oninput = () => { changeBrushSize(); }; function changeBrushSize() { var size = parseInt(lineWidth, 10); canvas.freeDrawingBrush.width = size; mousecursor // .center() .set({ radius: size / 2, top: 500, left: 1300, }) .setCoords() .canvas.renderAll(); } //change drawing color drawingColorEl.onchange = function () { console.log(\"color\"); canvas.freeDrawingBrush.color = this.value; var bigint = parseInt(this.value.replace(\"#\", \"\"), 16); var r = (bigint >> 16) & 255; var g = (bigint >> 8) & 255; var b = bigint & 255; // mousecursor.fill = \"rgba(\" + [r,g,b,cursorOpacity].join(\",\") + \")\" mousecursor .set({ fill: \"rgba(\" + [r, g, b, cursorOpacity].join(\",\") + \")\", }) .canvas.renderAll(); }; //////////////// mouse circle //////////////////////////// //////////////// drawing challenge //////////////////////// if (appType == \"drawingchallenge\") { // each mouse-up event sends the drawing canvas.on(\"mouse:up\", () => { // get the drawing from the canvas in the format of SVG const canvasData = canvas.toSVG(); // convert SVG into the HTML format in order to be able to manipulate inner data const parsedSVG = new DOMParser().parseFromString( canvasData, \"text/html\" ); // all <g> tags contain drawing action const gTagElement = parsedSVG.getElementsByTagName(\"g\"); // loop through <g> tags, remove all previous drawings and leave only the last one for (let i = gTagElement.length - 2; i >= 0; --i) { gTagElement[i].remove(); } // get the position of the drawing const positionObject = canvas.toJSON().objects; // needed SVG is stored inside of body which we want to send only const body = parsedSVG.getElementsByTagName(\"BODY\")[0].innerHTML; // all data to send const location = \"drawingchallenge\"; const JSONToSend = `{ \"action\": ${JSON.stringify( body )}, \"location\": \"${location}\", \"posX\": ${ positionObject[positionObject.length - 1].left }, \"posY\": ${positionObject[positionObject.length - 1].top}}`; // send data ManageSession.socket.rpc(\"move_position\", JSONToSend); }); // listening to the stream to get actions of other person's drawing ManageSession.socket.onstreamdata = (streamdata) => { let data = JSON.parse(streamdata.data); if ($Session.user_id != data.user_id) { // apply drawings to the canvas if only it is received from other participant fabric.loadSVGFromString(data.action, function (objects) { objects.forEach(function (svg) { console.log(\"svg\", svg); svg.set({ scaleX: 1, scaleY: 1, left: data.posX, top: data.posY, }); canvas.add(svg).renderAll(); }); }); } else { console.log(\"The same user!\"); } }; } //////////////// drawing challenge //////////////////////// adaptCanvasSize(); applyBrush = (brushType) => { if (typeof brushType == \"string\") selectedBrush = brushType; canvas.freeDrawingBrush = new fabric[selectedBrush + \"Brush\"](canvas); if (canvas.freeDrawingBrush) { var brush = canvas.freeDrawingBrush; brush.color = drawingColorEl.value; if (brush.getPatternSrc) { brush.source = brush.getPatternSrc.call(brush); } brush.width = parseInt(drawingLineWidthEl.value, 10) || 1; } }; }); /////////////////// end onMount /////////////////////// // to change visible/hidden status of the artwork const changeVisibility = async () => { setLoader(true); status = !status; if (isPreexistingArt) { // we update the name of the preexisting artwork await updateObject(Object.collection, Object.key, Object.value, status); } setLoader(false); }; const upload = async () => { if (!invalidTitle) return; // we upload the artwork if either something added to the art itself or when it is title changed if (isDrawn || isTitleChanged) { version = version + 1; // with every new update of the artwork, it is version gets +1 setLoader(true); if (appType == \"drawing\") { var Image = canvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); if (!!!title) { title = Date.now() + \"_\" + displayName; } // replace(`${$location}/${$Session.user_id}/${displayName}`); await uploadImage( title, appType, blobData, status, version, displayName ).then((url) => { // in every appType we assign url to the savedURL variable, it is needed for downloading // by default savedURL equals \"\" savedURL = url; setLoader(false); }); } if (appType == \"house\") { var Image = canvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); await uploadHouse(blobData).then((response) => { savedURL = response; }); setLoader(false); } if (appType == \"stopmotion\") { await createStopmotion(); setLoader(false); } if (appType == \"avatar\") { createAvatar().then((resp) => { setLoader(false); }); } isAlreadyUploaded = true; // once it is uploaded, we don't have to upload it again on the close button click isTitleChanged = false; } }; onDestroy(() => { // upload the artwork on the close button click, // if it is not uploaded yet or if the title has been changed if (!isAlreadyUploaded || isTitleChanged) { upload(); } }); async function download() { // check first if we are dealing with preexisting artwork // if it is the case, simply download from the url of the artwork on the addressbar if (isPreexistingArt) { if (!savedURL) { let url = lastImg; window.location = url; return; // don't proceed } } // start the process of downloading, only if something is drawn on the canvas if (isDrawn) { // if the user missed clicking the save button (upload function), then upload it first if (!isAlreadyUploaded) { await upload(); } if (appType == \"stopmotion\") { // the stopmotion function is not awaiting properly, a further investigation is needed (!) // once fixed, there is no need to use setTimeout setTimeout(async () => { const url = await convertImage(savedURL); window.location = url; }, 4500); } else { // for the rest of appTypes no need to set Timeout const url = await convertImage(savedURL); window.location = url; } } } const updateFrame = () => { frames[currentFrame] = canvas.toJSON(); console.log(\"currentFrame\", currentFrame) frames = frames; backgroundFrames[currentFrame] = canvas.toDataURL(\"image/png\", 1); backgroundFrames = backgroundFrames; }; const getImage = async () => { let localStore = JSON.parse(localStorage.getItem(\"Drawing\")); if (!!localStore) { console.log(localStore); console.log(\"store \" + localStore.name); console.log(\"param \" + params.name); if (localStore.name == params.name && typeof params.name != \"undefined\") { console.log(localStore.type); // isDrawn = true; // console.log(\"localstorage isDrawn\", isDrawn); if (localStore.type == \"drawing\") { console.log(\"test\"); // canvas.loadFromJSON( // localStore.drawing, // canvas.renderAll.bind(canvas) // ); fabric.Image.fromURL( localStore.drawing, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); canvas.add(oImg); }, { crossOrigin: \"anonymous\" } ); } // if (localStore.type == \"stopmotion\") { // frames = localStore.frames; // canvas.loadFromJSON( // localStore.frames[0], // canvas.renderAll.bind(canvas) // ); // } } } if (!!!params.name && (appType == \"stopmotion\" || appType == \"drawing\")) return setLoader(false); console.log(\"appType\", appType); // get images if (appType == \"avatar\") { lastImg = await convertImage($Profile.avatar_url, \"1024\", \"10000\"); isPreexistingArt = true; } else if (appType == \"house\") { let Object = await getObject(\"home\", $Profile.meta.Azc, $Profile.user_id); lastImg = await convertImage(Object.value.url, \"1024\", \"1024\"); lastValue = Object.value; title = Object.key; status = Object.permission_read == 2 ? true : false; isPreexistingArt = true; } else { Object = await getObject(appType, params.name, params.user); console.log(\"object\", Object); displayName = Object.value.displayname; title = Object.key; status = Object.permission_read == 2 ? true : false; console.log(\"status in getImage\", status); version = Object.value.version; console.log(\"displayName\", displayName); lastImg = await convertImage(Object.value.url); isPreexistingArt = true; } // put images on canvas if (appType == \"avatar\" || appType == \"stopmotion\") { console.log(\"avatar\"); let frameAmount; var framebuffer = new Image(); framebuffer.src = lastImg; framebuffer.onload = function () { console.log(\"img\", this.width); lastWidth = this.width; frameAmount = lastWidth / 1024; FrameObject.src = lastImg; FrameObject.width = lastWidth; frames = []; for (let i = 0; i < frameAmount; i++) { FrameObject.left = 0; FrameObject.width = 1024; FrameObject.cropX = i * 1024; // FrameObject.clipTo = function (ctx) { // // origin is the center of the image // // var x = rectangle.left - image.getWidth() / 2; // // var y = rectangle.top - image.getHeight() / 2; // // ctx.rect(i * -1024, 1024, (i * -1024)+1024, 1024); // ctx.rect(0,-1024,1024,1024) // }; // FrameObject.setCoords(); frames.push({ version: \"4.6.0\", objects: [{ ...FrameObject }], }); } frames = frames; console.log(\"frames\", frames); currentFrame = 0; canvas.loadFromJSON(frames[0], function () { canvas.renderAll.bind(canvas);}); }; } if (appType == \"drawing\" || appType == \"house\") { fabric.Image.fromURL( lastImg, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); canvas.add(oImg); }, { crossOrigin: \"anonymous\" } ); } if (!!!params.user) { console.log(window.location.pathname); replace(\"/\" + appType + \"/\" + $Session.user_id + \"/\" + displayName); } setLoader(false); }; function dataURItoBlob(dataURI) { var binary = atob(dataURI.split(\",\")[1]); var array = []; for (var i = 0; i < binary.length; i++) { array.push(binary.charCodeAt(i)); } return new Blob([new Uint8Array(array)], { type: \"image/png\" }); } async function getDataUrl(img) { // // Set width and height // savecanvas.width = img.width; // savecanvas.height = img.height; // // Draw the image // savecanvas.drawImage(img, 0, 0); // return savecanvas.toDataURL('image/jpeg'); // Create canvas let image; console.log(\"img\", img); await fabric.Image.fromURL(img, function (oImg) { oImg.set({ left: 0, top: 0 }); oImg.scaleToHeight(1024); oImg.scaleToWidth(1024); console.log(oImg); console.log(canvas); savecanvas.add(oImg); }); image = savecanvas.toDataURL(\"image/png\", 1); return image; } function mouseEvent() { setTimeout(() => { updateFrame(); saveHistory(); }, 200); } function zoomIt(factor) { // canvas.setHeight(canvas.getHeight() * factor); // canvas.setWidth(canvas.getWidth() * factor); if (canvas.backgroundImage) { // Need to scale background images as well var bi = canvas.backgroundImage; bi.width = bi.width * factor; bi.height = bi.height * factor; } var objects = canvas.getObjects(); for (var i in objects) { var scaleX = objects[i].scaleX; var scaleY = objects[i].scaleY; var left = objects[i].left; var top = objects[i].top; var tempScaleX = scaleX * factor; var tempScaleY = scaleY * factor; var tempLeft = left * factor; var tempTop = top * factor; objects[i].scaleX = tempScaleX; objects[i].scaleY = tempScaleY; objects[i].left = tempLeft; objects[i].top = tempTop; objects[i].setCoords(); } canvas.renderAll(); canvas.calcOffset(); } ////////////////////////// stop motion functie //////////////////////////////////////// let frames = [{}]; let backgroundFrames = [{}]; let maxFrames = 100; let currentFrame = 0; let play = false; // Create a new instance of the Image class var img = new Image(); // When the image loads, set it as background image if (showBackground) { img.onload = function () { var f_img = new fabric.Image(img); let options; let scale = 1024 / canvas.height; if (canvas.width <= canvas.height) { scale = 1024 / canvas.width; } if (!play) options = { opacity: 0.5, width: 1024, height: 1024, scaleX: scale, scaleY: scale, }; else options = {}; canvas.setBackgroundImage(f_img, canvas.renderAll.bind(canvas), options); canvas.renderAll(); }; } const changeFrame = (newFrame) => { console.log(\"newFrame\", newFrame); if (!play) { console.log(frames); // save frame // put as background of button canvas.clear(); // load frame canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas)); if (showBackground) img.src = backgroundFrames[newFrame - 1]; // change current frame currentFrame = newFrame; frames[newFrame].backgroundImage; } if (play || !showBackground) { canvas.clear(); frames[newFrame].backgroundImage = {}; canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas)); } }; const deleteFrame = (Frame) => { console.log(\"Frame\", Frame); for (var i = 0; i < frames.length; i++) { console.log(\"frames[i], Frame\", frames[i], Frame); if (i == Frame) { console.log(\"i\", i); if (i > 0) { frames.splice(i, 1); currentFrame = i - 1; frames[currentFrame].backgroundImage = {}; changeFrame(currentFrame); } else { frames.shift(); frames[0].backgroundImage = {}; currentFrame = 0; changeFrame(0); } } } }; async function addFrame() { await updateFrame(); if (frames.length >= maxFrames) return; console.log(\"click\"); frames.push({}); frames = frames; await changeFrame(frames.length - 1); let framebar = document.getElementById(\"frame-bar\"); framebar.scrollTo({ left: 0, top: framebar.scrollHeight }); } function playFrames() { if (currentFrame < frames.length - 1) currentFrame++; else currentFrame = 0; changeFrame(currentFrame); } let playint; function setPlay(bool) { if (bool) { playint = window.setInterval(playFrames, 500); } else { window.clearInterval(playint); } } ///////////////////// select functions ///////////////////////////////// function Copy() { // clone what are you copying since you // may want copy and paste on different moment. // and you do not want the changes happened // later to reflect on the copy. canvas.getActiveObject().clone(function (cloned) { _clipboard = cloned; }); } function Paste() { // clone again, so you can do multiple copies. _clipboard.clone(function (clonedObj) { canvas.discardActiveObject(); clonedObj.set({ left: clonedObj.left + 10, top: clonedObj.top + 10, evented: true, }); if (clonedObj.type === \"activeSelection\") { // active selection needs a reference to the canvas. clonedObj.canvas = canvas; clonedObj.forEachObject(function (obj) { canvas.add(obj); }); // this should solve the unselectability clonedObj.setCoords(); } else { canvas.add(clonedObj); } _clipboard.top += 10; _clipboard.left += 10; canvas.setActiveObject(clonedObj); canvas.requestRenderAll(); }); } function Delete() { // clone what are you copying since you // may want copy and paste on different moment. // and you do not want the changes happened // later to reflect on the copy. var curSelectedObjects = canvas.getActiveObjects(); canvas.discardActiveObject(); for (var i = 0; i < curSelectedObjects.length; i++) { canvas.remove(curSelectedObjects[i]); } } /////////////// select functions end ////////////////// ///////////////////// stop motion functies end ////////////////////////////// //////////////////// avatar functies ///////////////////////////////// if (appType == \"avatar\") { maxFrames = 5; } async function createAvatar() { let size = 1024; savecanvas.setHeight(size); savecanvas.setWidth(size * frames.length); savecanvas.renderAll(); savecanvas.clear(); let data = { objects: [] }; for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; const newFrames = frames[i].objects.map((object, index) => { //if (object.type == \"image\") return; const newObject = { ...object }; newObject.top = newObject.top; newObject.left += size * i; // newObject.scaleX = scaleRatio/1024; // newObject.scaleY = scaleRatio/1024; data.objects.push(newObject); }); } FrameObject.left = 0; // data.objects = [{ ...FrameObject }].concat(data.objects); console.log(\"data\", data); await savecanvas.loadFromJSON(data, savecanvas.renderAll.bind(savecanvas)); await savecanvas.calcOffset(); //var Image = savecanvas.toDataURL(\"image/png\", 0.2); // console.log(Image); // var blobData = dataURItoBlob(Image); setTimeout(async () => { var Image = savecanvas.toDataURL(\"image/png\", 1); var blobData = dataURItoBlob(Image); json = JSON.stringify(frames); Image = await uploadAvatar(blobData, json, version); }, 5000); } async function createStopmotion() { console.log(\"111\"); // console.log(\"saved\"); json = JSON.stringify(frames); // console.log(\"json\", json); // var blobData = dataURItoBlob(frames); // uploadImage(title, appType, json, blobData, status); let size = 1024; savecanvas.setHeight(size); savecanvas.setWidth(size * frames.length); savecanvas.renderAll(); savecanvas.clear(); let data = { objects: [] }; for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; const newFrames = frames[i].objects.map((object, index) => { //if (object.type == \"image\") return; const newObject = { ...object }; newObject.top = newObject.top; newObject.left += size * i; // newObject.scaleX = scaleRatio/1024; // newObject.scaleY = scaleRatio/1024; data.objects.push(newObject); }); } FrameObject.left = 0; // data.objects = [{ ...FrameObject }].concat(data.objects); // console.log(\"data\", data); savecanvas.loadFromJSON(data, async () => { console.log(\"222\"); savecanvas.renderAll.bind(savecanvas); savecanvas.calcOffset(); var saveImage = await savecanvas.toDataURL(\"image/png\", 1); // console.log(\"savedImage\", saveImage); var blobData = dataURItoBlob(saveImage); // console.log(\"blobData\", blobData); if (!!!title) { title = Date.now() + \"_\" + displayName; } await uploadImage( title, appType, blobData, status, version, displayName ).then((url) => { console.log(\"333\"); savedURL = url; console.log(\"savedURL stopmotion\", savedURL); // saving = false; setLoader(false); }); //Profile.update(n => n.url = Image); }); } //////////////////// avatar functies end ///////////////////////////////// //////////////////// camera functies /////////////////////////////// function camera() { current = \"camera\"; if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) { navigator.mediaDevices .getUserMedia({ video: true }) .then(function (stream) { video.srcObject = stream; video.play(); }) .catch((err) => { console.log(err); alert(err); }); } } async function capturePicture() { let videocanv = new fabric.Canvas(videoCanvas, { isDrawingMode: false, }); videocanv.setHeight(videoWidth / 1.33); videocanv.setWidth(videoWidth); let vidContext = videocanv.getContext(\"2d\"); vidContext.drawImage(video, 0, 0, videoWidth, videoWidth / 1.33); var uri = videoCanvas.toDataURL(\"image/png\", 1); fabric.Image.fromURL(uri, function (oImg) { oImg.scale(1); oImg.set({ left: 0, top: 0 }); canvas.add(oImg); }); video.srcObject.getTracks()[0].stop(); current = \"select\"; } //////////////////// camera functies end /////////////////////////// //////////////////// redo/undo function /////////////////////////// const saveHistory = () => {}; const undo = () => { let lastObject = canvas.toJSON().objects[canvas.toJSON().objects.length - 1]; history.push(lastObject); let newFile = canvas.toJSON(); newFile.objects.pop(); canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas)); // once all previously drawn objects are deleted, isDrawn is set to false if (canvas.toJSON().objects.length == 0) { isDrawn = false; } }; const redo = () => { let newFile = canvas.toJSON(); newFile.objects.push(history[history.length - 1]); history.pop(); canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas)); // once the elements that has been removed are brought back, isDrawn is set back to true if (canvas.toJSON().objects.length > 0) { isDrawn = true; } }; //////////////////// redo/undo function end /////////////////////////// /////////////////// fill functie ////////////////////////////////////// var FloodFill = { // Compare subsection of array1's values to array2's values, with an optional tolerance withinTolerance: function (array1, offset, array2, tolerance) { var length = array2.length, start = offset + length; tolerance = tolerance || 0; // Iterate (in reverse) the items being compared in each array, checking their values are // within tolerance of each other while (start-- && length--) { if (Math.abs(array1[start] - array2[length]) > tolerance) { return false; } } return true; }, // The actual flood fill implementation fill: function ( imageData, getPointOffsetFn, point, color, target, tolerance, width, height ) { var directions = [ [1, 0], [0, 1], [0, -1], [-1, 0], ], coords = [], points = [point], seen = {}, key, x, y, offset, i, x2, y2, minX = -1, maxX = -1, minY = -1, maxY = -1; // Keep going while we have points to walk while (!!(point = points.pop())) { x = point.x; y = point.y; offset = getPointOffsetFn(x, y); // Move to next point if this pixel isn't within tolerance of the color being filled if (!FloodFill.withinTolerance(imageData, offset, target, tolerance)) { continue; } if (x > maxX) { maxX = x; } if (y > maxY) { maxY = y; } if (x < minX || minX == -1) { minX = x; } if (y < minY || minY == -1) { minY = y; } // Update the pixel to the fill color and add neighbours onto stack to traverse // the fill area i = directions.length; while (i--) { // Use the same loop for setting RGBA as for checking the neighbouring pixels if (i < 4) { imageData[offset + i] = color[i]; coords[offset + i] = color[i]; } // Get the new coordinate by adjusting x and y based on current step x2 = x + directions[i][0]; y2 = y + directions[i][1]; key = x2 + \",\" + y2; // If new coordinate is out of bounds, or we've already added it, then skip to // trying the next neighbour without adding this one if (x2 < 0 || y2 < 0 || x2 >= width || y2 >= height || seen[key]) { continue; } // Push neighbour onto points array to be processed, and tag as seen points.push({ x: x2, y: y2 }); seen[key] = true; } } return { x: minX, y: minY, width: maxX - minX, height: maxY - minY, coords: coords, }; }, }; // End FloodFill function hexToRgb(hex, opacity) { opacity = Math.round(opacity * 255) || 255; hex = hex.replace(\"#\", \"\"); var rgb = [], re = new RegExp(\"(.{\" + hex.length / 3 + \"})\", \"g\"); hex.match(re).map(function (l) { rgb.push(parseInt(hex.length % 2 ? l + l : l, 16)); }); return rgb.concat(opacity); } function floodFill(enable) { if (!enable) { canvas.off(\"mouse:down\"); canvas.selection = true; canvas.forEachObject(function (object) { object.selectable = true; }); return; } canvas.discardActiveObject(); canvas.renderAll(); canvas.selection = false; canvas.forEachObject(function (object) { object.selectable = false; }); canvas.on({ \"mouse:down\": function (e) { var mouseX = Math.round(e.e.layerX), mouseY = Math.round(e.e.layerY), //canvas = canvas.lowerCanvasEl, context = canvas.getContext(\"2d\"), parsedColor = hexToRgb(fillColor), imageData = context.getImageData(0, 0, canvas.width, canvas.height), getPointOffset = function (x, y) { return 4 * (y * imageData.width + x); }, targetOffset = getPointOffset(mouseX, mouseY), target = imageData.data.slice(targetOffset, targetOffset + 4); if (FloodFill.withinTolerance(target, 0, parsedColor, fillTolerance)) { // Trying to fill something which is (essentially) the fill color return; } // Perform flood fill var data = FloodFill.fill( imageData.data, getPointOffset, { x: mouseX, y: mouseY }, parsedColor, target, fillTolerance, imageData.width, imageData.height ); if (0 == data.width || 0 == data.height) { return; } var tmpCanvas = document.createElement(\"canvas\"), tmpCtx = tmpCanvas.getContext(\"2d\"); tmpCanvas.width = canvas.width; tmpCanvas.height = canvas.height; var palette = tmpCtx.getImageData( 0, 0, tmpCanvas.width, tmpCanvas.height ); // x, y, w, h palette.data.set(new Uint8ClampedArray(data.coords)); // Assuming values 0..255, RGBA tmpCtx.putImageData(palette, 0, 0); // Repost the data. var imgData = tmpCtx.getImageData( data.x, data.y, data.width, data.height ); // Get cropped image tmpCanvas.width = data.width; tmpCanvas.height = data.height; tmpCtx.putImageData(imgData, 0, 0); // Convert canvas back to image: var img = new Image(); img.onload = function () { canvas.add( new fabric.Image(img, { left: data.x, top: data.y, selectable: false, }) ); }; img.src = tmpCanvas.toDataURL(\"image/png\", 1); canvas.add( new fabric.Image(tmpCanvas, { left: data.x, top: data.y, selectable: false, }) ); }, }); } ///////////////// fill functie end /////////////////////// function backgroundHide() { showBackground = !showBackground; if (!showBackground) { for (let i = 0; i < frames.length; i++) { frames[i].backgroundImage = {}; } canvas.loadFromJSON(frames[currentFrame], canvas.renderAll.bind(canvas)); frames = frames; } else { img.src = backgroundFrames[currentFrame - 1]; } } function switchOption(option) { if (current === option) { optionbox = !optionbox; } else { optionbox = false; current = option; } } let transition = { y: 200, duration: 500 }; if (window.screen.width >= 600) { transition = { x: 200, duration: 500 }; } </script> <main on:mouseup={mouseEvent}> <div class=\"main-container\"> <div class=\"canvas-frame-container\"> {#if current == \"camera\"} <video bind:this={video} autoplay /> <button on:click={capturePicture} class=\"videoButton\" /> <div class=\"videocanvas\"> <canvas bind:this={videoCanvas} /> </div> {/if} <!-- <div class=\"topbar\"> <div> <a on:click={undo}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CCW.svg\"></a> <a on:click={redo}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CW.svg\"></a> </div> </div> --> <div class=\"canvas-box\" class:hidden={current === \"camera\"}> <canvas bind:this={canv} class=\"canvas\" /> <canvas bind:this={Cursor} id=\"cursor\" /> </div> <div class=\"savecanvas\"> <canvas bind:this={saveCanvas} /> </div> <div class=\"frame-box\"> {#if appType == \"stopmotion\" || appType == \"avatar\"} <div id=\"frame-bar\"> {#each frames as frame, index} <div> <div id={index} class:selected={currentFrame === index} on:click={() => { changeFrame(index); console.log(\"debug index of frame:\", index); //remove debug }} style=\"background-image: url({backgroundFrames[index]})\" > <div>{index + 1}</div> </div> {#if currentFrame === index && frames.length > 1} <img class=\"icon\" on:click={() => { deleteFrame(index); }} src=\"assets/SHB/svg/AW-icon-trash.svg\" /> {/if} </div> {/each} {#if frames.length < maxFrames} <div> <div id=\"frameNew\" on:click={addFrame}><div>+</div></div> </div> {/if} </div> <div class=\"frame-buttons\"> {#if play} <a id=\"playPause\" on:click={() => { play = false; setPlay(false); }} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pause.svg\" /></a > {:else} <a id=\"playPause\" on:click={() => { play = true; setPlay(true); }}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-play.svg\" /></a > {/if} <a on:click={backgroundHide} ><img class=\"icon\" class:unselected={!showBackground} src=\"assets/SHB/svg/AW-icon-onion.svg\" /></a > </div> {/if} </div> </div> </div> <div class=\"optionbox-container\"> <div class=\"optionbox\"> <div class=\"optionbar\" class:hidden={optionbox}> <div class=\"colorTab\" class:hidden={current != \"draw\"}> <div class=\"drawing-options-container\"> <img on:click={() => applyBrush(\"Pencil\")} class=\"icon\" class:selected={selectedBrush == \"Pencil\"} src=\"assets/svg/drawing_pencil2.svg\" /> <img on:click={() => applyBrush(\"Circle\")} class=\"icon\" class:selected={selectedBrush == \"Circle\"} src=\"assets/svg/drawing_circle2.svg\" /> <img on:click={() => applyBrush(\"Spray\")} class=\"icon\" class:selected={selectedBrush == \"Spray\"} src=\"assets/svg/drawing_spray.svg\" /> <img on:click={() => applyBrush(\"Pattern\")} class=\"icon\" class:selected={selectedBrush == \"Pattern\"} src=\"assets/svg/drawing_pattern.svg\" /> </div> <!-- <div id=\"drawing-mode-options\"> <select id=\"drawing-mode-selector\"> <option>Pencil</option> <option>Circle</option> <option>Spray</option> <option>Pattern</option> <option>hline</option> <option>vline</option> <option>square</option> <option>diamond</option> <option>texture</option> </select> </div> --> <!-- <div class=\"widthBox\" style=\"background-color: {drawingColor};\" on:click={() => { drawingColorEl.click(); }} > </div> --> <input type=\"color\" bind:value={drawingColor} bind:this={drawingColorEl} id=\"drawing-color\" /> <!-- <img class=\"colorIcon\" src=\"assets/SHB/svg/AW-icon-paint.svg\" /> --> <!-- <span class=\"info\">{lineWidth}</span> --> <div class=\"range-container\"> <div class=\"circle-box-small\" /> <input type=\"range\" min=\"10\" max=\"500\" id=\"drawing-line-width\" bind:value={lineWidth} /> <div class=\"circle-box-big\" /> </div> <!-- <label for=\"drawing-shadow-color\">Shadow color:</label> <input type=\"color\" bind:value={shadowColor} id=\"drawing-shadow-color\" /> <label for=\"drawing-shadow-width\">Shadow width:</label> <span class=\"info\">0</span><input type=\"range\" bind:value={shadowWidth} min=\"0\" max=\"50\" id=\"drawing-shadow-width\" /> <label for=\"drawing-shadow-offset\">Shadow offset:</label> <span class=\"info\">0</span><input type=\"range\" bind:value={shadowOffset} min=\"0\" max=\"50\" id=\"drawing-shadow-offset\" /> --> </div> <div class=\"eraseTab\" class:hidden={current != \"erase\"}> <!-- <div class=\"widthBox\"> <div class=\"lineWidth\" style=\"background-color: black;margin: 0px auto;\" /> </div> <span class=\"info\">{lineWidth}</span> --> <div class=\"range-container\"> <div class=\"circle-box-small\" /> <input type=\"range\" min=\"10\" max=\"500\" id=\"erase-line-width\" bind:value={lineWidth} /> <div class=\"circle-box-big\" /> </div> </div> <div class=\"fillTab\" class:hidden={current != \"fill\"}> <input type=\"color\" bind:value={fillColor} id=\"fill-color\" /> </div> <div class=\"selectTab\" class:hidden={current != \"select\"}> <a on:click={Copy} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-copy.svg\" /></a > <a on:click={Paste} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-paste.svg\" /></a > <a on:click={Delete} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-trash.svg\" /></a > </div> <div class=\"saveBox\" class:hidden={current != \"saveToggle\"}> <div class=\"saveTab\"> {#if appType != \"avatar\" && appType != \"house\"} <label for=\"title\">Title</label> <NameGenerator bind:value={displayName} bind:invalidTitle bind:isTitleChanged /> {/if} <!-- <label for=\"status\">Status</label> <select bind:value={status} on:change={() => (answer = \"\")}> {#each statussen as status} <option value={status}> {status} </option> {/each} </select> --> <div class=\"status-save-download-container\"> {#if appType != \"avatar\" && appType != \"house\"} <div on:click={changeVisibility}> {#if status} <img class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-visible.svg\" /> {:else} <img class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-invisible.svg\" /> {/if} </div> {/if} <div> <!-- {#if saving} --> <!-- <img on:click={upload} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-history.svg\" /> --> <!-- {:else if saved} --> <img on:click={upload} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-check.svg\" /> <!-- {/if} --> </div> <!-- <button on:click={upload} >{#if saving}Saving{:else if saved} Saved{:else}Save{/if}</button > --> <div> <!-- {#if saved} --> <img on:click={download} class=\"icon selected\" src=\"assets/SHB/svg/AW-icon-save.svg\" /> <!-- {/if} --> </div> </div> <!-- {#if saved} <button >Download</button> {/if} --> </div> </div> </div> <div class=\"iconbox\"> <a on:click={undo} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CCW.svg\" /></a > <a on:click={redo} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-rotate-CW.svg\" /></a > <a on:click={applyBrush} id=\"drawing-mode\" class:currentSelected={current === \"draw\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pen.svg\" /></a > <a id=\"erase-mode\" class:currentSelected={current === \"erase\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-erase.svg\" /></a > <!-- <button class=\"icon\" id=\"fill-mode\" class:currentSelected={current === \"fill\"}><BucketIcon /></button > --> <a id=\"select-mode\" class:currentSelected={current === \"select\"} ><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-pointer.svg\" /></a > <!-- {#if \"mediaDevices\" in navigator && \"getUserMedia\" in navigator.mediaDevices} <button class=\"icon\" id=\"camera-mode\" class:currentSelected={current == \"camera\"} on:click={camera}><CameraIcon /></button > {/if} --> <!-- <button id=\"clear-canvas\" class=\"btn btn-info icon\"> <TrashIcon /> </button> --> <!-- svelte-ignore a11y-missing-attribute --> <a class:currentSelected={current === \"saveToggle\"} on:click={() => { // console.log(\"saving is clicked\"); // console.log(\"length\", canvas.toJSON().objects); if ( appType == \"drawing\" || appType == \"stopmotion\" || appType == \"house\" || appType == \"avatar\" ) { saveToggle = !saveToggle; switchOption(\"saveToggle\"); } }}><img class=\"icon\" src=\"assets/SHB/svg/AW-icon-save.svg\" /></a > </div> </div> </div> <div id=\"clear-canvas\"><img src=\"assets/SHB/svg/AW-icon-reset.svg\" /></div> {#if appType == \"avatar\"} <div id=\"avatarBox\"> <Avatar /> </div> {/if} </main> <style> * { box-sizing: border-box; padding: 0; margin: 0; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .main-container { display: flex; align-items: center; margin-left: 60px; justify-content: flex-end; /* justify-content: space-around; */ margin: 20px 20px 0 0; } #cursor { pointer-events: none !important; width: 100vw; height: 100vw; margin: 0px; position: absolute; user-select: none; top: 0px; left: 0px; pointer-events: none; } .topbar { width: 100vw; margin: 0px auto; } .selected { box-shadow: 3px 3px #7300ed; } .colorTab { display: flex; flex-direction: column; align-items: center; } .saveTab { min-width: 160px; bottom: 50px; z-index: 1; } .savecanvas { display: none; } .saveTab > * { padding: 12px 16px; text-decoration: none; display: block; } .saveBox { position: relative; display: inline-block; } .saveBox:hover .saveTab { display: block; color: green; } .iconbox { width: 50px; position: relative; display: flex; justify-content: center; align-items: center; flex-direction: column; flex-wrap: wrap; transition: all 0.5s ease-in-out; } .optionbar { margin-left: 10px; border-right: 2px solid #7300ed; /* box-shadow: 10px 0px 5px 0px rgba(115,0,237,0.5); */ height: 100vh; background-color: white; transition: all 0.5s ease-in-out; width: fit-content; padding: 15px; transform: translateX(0%); width: 280px; display: flex; justify-content: center; align-items: center; flex-direction: column; flex-wrap: wrap; } .optionbar.hidden { width: 0px; transform: translateX(-160%); display: inline; padding: 0px; margin: 0px; } .optionbar.hidden > * { display: none; } .optionbar > * { /* margin: 5px auto; */ } .icon { min-width: 50px; height: 50px; border-radius: 50%; padding: 5px 0px 5px 0px; cursor: pointer; } #drawing-color, #drawing-shadow-color { padding: 0px; display: block; margin: 20px auto; } .optionbox { width: fit-content; display: flex; } .currentSelected { box-shadow: 0px 4px #7300ed; border-radius: 0% 50% 50% 0; height: 60px; display: block; width: 49px; padding: 0px; background-color: white; margin-left: -5px; } .hidden { display: none; } .videoButton { border-radius: 50%; padding: 25px; margin: 0 auto; background: red; display: block; } .lineWidth { border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } .range-container { display: flex; flex-direction: row; flex-wrap: nowrap; align-items: center; } .circle-box-small { border: solid 2px black; border-radius: 50%; padding: 5px; } .circle-box-big { border: solid 2px black; border-radius: 50%; padding: 10px; } input[type=\"range\"] { -webkit-appearance: none; -moz-apperance: none; border-radius: 6px; border: 4px solid #7300ed; height: 4px; margin: 0 10px; } input[type=\"range\"]::-webkit-slider-thumb { -webkit-appearance: none !important; background-color: black; border: 1px solid black; border-radius: 50%; height: 15px; width: 15px; } /* .colorIcon { width: 32px; position: absolute; right: 5px; bottom: 5px; } */ .canvas-box { position: relative; background-color: white; border: 2px solid #7300ed; } .frame-box { display: flex; justify-content: center; align-items: center; position: relative; flex-direction: column; } #frame-bar { display: flex; flex-direction: column; max-height: 300px; width: 130px; overflow-y: auto; overscroll-behavior-y: contain; scroll-snap-type: y proximity; } #frame-bar > div { display: flex; justify-content: center; align-items: center; flex-direction: row; } #frame-bar > div > div { display: inline-block; width: 60px; height: 60px; margin: 5px; border: 2px solid #7300eb; font-size: 30px; text-align: center; background-position: center; background-repeat: no-repeat; background-size: contain; } #frame-bar > div > div:hover { cursor: pointer; } #frame-bar > div > div > div { height: 60px; display: flex; justify-content: center; align-items: center; } .frame-buttons { display: flex; flex-direction: column; } .frame-buttons > a > img { display: block; } #clear-canvas { position: fixed; left: 8px; top: 80px; z-index: 13; box-shadow: 5px 5px 0px #7300ed; cursor: pointer; padding: 0; margin: 0; border-radius: 50%; width: 40px; height: 40px; } #clear-canvas > img { width: 40px; } video { margin: 0 auto; display: block; } .canvas-frame-container { display: flex; flex-direction: row; } .topbar { width: unset; } .topbar { float: left; height: 100vh; } .topbar > div { display: inline-grid; position: relative; top: 50%; margin: 10px; -ms-transform: translateY(-50%); transform: translateY(-50%); } #frame-bar > div:last-child { overflow-anchor: auto; } .optionbox-container { margin: 0 10px 0 0; position: fixed; left: 0; top: 50vh; -ms-transform: translateY(-50%); transform: translateY(-50%); } .unselected { filter: grayscale(1) opacity(0.5); } #avatarBox { position: fixed; top: 130px; left: 20px; } .drawing-options-container { display: flex; flex-direction: row; flex-wrap: wrap; } .status-save-download-container { display: flex; flex-direction: column; /* justify-content: center; */ /* align-items: center; */ height: min-content; } /* medium size */ @media only screen and (max-width: 1007px) { .canvas-frame-container { flex-direction: column; } .frame-box { flex-direction: row; } #frame-bar { flex-direction: row; width: 250px; overflow-x: auto; overflow-y: none; overscroll-behavior-x: contain; scroll-snap-type: x proximity; } #frame-bar > div { flex-direction: column; } .frame-buttons { flex-direction: row; } } /* small */ @media only screen and (max-width: 640px) { .main-container { display: unset; align-items: unset; margin: 0; } .canvas-frame-container { justify-content: center; align-items: center; } .canvas-box { order: 2; } .frame-box { order: 1; flex-direction: row; /* width: 100%; */ justify-content: space-between; /* align-self: flex-end; */ } #frame-bar { max-width: 300px; height: 140px; margin-right: 10px; } #frame-bar > div { flex-direction: column-reverse; } .frame-buttons { flex-direction: column-reverse; margin: unset; align-self: center; } .optionbox { width: 100%; height: min-content; position: fixed; bottom: 0; display: block; } .optionbar { margin: 0; border-right: none; border-top: 2px solid #7300ed; box-shadow: 0px -5px 5px 0px #7300ed; height: min-content; width: 100%; padding: 0px; transition: none; animation: growup 0.3s ease-in-out forwards; transform-origin: bottom center; position: sticky; z-index: 40; align-items: flex-end; } .optionbar > * { margin: 20px 50px 20px 0; } .status-save-download-container { flex-direction: row; justify-content: space-between; } @keyframes growup { 0% { transform: scaleY(0); } 80% { transform: scaleY(1.1); } 100% { transform: scaleY(1); } } .optionbar.hidden { margin: 0; border-right: none; height: min-content; width: auto; transform: none; display: inline; animation: growdown 2s ease-in-out forwards; } @keyframes growdown { 0% { transform: scaleY(1); } 50% { transform: scaleY(0.5); } 100% { transform: scaleY(0); } } .optionbox-container { position: fixed; -ms-transform: initial; transform: initial; } .currentSelected { display: inline; } .iconbox { width: max-content; height: min-content; display: block; margin: 0 auto; } .currentSelected > img { border: 2px solid #7300ed; } .currentSelected { box-shadow: unset; } #clear-canvas { top: unset; bottom: 60px; } } </style> Het gaat vooral om deze componenten: let FrameObject = { type: \"image\", version: \"4.6.0\", originX: \"left\", originY: \"top\", left: -1024, top: 0, width: 0, height: 1024, fill: \"rgb(0,0,0)\", stroke: null, strokeWidth: 0, strokeDashArray: null, strokeLineCap: \"butt\", strokeDashOffset: 0, strokeLineJoin: \"miter\", strokeUniform: false, strokeMiterLimit: 4, scaleX: 1, scaleY: 1, angle: 0, flipX: false, flipY: false, opacity: 1, shadow: null, visible: true, backgroundColor: \"\", fillRule: \"nonzero\", paintFirst: \"fill\", globalCompositeOperation: \"source-over\", skewX: 0, skewY: 0, erasable: true, cropX: 0, cropY: 0, src: \"\", crossOrigin: \"anonymous\", filters: [], }; const updateFrame = () => { frames[currentFrame] = canvas.toJSON(); console.log(\"currentFrame\", currentFrame) frames = frames; backgroundFrames[currentFrame] = canvas.toDataURL(\"image/png\", 1); backgroundFrames = backgroundFrames; }; lastImg = await convertImage(Object.value.url); // dit moet ingeladen worden zonder convertImage, maar met de raw versie isPreexistingArt = true; let frameAmount; var framebuffer = new Image(); framebuffer.src = lastImg; framebuffer.onload = function () { console.log(\"img\", this.width); lastWidth = this.width; frameAmount = lastWidth / 2048; FrameObject.src = lastImg; FrameObject.width = lastWidth; frames = []; for (let i = 0; i < frameAmount; i++) { FrameObject.left = 0; FrameObject.width = 2048; FrameObject.cropX = i * 2048; frames.push({ version: \"4.6.0\", objects: [{ ...FrameObject }], });","title":"Color picker in svelte"},{"location":"4.%20bugs/fixed/Cors-error-on-retrieving-images/","text":"Access to image at 'https://artworld01.s3.eu-central-1.amazonaws.com/avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-28T14_17_06_GroenBaard.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA3VY3XUKP6SYAM4OK%2F20230104%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20230104T104203Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=a72c2f7bd20029e2546f5fc4965a8d378c9e1ef8977ef67e3be22d4300bd9476' from origin 'https://artworld.vrolijkheid.nl' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. https://aws.amazon.com/premiumsupport/knowledge-center/no-access-control-allow-origin-error/ curl -H \"Origin: artworld.vrolijkheid.nl\" -v \"https://artworld01.s3.eu-central-1.amazonaws.com/avatar/fcbcc269-a109-4a4b-a570-5ccafc5308d8/0_2022-12-28T14_17_06_GroenBaard.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIA3VY3XUKP6SYAM4OK%2F20230104%2Feu-central-1%2Fs3%2Faws4_request&X-Amz-Date=20230104T104203Z&X-Amz-Expires=86400&X-Amz-SignedHeaders=host&X-Amz-Signature=a72c2f7bd20029e2546f5fc4965a8d378c9e1ef8977ef67e3be22d4300bd9476\" return: Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < x-amz-id-2: Z0a88pOWAFUgOmBCB/R0e3TPg66g7v7CeKtjwYeeshOYpLugd8NCFg5E3EdBudQlH8EuXhSLFnc= < x-amz-request-id: HS542A220XJFVABR < Date: Wed, 04 Jan 2023 10:48:29 GMT < Access-Control-Allow-Origin: * < Access-Control-Allow-Methods: PUT, HEAD, GET < Vary: Origin, Access-Control-Request-Headers, Access-Control-Request-Method < Last-Modified: Mon, 02 Jan 2023 14:25:35 GMT < ETag: \"8e07129259d6e55599fb94b47714c078\" < x-amz-version-id: cHPlJHGeZEB1.MaX7IRw7klhDe2Z3dj4 < Accept-Ranges: bytes < Content-Type: multipart/form-data < Server: AmazonS3 < Content-Length: 159817 cloudfront page https://us-east-1.console.aws.amazon.com/cloudfront/v3/home?region=eu-central-1#/originAccess/ hypothesis 1: the image is first retreived with an empty value. Because of the way displayName is updated. To test: go back to commit that does not have that code Result: going back didn't solve the issue. Test 2: go back further (to when it did work) With commit 8caa677c538f888220791e290224fdf533073b48 downloading and editing artworks works: So we see above that even when it works there is a undefined asked from the server, with a 404 response. But in our case we also get a cors problem: git log of commits: d1735d059859cc3a968030f4825afbc8cd75da19 - when I tried to solve the drawing over the edge bug, but had not changed the displayName 8118fd2da334d346657bc4e9b9968f462b79da78 - the commit with Eelkes code before I started to alter the drawing app 8caa677c538f888220791e290224fdf533073b48 - before Eelke, working without cors if (appType == \"avatar\") { lastImg = await convertImage($Profile.avatar_url, \"2048\", \"10000\"); isPreexistingArt = true; then to put the image on the canvas: // put images on canvas if (appType == \"avatar\" || appType == \"stopmotion\") { console.log(\"avatar\"); let frameAmount; var framebuffer = new Image(); framebuffer.src = lastImg; framebuffer.onload = function () { console.log(\"img\", this.width); lastWidth = this.width; frameAmount = lastWidth / 2048; FrameObject.src = lastImg; FrameObject.width = lastWidth; frames = []; for (let i = 0; i < frameAmount; i++) { FrameObject.left = 0; FrameObject.width = 2048; FrameObject.cropX = i * 2048; // FrameObject.clipTo = function (ctx) { // // origin is the center of the image // // var x = rectangle.left - image.getWidth() / 2; // // var y = rectangle.top - image.getHeight() / 2; // // ctx.rect(i * -2048, 2048, (i * -2048)+2048, 2048); // ctx.rect(0,-2048,2048,2048) // }; // FrameObject.setCoords(); frames.push({ version: \"4.6.0\", objects: [{ ...FrameObject }], }); } frames = frames; console.log(\"frames\", frames); currentFrame = 0; canvas.loadFromJSON(frames[0], function () { canvas.renderAll.bind(canvas); // for (let i = 0; i < frames.length; i++) { // updateFrame() // changeFrame(i) // } }); }; } let FrameObject = { type: \"image\", version: \"4.6.0\", originX: \"left\", originY: \"top\", left: -2048, top: 0, width: 0, height: 2048, fill: \"rgb(0,0,0)\", stroke: null, strokeWidth: 0, strokeDashArray: null, strokeLineCap: \"butt\", strokeDashOffset: 0, strokeLineJoin: \"miter\", strokeUniform: false, strokeMiterLimit: 4, scaleX: 1, scaleY: 1, angle: 0, flipX: false, flipY: false, opacity: 1, shadow: null, visible: true, backgroundColor: \"\", fillRule: \"nonzero\", paintFirst: \"fill\", globalCompositeOperation: \"source-over\", skewX: 0, skewY: 0, erasable: true, cropX: 0, cropY: 0, src: \"\", crossOrigin: \"anonymous\", filters: [], }; But here the avatar is loaded with the convertImage -> that is wrong because then the quality of the avatar get worse over time! We need to get the image without conversion. Is that with the getFile api function? export async function getFile(file_url) { const payload = { \"url\": file_url }; let url const rpcid = \"download_file\"; await client.rpc(Sess, rpcid, payload) .then((fileurl) => { url = fileurl.payload.url //console.log(\"url\") //console.log(url) return url }) .catch(() => { console.log('fail') return '' }) return url } git log before Eelke: commit c87da81339cdc1e1831ed05675083846a7de6727 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 22:36:10 2022 +0200 removed multiplayer from animalGarden because of crash when someone joint the garden commit 78aa5bfdc328443a51457b83d20fc03a6709ae00 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 21:11:38 2022 +0200 save stopmotions when adding a frame to prevent data loss commit d218d7c78aafb15a24eb63634568b3aaa9c7ff6e Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 21:07:24 2022 +0200 save stopmotions when adding a frame to prevent data loss commit e9735a9436badaaa7cd93f68e4d7b114752a4a34 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 14:36:11 2022 +0200 debug animalChallenge commit a1742295a72c6cd77bd2cb1211079a3bb2f21e5d Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 14:32:15 2022 +0200 debug animalChallenge commit 323dcdd4f66158ecfdb76b5046e0d93e10aa5030 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 14:22:10 2022 +0200 debugging animalChallenge fixed some issues, look into rest commit bb99cc08bce849f1847dbde5f67e1c9d94f8c029 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 13:26:58 2022 +0200 halved the artwork resolution to 1024 to save resources on poor laptops commit 45667ae850d5936f6f8134f5e6c423e61b721238 Author: maarten maartenvanderglas@gmail.com Date: Sun Jul 24 12:35:35 2022 +0200 console.log behind a boolean flag via nakama.svelte and ManageSession.js commit 48eb228fe47457d876f04bbcb6f85baf63e41056 Author: maarten maartenvanderglas@gmail.com Date: Fri Jul 22 22:14:45 2022 +0200 made world 5500x5500 commit c938bddf63c2a46968c750628a2012432412c9a8 Author: maarten maartenvanderglas@gmail.com Date: Fri Jul 22 22:11:53 2022 +0200 made world 5000x5000 commit bf47e052c76fd0e3eb607b83ed03698605745efb Author: maarten maartenvanderglas@gmail.com Date: Fri Jul 22 22:02:42 2022 +0200 made world 5500x5500 commit 854d1188b629fa9da97171e25d325633d05de619 Author: maarten maartenvanderglas@gmail.com Date: Thu Jul 21 18:32:18 2022 +0200 changed artworld size to 8000x8000 commit e51a8149be35cc214b369f0aaa252706603ea140 Author: maarten maartenvanderglas@gmail.com Date: Thu Jul 21 18:19:37 2022 +0200 increased artworld size commit e5f5589b05c91525465bfaf314d7b58d4fd99343 Author: linjoe linjoe@localhost.localdomain Date: Thu Jul 21 17:56:12 2022 +0200 add username to email in register commit 4785a0cb0ac7216a53cda34d61fc7274c990aeba Author: linjoe linjoe@localhost.localdomain Date: Thu Jul 21 16:30:07 2022 +0200 qr fix commit 9e1b18f0b70862058917d71849ddfe55c3dc2985 Author: linjoe linjoe@localhost.localdomain Date: Thu Jul 21 14:22:59 2022 +0200 qr code and history bugfix commit a018c848df473dba8dfec71400da1f730a453ebc Author: maarten maartenvanderglas@gmail.com Date: Thu Jul 21 11:53:48 2022 +0200 fixed gl outline bug, plugin in sloading in artworld scene, should still load in global setup","title":"Log: cors error on retrieving images"},{"location":"4.%20bugs/fixed/Status-van-de-itemsbar-speler-en-moderator-werd-niet-goed-geupdate/","text":"De status van de het vorige item werd overgenomen als er een aanpassing werd gedaan. Lindsey zegt dat de lijst van items nu wel goed wordt update. row.permission_read kon 2 of 1 zijn, dat is nu 1 of 0 voor zichtbaar/ onzichtbaar","title":"Log: status van de itemsbar (speler en moderator) werd niet goed geupdate"},{"location":"4.%20bugs/fixing/bug-fix-homes-of-turquoisetriangle-missing/","text":"A lot of homes of TurquoiseTriangle are missing. I made a mistake naming the Azc Torquoise, so the Azc and the homeObject are spelled wrong. Fix: user Azc Fix: user homeObjects Extra fixes: I inadvertently deleted the homeObject of user19. FIX THAT! But also fix the error that the itemsBar cannot be opened to select a default homeObject imagePicker.svelte:195 Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'url') at Object.create [as c] (imagePicker.svelte:195:31) at Object.update [as p] (imagePicker.svelte:189:9) at update$2 (index.mjs:1093:36) stopmotion.svelte:18 Uncaught TypeError: Cannot read properties of undefined (reading 'clientWidth') at stopmotion.svelte:18:18","title":"Bug Fix: homes of TurquoiseTriangle missing"}]}