<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../../img/favicon.ico" />
    <title>Log: BugFix: Drawing over the edge - ARTWORLD Documentation</title>
    <link rel="stylesheet" href="../../../css/theme.css" />
    <link rel="stylesheet" href="../../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Log: BugFix: Drawing over the edge";
        var mkdocs_page_input_path = "4. bugs/fixed/Bugfix-drawing-over-the-edge.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../../.." class="icon icon-home"> ARTWORLD Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../../..">Using MkDocs for ARTWORLD documentation</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">1. implementation</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/0-List-of-tasks/">0 List of tasks</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Avatar/">Avatar</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/BetaWorld/">domain names</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Chat-Message-Functionality/">Chat Message Functionality</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Compression-Tests-Images/">Compression Tests Images</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Conventions/">Conventions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Coordinate-System-Conversion/">Coordinate System Conversion</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Create_and_update_SERVER_OBJECT_examples/">Create and update SERVER OBJECT examples</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Create_onlinePlayers_diagram/">Create onlinePlayers diagram</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Depth_of_elements_in_game/">Depth of elements in game</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Download_art_Images_flow/">Download art Images flow</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/HistoryTracker-and-the-Back-button/">HistoryTracker and the Back button</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Home-and-server-OBJECT/">Home and server OBJECT</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Home/">Home</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/How_to_deploy_artworld/">How to deploy ARTWORLD</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Items-bar/">Items bar</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/LOG-release-notes/">LOG release notes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Last-Position-Players/">Last Position Players</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Like%28Heart%29-Button-and-OBJECT/">Like(Heart) Button and OBJECT</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Locations-OBJECT/">Locations OBJECT</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Movement---player/">Movement   player</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Movement--onlinePlayer/">Movement  onlinePlayer</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Network-Flow-Client-Side/">Network Flow Client Side</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/PNG_Compression_percentages/">PNG Compression percentages</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Parsing-URL-Parameters---Phaser-onboarding/">Parsing URL Parameters   Phaser onboarding</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Phaser_error_handling/">Phaser error handling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Phaser_event_system/">Phaser event system</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/RELEASE_LOG/">RELEASE LOG</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/SERVEROBJECT-achievements/">SERVEROBJECT achievements</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/SERVEROBJECT-addressbook/">SERVEROBJECT addressbook</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/SERVEROBJECT-liked/">SERVEROBJECT liked</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/ServerCallsFormat/">ServerCallsFormat</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Storage.js/">Storage.js</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/Svelte-spa-router-query-params-demo---refactoring/">Svelte spa router query params demo   refactoring</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../../1.%20implementation/UI-scrollable-panels/">UI scrollable panels</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">2. research notes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../../2.%20research%20notes/Icons-and-svg-FREE/">Icons and svg FREE</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Phaser3</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/A-canvas-can-be-used-as-a-Texture/">A canvas can be used as a Texture</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Add-3D-to-Phaser/">Add 3D to Phaser</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Add-a-plugin-to-a-scene/">Add a plugin to a scene</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Add-scene-on-the-fly/">Add scene on the fly</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Automatic-Scene-loading-flag/">Automatic Scene loading flag</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Background-image-repeating/">Background image repeating</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Camera-effects%2C-colors%2C-fade/">Camera effects, colors, fade</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Camera-follow/">Camera follow</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Change-Gravity-per-sce/">Change Gravity per sce</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Changing-the-collision-shape%2C-size%2C-mouse-input-events/">Changing the collision shape, size, mouse input events</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Check-world-bounds/">Check world bounds</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/DOM-elements-in-phaser-and-as-input/">DOM elements in phaser and as input</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Datamanager-system-registry/">Datamanager system registry</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Disable-mouse-input-from-outside-the-canvas/">Disable mouse input from outside the canvas</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Drag-containers-%28also-scenes%21%29/">Drag containers (also scenes!)</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Dragging/">Dragging</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Drawing-ideas-and-examples-Phaser/">Drawing ideas and examples Phaser</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Experimenting-with-different-backgrounds/">Experimenting with different backgrounds</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Groups-vs-containers/">Groups vs containers</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/How-to-manage-lots-of-particle-emitter-managers/">Note: How to manage lots of Particle Emitter (Managers)?</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Infinite-world/">Infinite world</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/LoaderPlugin-feedback/">LoaderPlugin feedback</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Loading-and-preloading/">Loading and preloading</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/No-Physics-possible-between-Scenes/">No Physics possible between Scenes</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Pause-and-resume-a-scene/">Pause and resume a scene</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Pausing-game-engine/">Note:  Pausing game engine</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Phaser---timed-Events/">Phaser   timed Events</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Physics---overlap/">Physics   overlap</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Scaling-the-game---res-and-ppi/">Scaling the game   res and ppi</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Sending-data-to-scenes/">Sending data to scenes</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Separate-UI-with-a-overlay-Scene/">Separate UI with a overlay Scene</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Speech-bubble-GRAPHIC-across-SCENES/">Speech bubble GRAPHIC across SCENES</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Starting-and-stopping-scenes/">Starting and stopping scenes</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/TextureManager/">TextureManager</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../2.%20research%20notes/phaser3/Using-classes-for-GameObjects-and-extending-Phaser-Classes/">Using classes for GameObjects and extending Phaser Classes</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">3. features</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="#">Done</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Download-flipbooks/">Feature: download FLIPBOOKS</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Illustrations-fire-world/">Illustrations Fire World</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Illustrations-robot-world/">Illustrations Robot World</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Implement-robotworld-2022-12-20/">Log: implement RobotWorld 2022.12.20</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Merging-2023-01-20/">Merging 2023-01-20</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Physics-debug-in-gameedit-mode/">Log: feature - physics debug in gameEdit mode</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Place-visitor-next-to-house/">Log: feature - place visitor next to house</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/Save%20an%20ARTWORK%20as%20an%20other%20OBJECT/">Feature: save an ARTWORK as an other OBJECT</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/done/User-can-change-name/">Feature: user can change name</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Ideas</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/ideas/Bug-no-home-object/">Log: bug: no home Object</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Working on</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../../3.%20features/working%20on/Update-phaser-from-3-55-to-3-70-0/">Log: update Phaser from 3.55 to 3.70.0</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">4. bugs</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Fixed</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../Bug-aanpassen-touch-targets-werelden-fixed/">BugFix: Aanpassen ‘touch targets’ werelden [fixed]</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Bug-cant-edit-avatar/">Log: Bug - can't edit AVATAR</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Bug-fix-players-are-lost-when-switching-location/">Log: bug Fix - players are lost when switching location</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Bug-load-assets-per-scene-with-error-handling/">BugFix: load assets per scene, with error handling</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Bug-tracking-100-cpu-usage/">Log: bug tracking 100% CPU usage</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Log: BugFix: Drawing over the edge</a>
    <ul class="current">
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Cors-error-on-retrieving-images/">Log: cors error on retrieving images</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../Status-van-de-itemsbar-speler-en-moderator-werd-niet-goed-geupdate/">Log: status van de itemsbar (speler en moderator) werd niet goed geupdate</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Fixing</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../fixing/bug-fix-homes-of-turquoisetriangle-missing/">Bug Fix: homes of TurquoiseTriangle missing</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../..">ARTWORLD Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">4. bugs</li>
          <li class="breadcrumb-item">Fixed</li>
      <li class="breadcrumb-item active">Log: BugFix: Drawing over the edge</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <p>WE DONT HAVE ENOUGH TIME TO REFACTOR TO PAINTERRO</p>
<p>so I am trying to implement a new solution:</p>
<ol>
<li>
<p>DrawingCanvas</p>
</li>
<li>
<p>SaveCanvas</p>
</li>
</ol>
<p>This workes and is done, after this is it still good to refactor to Painterro, because performance is lacking on an iPad for instance.</p>
<hr />
<p>Working code so far:</p>
<pre><code>var canvas = new fabric.Canvas(document.getElementById('canvasId'))
var canvas2 = new fabric.Canvas(document.getElementById('canvasId2'))

var canvas3 = new fabric.Canvas(document.getElementById('canvasId3'))

canvas.isDrawingMode = true;
canvas.freeDrawingBrush.width = 5;
canvas.freeDrawingBrush.color = '#00aeff';

canvas2.isDrawingMode = true;
canvas2.freeDrawingBrush.width = 10;
canvas2.freeDrawingBrush.color = '#ffaeff';

canvas.on('path:created', function(e) {
  e.path.set();
  canvas.renderAll();

  const preview = canvas.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview, (img) =&gt; {      
    canvas3.add(img.set({ left: 0, top: 0, height: 400,
        width: 400 }))
 },{ crossOrigin: 'anonymous' },
);

});

canvas2.on('path:created', function(e) {
  e.path.set();
  canvas2.renderAll();

  const preview2 = canvas2.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview2, (img) =&gt; {      
    canvas3.add(img.set({ left: 400, top: 0, height: 400,
        width: 400 }))
 },{ crossOrigin: 'anonymous' },
);

});
</code></pre>
<p><img alt="" src="https://artworlddev.maartenvanderglas.com/wp-content/uploads/2022/12/Screenshot-from-2022-12-29-16-32-27.png" /></p>
<hr />
<p>code with 2 canvas and filtering out the last drawing (other wise fabric adds an image each time when having drawn, in effect creating an undo /redo stack!</p>
<pre><code>var canvas = new fabric.Canvas(document.getElementById('canvasId'))
var clearCanvas = document.getElementById('clear-canvas');


var canvas2 = new fabric.Canvas(document.getElementById('canvasId2'))

var canvas3 = new fabric.Canvas(document.getElementById('canvasId3'))

canvas.isDrawingMode = true;
canvas.freeDrawingBrush.width = 5;
canvas.freeDrawingBrush.color = '#00aeff';

canvas2.isDrawingMode = true;
canvas2.freeDrawingBrush.width = 10;
canvas2.freeDrawingBrush.color = '#ffaeff';


clearCanvas.onclick = function() { canvas.clear();         pushCanvasToPreview(canvas, 0);
};

function pushCanvasToPreview(_canvas, frameNumber) {
const previewCanvasObjects = canvas3.getObjects();

    //remnove all objects with frame: frameNumber
    // that way there is only 1; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === frameNumber){
        canvas3.remove(element);
      }
    })

  const leftOffset = frameNumber * 400

  const preview = _canvas.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview, (img) =&gt; {      
    canvas3.add(img.set({ left: leftOffset, top: 0, height: 400,
        width: 400, frame: frameNumber}))
 },{ crossOrigin: 'anonymous' },
);
  const canvasObjects = canvas3.getObjects();
  console.log(canvasObjects)
  return preview;
}

canvas.on('path:created', function(e) {
  e.path.set();
  canvas.renderAll();

  pushCanvasToPreview(canvas, 0)

});

canvas2.on('path:created', function(e) {
  e.path.set();
  canvas2.renderAll();

  pushCanvasToPreview(canvas2, 1);
});
</code></pre>
<hr />
<p>Select between drawing canvas:</p>
<pre><code>var canvas = new fabric.Canvas(document.getElementById('canvasId'))
var clearCanvas = document.getElementById('clear-canvas');
var selectedCanvas = 1;

var selectedCanvas1 = document.getElementById('selectCanvas1');
var selectedCanvas2 = document.getElementById('selectCanvas2');
// var canvas2 = new fabric.Canvas(document.getElementById('canvasId2'))

var canvas3 = new fabric.Canvas(document.getElementById('previewCanvas'))

canvas.isDrawingMode = true;
canvas.freeDrawingBrush.width = 5;
canvas.freeDrawingBrush.color = '#00aeff';

canvas.on('path:created', function(e) {
  e.path.set();
  canvas.renderAll();

  pushCanvasToPreview(canvas, selectedCanvas)

});

clearCanvas.onclick = function() { canvas.clear(); pushCanvasToPreview(canvas, selectedCanvas);
};

selectedCanvas1.onclick = function () {
  selectedCanvas = 0; 
  canvas.clear();
};

selectedCanvas2.onclick = function () {
  selectedCanvas = 1; 
  canvas.clear();                
};


function pushCanvasToPreview(_canvas, frameNumber) {
  const previewCanvasObjects = canvas3.getObjects();
    //remnove all objects with frame: frameNumber
    // that way there is only 1 image layer; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === frameNumber){
        canvas3.remove(element);
      }
    })

  const leftOffset = frameNumber * 400

  const preview = _canvas.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview, (img) =&gt; {      
    canvas3.add(img.set({ left: leftOffset, top: 0, height: 400,
        width: 400, frame: frameNumber}))
 },{ crossOrigin: 'anonymous' },
);
  const canvasObjects = canvas3.getObjects();
  console.log(canvasObjects)
  return preview;
}
</code></pre>
<hr />
<p>Working code for drawing canvas, SaveCanvas, can switch between canvas and keep drawing. Undo is disabled (filtered out), but could be turned on again</p>
<pre><code>var canvas = new fabric.Canvas(document.getElementById('canvasId'))
var clearCanvas = document.getElementById('clear-canvas');
var selectedCanvas = 0;

var selectedCanvas1 = document.getElementById('selectCanvas1');
var selectedCanvas2 = document.getElementById('selectCanvas2');
// var canvas2 = new fabric.Canvas(document.getElementById('canvasId2'))

var canvas3 = new fabric.Canvas(document.getElementById('previewCanvas'))

canvas.isDrawingMode = true;
canvas.freeDrawingBrush.width = 5;
canvas.freeDrawingBrush.color = '#00aeff';

canvas.on('path:created', function(e) {
  e.path.set();
  canvas.renderAll();
  pushCanvasToPreview(canvas, selectedCanvas)
});

clearCanvas.onclick = function() { 
  canvas.clear(); 
  pushCanvasToPreview(canvas, selectedCanvas);
};

selectedCanvas1.onclick = function () {
  selectedCanvas = 0; 
  canvas.clear();
  // get the object for frame1 of the renderCanvas
  pushImageFromSaveCanvasToDrawingCanvas()
};

selectedCanvas2.onclick = function () {
  selectedCanvas = 1; 
  canvas.clear();
  // get the object for frame1 of the renderCanvas
  pushImageFromSaveCanvasToDrawingCanvas()
};

function pushImageFromSaveCanvasToDrawingCanvas(){
    const previewCanvasObjects = canvas3.getObjects();
    // remnove all objects with frame: frameNumber
    // that way there is only 1 image layer; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === selectedCanvas){
        const cloned = canvas3.clone(element);
        canvas.add(element.set({ left: 0, top: 0, height: 400,
        width: 400}))                    
      }
    })
}

function getCroppedImageFromCanvas(ToCanvas, frameNumber){
  var cropped = new Image();
    cropped.src = canvas3.toDataURL({
        left: 400,
        top: 0,
        width: 400,
        height: 400
    });
  fabric.Image.fromURL(preview, (img) =&gt; {      
    ToCanvas.add(img.set({ left: 0, top: 0, height: 400,
        width: 400}))
 },{ crossOrigin: 'anonymous' });
};


function pushCanvasToPreview(_canvas, frameNumber) {
  const previewCanvasObjects = canvas3.getObjects();
    //remnove all objects with frame: frameNumber
    // that way there is only 1 image layer; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === frameNumber){
        canvas3.remove(element);
      }
    })

  const leftOffset = frameNumber * 400

  const preview = _canvas.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview, (img) =&gt; {      
    canvas3.add(img.set({ left: leftOffset, top: 0, height: 400,
        width: 400, frame: frameNumber}))
 },{ crossOrigin: 'anonymous' }
);
  //show how many objects there are in canvas3
  const canvasObjects = canvas3.getObjects();
  console.log(canvasObjects)
  return preview;
}
</code></pre>
<p>Next step:<br />
make SaveCanvas invisible<br />
use it to make previews<br />
Load in imagebefore on the saveCanvas, then push a crop back to the drawCanvas</p>
<pre><code>var canvas = new fabric.Canvas(document.getElementById('canvasId'))
var clearCanvas = document.getElementById('clear-canvas'); // button
var selectedCanvas = 0;

var selectedCanvas1 = document.getElementById('selectCanvas1'); // button
var selectedCanvas2 = document.getElementById('selectCanvas2'); // button

var saveCanvas = new fabric.Canvas(document.getElementById('previewCanvas'))

canvas.isDrawingMode = true;
canvas.freeDrawingBrush.width = 5;
canvas.freeDrawingBrush.color = '#00aeff';

canvas.on('path:created', function(e) {
  e.path.set();
  canvas.renderAll();
  pushCanvasToPreview(canvas, selectedCanvas)
});

clearCanvas.onclick = function() { 
  canvas.clear(); 
  pushCanvasToPreview(canvas, selectedCanvas);
};

selectedCanvas1.onclick = function () {
  selectedCanvas = 0; 
  canvas.clear();
  // get the object for frame1 of the renderCanvas
  // pushImageFromSaveCanvasToDrawingCanvas()
  getCroppedImageFromCanvas(canvas, selectedCanvas)
};

selectedCanvas2.onclick = function () {
  selectedCanvas = 1; 
  canvas.clear();
  // get the object for frame1 of the renderCanvas
  // pushImageFromSaveCanvasToDrawingCanvas()
  getCroppedImageFromCanvas(canvas, selectedCanvas)
};

function pushImageFromSaveCanvasToDrawingCanvas(){
    const previewCanvasObjects = saveCanvas.getObjects();
    // remnove all objects with frame: frameNumber
    // that way there is only 1 image layer; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === selectedCanvas){
        const cloned = saveCanvas.clone(element);
        canvas.add(element.set({ left: 0, top: 0, height: 400,
        width: 400}))                    
      }
    })
}

function getCroppedImageFromCanvas(ToCanvas, frameNumber){
  const leftOffset = frameNumber * 400
  // var cropped = new Image();
  const cropped = saveCanvas.toDataURL({
        left: leftOffset,
        top: 0,
        width: 400,
        height: 400
    });
  fabric.Image.fromURL(cropped, (img) =&gt; {      
    ToCanvas.add(img.set({ left: 0, top: 0, height: 400,
        width: 400}))
 },{ crossOrigin: 'anonymous' });
};


function pushCanvasToPreview(_canvas, frameNumber) {
  const previewCanvasObjects = saveCanvas.getObjects();
    //remnove all objects with frame: frameNumber
    // that way there is only 1 image layer; the last one
    previewCanvasObjects.forEach((element) =&gt; {
      if (element.frame === frameNumber){
        saveCanvas.remove(element);
      }
    })

  const leftOffset = frameNumber * 400

  const preview = _canvas.toDataURL({
        format: 'png',
        height: 400,
        width: 400,
      });

   fabric.Image.fromURL(preview, (img) =&gt; {      
    saveCanvas.add(img.set({ left: leftOffset, top: 0, height: 400,
        width: 400, frame: frameNumber}))
 },{ crossOrigin: 'anonymous' }
);
  //show how many objects there are in canvas3
  const canvasObjects = saveCanvas.getObjects();
  console.log(canvasObjects)
  return preview;
}
</code></pre>
<p>HTML:</p>
<pre><code>&lt;canvas id=&quot;canvasId&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;
&lt;button id=&quot;clear-canvas&quot; class=&quot;btn btn-info&quot;&gt;Clear&lt;/button&gt;&lt;br&gt;
&lt;button id=&quot;selectCanvas1&quot; class=&quot;btn btn-info&quot;&gt;selectCanvas1&lt;/button&gt;&lt;br&gt;
&lt;button id=&quot;selectCanvas2&quot; class=&quot;btn btn-info&quot;&gt;selectCanvas2&lt;/button&gt;&lt;br&gt;

&lt;canvas hidden id=&quot;previewCanvas&quot; width=&quot;400&quot; height=&quot;400&quot; &gt;&lt;/canvas&gt;
</code></pre>
<p>This version works with cropping the SaveCanvas back to the DrawingCanvas: this should work with loaded images and the like;</p>
<hr />
<p>Konva was pretty slow, so not a good replacement.</p>
<p>So we switched to: SPAINTER a basic paixel based canvas drawing framework.</p>
<p><a href="https://github.com/akoidan/spainter">https://github.com/akoidan/spainter</a></p>
<p>Painterro is also an option:</p>
<p><a href="https://github.com/devforth/painterro">https://github.com/devforth/painterro</a></p>
<hr />
<p><img alt="" src="https://artworlddev.maartenvanderglas.com/wp-content/uploads/2022/12/Screenshot-from-2022-12-15-16-32-27.png" /></p>
<p>I fixed the "drawing over the border" bug by by adding a clipPath to each frame, and then clipping each stroke to that clipPath (sort of a mask). That worked, but fell apart when erasing.</p>
<p>The eraser also uses something like a clipPath, but it gets all wonky when erasing. The stack order doesn't make sense and the erase stroke is applied to other objects etc.</p>
<p>And when I would turn off the clipPath before erasing, the eraser would be able to erase in the adjacent frames.</p>
<p>I could try to implement eraser my self and see what is going on...</p>
<p>I looked into creating a mask and using it both for the eraser and for the frame.</p>
<p>But before trying that I tried another method: removing the points that are outside the frame after drawing. This works! But now also has to be implemented for the eraser. Because we are changing the paths after execution, we have to undo the erase and then do it again with the adjusted path.</p>
<p>let lineWidth = 25;<br />
let drawingColor = '#000000';<br />
let currentTab = null; make this pencil so we don't have to click twice in the beginning<br />
let applyBrush; where / for what is this used?<br />
let selectedBrush = 'Pencil';</p>
<hr />
<h2 id="alternative-ideas">Alternative ideas</h2>
<p>Wat als je een verse clippath maakt nadat de eraser bezig is geweest? Dus bij het selecteren van een brush</p>
<ul>
<li>
<ul>
<li>
<p>Dus: er is een clipPath en alles, er wordt geerased.</p>
</li>
<li>
<p>Er wordt weer getekend: de clipPath wordt weer vers aangemaakt</p>
<ul>
<li>en op alle lijnen weer toegepast?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Werkt niet, want: erasen over de clipPath, in het eerste frame wordt er sowieso een groot deel van de linkerbovenhoek af geknipt</p>
<p>Dus dan zou de clipPath eerst op null gezet moeten worden als er erased wordt...</p>
<hr />
<p>Andere methode: esare = bush en die deel uit laten maken van clipPath group: https://jsfiddle.net/almozdmr/yjmx6751/</p>
<hr />
<p>Deze mask methode? https://jsfiddle.net/Fidel90/md6rwg4b/</p>
<hr />
<p>This does not work:</p>
<pre><code>canvas.freeDrawingBrush.limitedToCanvasSize = true;
</code></pre>
<p>Because the canvas is spread across frames.</p>
<hr />
<p>Alternatief voor de erase tool?</p>
<p>//eraser</p>
<p>canvas.on('path:created', function (opt) {</p>
<p>opt.path.globalCompositeOperation = 'destination-out';</p>
<p>opt.path.lineWidth = strokeWidth;</p>
<p>opt.path.stroke = 'rgba(0,0,0,0)';</p>
<p>//opt.path.fill = 'black';</p>
<p>canvas.requestRenderAll();</p>
<p>});</p>
<p>//draw</p>
<p>canvas.on('path:created', function (opt) {</p>
<p>opt.path.globalCompositeOperation = 'source-over';</p>
<p>opt.path.lineWidth = strokeWidth;</p>
<p>opt.path.stroke = 'black';</p>
<p>//opt.path.fill = 'black';</p>
<p>canvas.requestRenderAll();</p>
<p>});</p>
<hr />
<p>Trying to implement the eraser as a special brush:</p>
<pre><code> // Set frameNumber on object, to refer to when deleting frames
    canvas.on('path:created', (e) =&gt; {
      const idx = canvas.getObjects().length - 1;
      const index = currentFrame - 1;

      // is e and the last item the same? - no; e is the path of the item
      console.log(&quot;canvas.item(idx), e&quot;, canvas.item(idx), e)
      const obj = e.path;
      canvas.item(idx).frameNumber = currentFrame;
      canvas.item(idx).eraser = 'false'

      if (currentTab === 'erase'){
        canvas.item(idx).eraser = 'true'
      //   // console.log(&quot;eraser: canvas.item(idx)&quot;, canvas.item(idx))
      //   const top = canvas.item(idx).top;
      //   const left = canvas.item(idx).left;

      //   // de eraser vernietigen en weer maken met meer properties
      //   canvas.remove(obj);
      //   const newObj = new fabric.Path(obj.path, {
      //   fill: '',
      //   top: top,
      //   left: left,
      //   absolutePositioned: true,
      //   stroke: 'white',
      //   strokeWidth: lineWidth,
      //   name: 'erase_clipPath',
      //   hasControls: false,
      //   hasBorders: false,
      //   objectCaching: false,
      //   // globalCompositionOperation: 'destination-out',
      //   controlsAboveOverlay: true,
      //   perPixelTargetFind: true,
      // });
      // canvas.add(newObj);

      // const allCanvasObjects = canvas.getObjects()
      // console.log(&quot;allCanvasObjects&quot;, allCanvasObjects)
      // allCanvasObjects.forEach((element) =&gt; {
      //     if (element.frameNumber === currentFrame &amp;&amp; element.eraser === 'false'){
      //       console.log(&quot;element&quot;, element)
      //       console.log(&quot;element.clipPath&quot;, element.clipPath)
      //       element.clipPath = null;
      //       element.clipPath = newObj;
      //     }
      //   })
      e.path.globalCompositionOperation = 'destination-out';
      canvas.remove(canvas.item(idx));

      const newObj = new fabric.Path(obj.path, {
        fill: '',
        // top: top,
        // left: left,
        // absolutePositioned: true,
        stroke: 'white',
        strokeWidth: lineWidth,
        name: 'erase_clipPath',
        hasControls: false,
        hasBorders: false,
        objectCaching: false,
        globalCompositionOperation: 'destination-out',
        controlsAboveOverlay: true,
        perPixelTargetFind: true,
      });
      canvas.add(newObj);

      } else if (currentTab ==='draw'){
        // clip the path with the canvasClipper so as to not draw into the next frame
        canvas.item(idx).clipPath = canvasClipperArray[index];
        console.log(&quot;canvas.item(idx).clipPath&quot;, canvas.item(idx).clipPath)
      }



      // start fix for drawing over the edge
      // const obj = e.path;
      // console.log(&quot;obj&quot;, obj);
      // console.log(&quot;selectedBrush&quot;, selectedBrush)
      // // different burshes have different line types
      // let points
      // if (selectedBrush === 'Pencil' || selectedBrush === 'Pattern'){
      //   points = [...obj.path];
      // } else if (selectedBrush === 'Circle' || selectedBrush === 'Spray'){
      //   points = [...obj.lineCoords];
      // }

      // for (let i = 0; i &lt; points.length; i++) {
      //   const element = points[i];

      //   if (
      //     element[1] &lt; baseSize * (currentFrame - 1) ||
      //     element[2] &lt; 0 ||
      //     element[1] &gt; baseSize * currentFrame ||
      //     element[2] &gt; baseSize
      //   ) {
      //     console.log('points[i]', points[i]);
      //     points.splice(i, 1);
      //   }

      //   if (
      //     obj.left &lt; baseSize * (currentFrame - 1) ||
      //       obj.top &lt; 0 ||
      //       obj.left + obj.width &gt; baseSize * currentFrame ||
      //       obj.top + obj.height &gt; baseSize
      //   ) {
      //   // clip borders
      //     console.log('outside of acceptable borders');
      //     for (let i = 0; i &lt; points.length; i++) {
      //       const element = points[i];
      //       if (
      //       element[1] &lt; baseSize * (currentFrame - 1) ||
      //       element[2] &lt; 0 ||
      //       element[1] &gt; baseSize * currentFrame ||
      //       element[2] &gt; baseSize
      //       ) {
      //         console.log('points[i]', points[i]);
      //         points.splice(i, 1);
      //       }
      //     }
      //   // update value if &gt; or &lt; then border, ajust value to border value ( -line width)
      //   }
      // }
      // obj.set({ path: points });
      // obj.setCoords();
      // const modObj = obj;

      // // console.log('after', obj.path.length);
      // // console.log('obj', obj);
      // // console.log('obj.path', obj.path);
      // canvas.remove(obj);

      // const newObj = new fabric.Path(modObj.path, {
      //   fill: '',
      //   stroke: drawingColor,
      //   strokeWidth: lineWidth,
      //   name: 'line',
      //   hasControls: false,
      //   hasBorders: false,
      //   objectCaching: false,
      // });
      // canvas.add(newObj);


    });
</code></pre>
<hr />
<p>- perPixelTargetFind: true ?</p>
<hr />
<p>An other framework that has an eraser implemented: KONVA</p>
<p><a href="https://konvajs.org/docs/index.html">https://konvajs.org/docs/index.html</a></p>
<p>Free drawing with erase: <a href="https://konvajs.org/docs/sandbox/Free_Drawing.html">https://konvajs.org/docs/sandbox/Free_Drawing.html</a></p>
<p>undo /redo : <a href="https://codesandbox.io/s/0o9xmkno0">https://codesandbox.io/s/0o9xmkno0</a>  </p>
<p>Transparent layers/ groups: <a href="https://konvajs.org/docs/sandbox/Transparent_Group.html">https://konvajs.org/docs/sandbox/Transparent_Group.html</a></p>
<p>Zooming the stage</p>
<p>https://longviewcoder.com/2021/07/12/konva-zooming-the-stage-under-the-mouse/</p>
<p><a href="https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html">https://konvajs.org/docs/sandbox/Zooming_Relative_To_Pointer.html</a></p>
<p><a href="https://konvajs.org/docs/sandbox/Responsive_Canvas.html">https://konvajs.org/docs/sandbox/Responsive_Canvas.html</a></p>
<hr />
<h2 id="flood-fill-and-line-tool-for-html-canvas-also-color-picker">Flood Fill and Line Tool for HTML Canvas (also color picker)</h2>
<p><a href="https://cantwell-tom.medium.com/flood-fill-and-line-tool-for-html-canvas-65e08e31aec6">https://cantwell-tom.medium.com/flood-fill-and-line-tool-for-html-canvas-65e08e31aec6</a></p>
<hr />
<p>https://ben.akrin.com/an-html5-canvas-flood-fill-that-doesnt-kill-the-browser/</p>
<hr />
<p><a href="http://www.williammalone.com/projects/html5-canvas-javascript-drawing-app-with-bucket-tool/">http://www.williammalone.com/projects/html5-canvas-javascript-drawing-app-with-bucket-tool/</a></p>
<hr />
<h2 id="color-picker-in-svelte">Color picker in svelte</h2>
<p><a href="https://www.npmjs.com/package/svelte-awesome-color-picker">https://www.npmjs.com/package/svelte-awesome-color-picker</a></p>
<p><a href="https://svelte.dev/repl/8b00804d417b4fe89f42f90d6ed485e7?version=3.47.0">https://svelte.dev/repl/8b00804d417b4fe89f42f90d6ed485e7?version=3.47.0</a></p>
<hr />
<p>Chips oude implementatie van de stopmotion/ drawing app:</p>
<p>git checkout 4d3f4a6be6e1659aa6175415e530fafb6fc9c5d4</p>
<pre><code>&lt;script&gt;
  import { fabric } from &quot;./fabric&quot;;
  import { location, replace } from &quot;svelte-spa-router&quot;;
  import { onMount, beforeUpdate, onDestroy } from &quot;svelte&quot;;
  import {
    uploadImage,
    user,
    uploadAvatar,
    uploadHouse,
    getObject,
    setLoader,
    convertImage,
    updateObject,
  } from &quot;../../api.js&quot;;
  import { client } from &quot;../../nakama.svelte&quot;;
  import { Session, Profile, tutorial } from &quot;../../session.js&quot;;
  import { Achievements } from &quot;../../storage&quot;;
  import NameGenerator from &quot;../components/nameGenerator.svelte&quot;;
  import MouseIcon from &quot;svelte-icons/fa/FaMousePointer.svelte&quot;;
  import Avatar from &quot;../components/avatar.svelte&quot;;
  import ManageSession from &quot;../game/ManageSession&quot;;

  let scaleRatio, lastImg, lastValue, lastWidth;
  let params = { user: $location.split(&quot;/&quot;)[2], name: $location.split(&quot;/&quot;)[3] };
  let invalidTitle = true;
  let history = [],
    historyCurrent;
  let canv, _clipboard, Cursor, cursor, drawingColorEl;
  let saveCanvas, savecanvas, videoCanvas;
  // saving = false;
  let videoWidth;
  let canvas,
    video,
    lineWidth = 25;
  let json,
    drawingColor = &quot;#000000&quot;;
  let shadowOffset = 0,
    shadowColor = &quot;#ffffff&quot;,
    shadowWidth = 0;
  let title,
    answer,
    showBackground = true;
  let fillColor = &quot;#f00&quot;,
    fillTolerance = 2;
  let current = &quot;draw&quot;;
  if (!!params.name) title = params.name;
  let saved = false,
    saveToggle = false,
    savedURL = &quot;&quot;,
    colorToggle = true;
  // const statussen = [true, false];
  export let appType = $location.split(&quot;/&quot;)[1];
  let version = 0;
  let optionbox = true;

  let status = true;
  let displayName;
  let isDrawn = false;
  let isPreexistingArt = false;
  let isAlreadyUploaded = false;
  let isTitleChanged = false;

  let applyBrush; // declaring the variable to be available globally, onMount assinging a function to it
  let selectedBrush = &quot;Pencil&quot;; // by default the Pencil is chosen

  let Object = {};

  let FrameObject = {
    type: &quot;image&quot;,
    version: &quot;4.6.0&quot;,
    originX: &quot;left&quot;,
    originY: &quot;top&quot;,
    left: -1024,
    top: 0,
    width: 0,
    height: 1024,
    fill: &quot;rgb(0,0,0)&quot;,
    stroke: null,
    strokeWidth: 0,
    strokeDashArray: null,
    strokeLineCap: &quot;butt&quot;,
    strokeDashOffset: 0,
    strokeLineJoin: &quot;miter&quot;,
    strokeUniform: false,
    strokeMiterLimit: 4,
    scaleX: 1,
    scaleY: 1,
    angle: 0,
    flipX: false,
    flipY: false,
    opacity: 1,
    shadow: null,
    visible: true,
    backgroundColor: &quot;&quot;,
    fillRule: &quot;nonzero&quot;,
    paintFirst: &quot;fill&quot;,
    globalCompositeOperation: &quot;source-over&quot;,
    skewX: 0,
    skewY: 0,
    erasable: true,
    cropX: 0,
    cropY: 0,
    src: &quot;&quot;,
    crossOrigin: &quot;anonymous&quot;,
    filters: [],
  };

  var fab = function (id) {
    return document.getElementById(id);
  };

  function adaptCanvasSize() {
    // the canvas size is set by the least of two (width / height)
    const canvasSize =
      window.innerWidth &gt; window.innerHeight
        ? window.innerHeight
        : window.innerWidth;

    // setting default width and height
    canvas.setWidth(canvasSize);
    canvas.setHeight(canvasSize);
    cursor.setWidth(canvasSize);
    cursor.setHeight(canvasSize);

    const canvasReductionAmount = 200;

    // for medium screens
    if (canvasSize &lt; 1008 &amp;&amp; canvasSize &gt; 640) {
      canvas.setWidth(canvasSize - canvasReductionAmount);
      canvas.setHeight(canvasSize - canvasReductionAmount);
      cursor.setWidth(canvasSize - canvasReductionAmount);
      cursor.setHeight(canvasSize - canvasReductionAmount);
    }

    // for mobile screens
    if (canvasSize &lt;= 640) {
      canvas.setWidth(canvasSize - canvasReductionAmount * 0, 55);
      canvas.setHeight(canvasSize - canvasReductionAmount * 0, 55);
      cursor.setWidth(canvasSize - canvasReductionAmount * 0, 55);
      cursor.setHeight(canvasSize - canvasReductionAmount * 0, 55);
    }

    // for mobile screens
    if (canvasSize &lt;= 540) {
      canvas.setWidth(canvasSize - canvasReductionAmount * 0, 4);
      canvas.setHeight(canvasSize - canvasReductionAmount * 0, 4);
      cursor.setWidth(canvasSize - canvasReductionAmount * 0, 4);
      cursor.setHeight(canvasSize - canvasReductionAmount * 0, 4);
    }

    // for correct and adapted scaling of the preexisting artworks
    scaleRatio = Math.min(canvas.width / 1024, canvas.width / 1024);
    cursor.setZoom(scaleRatio);
    canvas.setZoom(scaleRatio);
  }

  onMount(() =&gt; {
    setLoader(true);
    const autosave = setInterval(() =&gt; {
      if (!saved) {
        let data = {};
        data.type = appType;
        data.name = title;
        if (appType == &quot;drawing&quot; || appType == &quot;house&quot;) {
          data.drawing = canvas.toDataURL(&quot;image/png&quot;, 1);
        }

        localStorage.setItem(&quot;Drawing&quot;, JSON.stringify(data));
        console.log(&quot;stored in localstorage&quot;);
      }
    }, 20000);
    cursor = new fabric.StaticCanvas(Cursor);
    canvas = new fabric.Canvas(canv, {
      isDrawingMode: true,
    });

    // always adapting the canvas size on screen size change
    window.onresize = () =&gt; {
      adaptCanvasSize();
    };

    MouseIcon;
    savecanvas = new fabric.Canvas(saveCanvas, {
      isDrawingMode: true,
    });

    getImage();
    setLoader(false);

    fabric.Object.prototype.transparentCorners = false;

    var drawingModeEl = fab(&quot;drawing-mode&quot;),
      selectModeEl = fab(&quot;select-mode&quot;),
      //fillModeEl = fab(&quot;fill-mode&quot;),
      drawingOptionsEl = fab(&quot;drawing-mode-options&quot;),
      eraseModeEl = fab(&quot;erase-mode&quot;),
      drawingColorEl = fab(&quot;drawing-color&quot;),
      //drawingShadowColorEl = fab(&quot;drawing-shadow-color&quot;),
      drawingLineWidthEl = fab(&quot;drawing-line-width&quot;),
      //drawingShadowWidth = fab(&quot;drawing-shadow-width&quot;),
      //drawingShadowOffset = fab(&quot;drawing-shadow-offset&quot;);
      clearEl = fab(&quot;clear-canvas&quot;);

    clearEl.onclick = function () {
      // if anything is drawn on the canvas and it has not been uploaded,
      // save the artwork and clear the canvas
      if (isDrawn &amp;&amp; !isAlreadyUploaded) {
        upload();
        isDrawn = false;
      }
      canvas.clear();
      localStorage.setItem(&quot;Drawing&quot;, &quot;&quot;);
    };

    drawingModeEl.onclick = function () {
      // console.log(&quot;mouse is down&quot;);
      switchOption(&quot;draw&quot;);
      canvas.isDrawingMode = true;
      console.log(drawingColor);
      floodFill(false);
    };

    selectModeEl.onclick = function () {
      canvas.isDrawingMode = false;
      switchOption(&quot;select&quot;);
      floodFill(false);
    };

    // fillModeEl.onclick = function () {
    //   current = &quot;fill&quot;;
    //   floodFill(true);
    // };

    eraseModeEl.onclick = function () {
      // erase functie kapot? recompile: http://fabricjs.com/build/
      var eraseBrush = new fabric.EraserBrush(canvas);
      canvas.freeDrawingBrush = eraseBrush;
      canvas.freeDrawingBrush.width =
        parseInt(drawingLineWidthEl.value, 10) || 1;
      canvas.isDrawingMode = true;
      switchOption(&quot;erase&quot;);
      floodFill(false);
    };

    if (fabric.PatternBrush) {
      var vLinePatternBrush = new fabric.PatternBrush(canvas);
      vLinePatternBrush.getPatternSrc = function () {
        var patternCanvas = fabric.document.createElement(&quot;canvas&quot;);
        patternCanvas.width = patternCanvas.height = 10;
        var ctx = patternCanvas.getContext(&quot;2d&quot;);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.lineTo(10, 5);
        ctx.closePath();
        ctx.stroke();

        return patternCanvas;
      };

      var hLinePatternBrush = new fabric.PatternBrush(canvas);
      hLinePatternBrush.getPatternSrc = function () {
        var patternCanvas = fabric.document.createElement(&quot;canvas&quot;);
        patternCanvas.width = patternCanvas.height = 10;
        var ctx = patternCanvas.getContext(&quot;2d&quot;);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(5, 0);
        ctx.lineTo(5, 10);
        ctx.closePath();
        ctx.stroke();

        return patternCanvas;
      };

      var squarePatternBrush = new fabric.PatternBrush(canvas);
      squarePatternBrush.getPatternSrc = function () {
        var squareWidth = 10,
          squareDistance = 2;

        var patternCanvas = fabric.document.createElement(&quot;canvas&quot;);
        patternCanvas.width = patternCanvas.height =
          squareWidth + squareDistance;
        var ctx = patternCanvas.getContext(&quot;2d&quot;);

        ctx.fillStyle = this.color;
        ctx.fillRect(0, 0, squareWidth, squareWidth);

        return patternCanvas;
      };

      var diamondPatternBrush = new fabric.PatternBrush(canvas);
      diamondPatternBrush.getPatternSrc = function () {
        var squareWidth = 10,
          squareDistance = 5;
        var patternCanvas = fabric.document.createElement(&quot;canvas&quot;);
        var rect = new fabric.Rect({
          width: squareWidth,
          height: squareWidth,
          angle: 45,
          fill: this.color,
        });

        var canvasWidth = rect.getBoundingRect().width;

        patternCanvas.width = patternCanvas.height =
          canvasWidth + squareDistance;
        rect.set({ left: canvasWidth / 2, top: canvasWidth / 2 });

        var ctx = patternCanvas.getContext(&quot;2d&quot;);
        rect.render(ctx);

        return patternCanvas;
      };
    }

    // fab(&quot;drawing-mode-selector&quot;).onchange = () =&gt; changebrush();

    // function changebrush() {
    //   brush = fab(&quot;drawing-mode-selector&quot;);
    //   console.log(brush);
    //   if (brush.value === &quot;hline&quot;) {
    //     canvas.freeDrawingBrush = vLinePatternBrush;
    //   } else if (brush.value === &quot;vline&quot;) {
    //     canvas.freeDrawingBrush = hLinePatternBrush;
    //   } else if (brush.value === &quot;square&quot;) {
    //     canvas.freeDrawingBrush = squarePatternBrush;
    //   } else if (brush.value === &quot;diamond&quot;) {
    //     canvas.freeDrawingBrush = diamondPatternBrush;
    //   } else if (brush.value === &quot;texture&quot;) {
    //     canvas.freeDrawingBrush = texturePatternBrush;
    //   } else {
    //     canvas.freeDrawingBrush = new fabric[brush.value + &quot;Brush&quot;](canvas);

    //   }

    //   if (canvas.freeDrawingBrush) {
    //     var brush = canvas.freeDrawingBrush;
    //     brush.color = drawingColorEl.value;
    //     if (brush.getPatternSrc) {
    //       brush.source = brush.getPatternSrc.call(brush);
    //     }
    //     brush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
    //     // brush.shadow = new fabric.Shadow({
    //     //   blur: parseInt(drawingShadowWidth.value, 10) || 0,
    //     //   offsetX: 0,
    //     //   offsetY: 0,
    //     //   affectStroke: true,
    //     //   color: drawingShadowColorEl.value,
    //     // });
    //   }
    // }

    drawingColorEl.onchange = function () {
      var brush = canvas.freeDrawingBrush;
      brush.color = this.value;
      if (brush.getPatternSrc) {
        brush.source = brush.getPatternSrc.call(brush);
      }
    };
    // drawingShadowColorEl.onchange = function () {
    //   canvas.freeDrawingBrush.shadow.color = this.value;
    // };
    drawingLineWidthEl.onchange = function () {
      canvas.freeDrawingBrush.width = parseInt(this.value, 10) || 1;
      this.previousSibling.innerHTML = this.value;
    };


    if (canvas.freeDrawingBrush) {
      canvas.freeDrawingBrush.color = drawingColorEl.value;
      // canvas.freeDrawingBrush.source = canvas.freeDrawingBrush.getPatternSrc.call(this);
      canvas.freeDrawingBrush.width =
        parseInt(drawingLineWidthEl.value, 10) || 1;
      // canvas.freeDrawingBrush.shadow = new fabric.Shadow({
      //   blur: parseInt(drawingShadowWidth.value, 10) || 0,
      //   offsetX: 0,
      //   offsetY: 0,
      //   affectStroke: true,
      //   color: drawingShadowColorEl.value,
      // });
    }
    console.log(params);

    canvas.on(&quot;mouse:up&quot;, function () {
      // once there is anything is drawn on the canvas
      isDrawn = true;
      isPreexistingArt = false;
      isAlreadyUploaded = false;
      mouseEvent();
    });

    //////////////// mouse circle ////////////////////////////

    //mouse cursor layer

    var cursorOpacity = 0.5;
    //create cursor and place it off screen
    var mousecursor = new fabric.Circle({
      left: -100,
      top: -100,
      radius: canvas.freeDrawingBrush.width / 2,
      fill: &quot;rgba(0,0,0,&quot; + cursorOpacity + &quot;)&quot;,
      stroke: &quot;black&quot;,
      originX: &quot;center&quot;,
      originY: &quot;center&quot;,
    });

    cursor.add(mousecursor);

    //redraw cursor on new mouse position when moved
    canvas.on(&quot;mouse:move&quot;, function (evt) {
      if (current == &quot;select&quot;)
        return mousecursor
          .set({ top: -100, left: -100 })
          .setCoords()
          .canvas.renderAll();
      var mouse = this.getPointer(evt.e);
      mousecursor
        .set({
          top: mouse.y,
          left: mouse.x,
        })
        .setCoords()
        .canvas.renderAll();
    });

    //while brush size is changed show cursor in center of canvas
    document.getElementById(&quot;drawing-line-width&quot;).oninput = () =&gt; {
      changeBrushSize();
    };
    document.getElementById(&quot;erase-line-width&quot;).oninput = () =&gt; {
      changeBrushSize();
    };

    function changeBrushSize() {
      var size = parseInt(lineWidth, 10);
      canvas.freeDrawingBrush.width = size;
      mousecursor
        // .center()
        .set({
          radius: size / 2,
          top: 500,
          left: 1300,
        })
        .setCoords()
        .canvas.renderAll();
    }

    //change drawing color
    drawingColorEl.onchange = function () {
      console.log(&quot;color&quot;);
      canvas.freeDrawingBrush.color = this.value;
      var bigint = parseInt(this.value.replace(&quot;#&quot;, &quot;&quot;), 16);
      var r = (bigint &gt;&gt; 16) &amp; 255;
      var g = (bigint &gt;&gt; 8) &amp; 255;
      var b = bigint &amp; 255;
      //  mousecursor.fill = &quot;rgba(&quot; + [r,g,b,cursorOpacity].join(&quot;,&quot;) + &quot;)&quot;

      mousecursor
        .set({
          fill: &quot;rgba(&quot; + [r, g, b, cursorOpacity].join(&quot;,&quot;) + &quot;)&quot;,
        })
        .canvas.renderAll();
    };

    //////////////// mouse circle ////////////////////////////

    //////////////// drawing challenge ////////////////////////
    if (appType == &quot;drawingchallenge&quot;) {
      // each mouse-up event sends the drawing
      canvas.on(&quot;mouse:up&quot;, () =&gt; {
        // get the drawing from the canvas in the format of SVG
        const canvasData = canvas.toSVG();

        // convert SVG into the HTML format in order to be able to manipulate inner data
        const parsedSVG = new DOMParser().parseFromString(
          canvasData,
          &quot;text/html&quot;
        );

        // all &lt;g&gt; tags contain drawing action
        const gTagElement = parsedSVG.getElementsByTagName(&quot;g&quot;);

        // loop through &lt;g&gt; tags, remove all previous drawings and leave only the last one
        for (let i = gTagElement.length - 2; i &gt;= 0; --i) {
          gTagElement[i].remove();
        }

        // get the position of the drawing
        const positionObject = canvas.toJSON().objects;

        // needed SVG is stored inside of body which we want to send only
        const body = parsedSVG.getElementsByTagName(&quot;BODY&quot;)[0].innerHTML;

        // all data to send
        const location = &quot;drawingchallenge&quot;;
        const JSONToSend = `{ &quot;action&quot;: ${JSON.stringify(
          body
        )}, &quot;location&quot;: &quot;${location}&quot;, &quot;posX&quot;: ${
          positionObject[positionObject.length - 1].left
        }, &quot;posY&quot;: ${positionObject[positionObject.length - 1].top}}`;

        // send data
        ManageSession.socket.rpc(&quot;move_position&quot;, JSONToSend);
      });

      // listening to the stream to get actions of other person's drawing
      ManageSession.socket.onstreamdata = (streamdata) =&gt; {
        let data = JSON.parse(streamdata.data);

        if ($Session.user_id != data.user_id) {
          // apply drawings to the canvas if only it is received from other participant
          fabric.loadSVGFromString(data.action, function (objects) {
            objects.forEach(function (svg) {
              console.log(&quot;svg&quot;, svg);
              svg.set({
                scaleX: 1,
                scaleY: 1,
                left: data.posX,
                top: data.posY,
              });
              canvas.add(svg).renderAll();
            });
          });
        } else {
          console.log(&quot;The same user!&quot;);
        }
      };
    }
    //////////////// drawing challenge ////////////////////////

    adaptCanvasSize();

    applyBrush = (brushType) =&gt; {
      if (typeof brushType == &quot;string&quot;) selectedBrush = brushType;
      canvas.freeDrawingBrush = new fabric[selectedBrush + &quot;Brush&quot;](canvas);
      if (canvas.freeDrawingBrush) {
        var brush = canvas.freeDrawingBrush;
        brush.color = drawingColorEl.value;
        if (brush.getPatternSrc) {
          brush.source = brush.getPatternSrc.call(brush);
        }
        brush.width = parseInt(drawingLineWidthEl.value, 10) || 1;
      }
    };
  });
  /////////////////// end onMount ///////////////////////

  // to change visible/hidden status of the artwork
  const changeVisibility = async () =&gt; {
    setLoader(true);
    status = !status;
    if (isPreexistingArt) {
      // we update the name of the preexisting artwork
      await updateObject(Object.collection, Object.key, Object.value, status);
    }
    setLoader(false);
  };

  const upload = async () =&gt; {
    if (!invalidTitle) return;

    // we upload the artwork if either something added to the art itself or when it is title changed
    if (isDrawn || isTitleChanged) {
      version = version + 1; // with every new update of the artwork, it is version gets +1

      setLoader(true);
      if (appType == &quot;drawing&quot;) {
        var Image = canvas.toDataURL(&quot;image/png&quot;, 1);
        var blobData = dataURItoBlob(Image);
        if (!!!title) {
          title = Date.now() + &quot;_&quot; + displayName;
        }
        // replace(`${$location}/${$Session.user_id}/${displayName}`);
        await uploadImage(
          title,
          appType,
          blobData,
          status,
          version,
          displayName
        ).then((url) =&gt; {
          // in every appType we assign url to the savedURL variable, it is needed for downloading
          // by default savedURL equals &quot;&quot;
          savedURL = url;
          setLoader(false);
        });
      }
      if (appType == &quot;house&quot;) {
        var Image = canvas.toDataURL(&quot;image/png&quot;, 1);
        var blobData = dataURItoBlob(Image);
        await uploadHouse(blobData).then((response) =&gt; {
          savedURL = response;
        });
        setLoader(false);
      }
      if (appType == &quot;stopmotion&quot;) {
        await createStopmotion();
        setLoader(false);
      }
      if (appType == &quot;avatar&quot;) {
        createAvatar().then((resp) =&gt; {
          setLoader(false);
        });
      }
      isAlreadyUploaded = true; // once it is uploaded, we don't have to upload it again on the close button click
      isTitleChanged = false;
    }
  };

  onDestroy(() =&gt; {
    // upload the artwork on the close button click,
    // if it is not uploaded yet or if the title has been changed
    if (!isAlreadyUploaded || isTitleChanged) {
      upload();
    }
  });

  async function download() {
    // check first if we are dealing with preexisting artwork
    // if it is the case, simply download from the url of the artwork on the addressbar
    if (isPreexistingArt) {
      if (!savedURL) {
        let url = lastImg;
        window.location = url;
        return; // don't proceed
      }
    }

    // start the process of downloading, only if something is drawn on the canvas
    if (isDrawn) {
      // if the user missed clicking the save button (upload function), then upload it first
      if (!isAlreadyUploaded) {
        await upload();
      }
      if (appType == &quot;stopmotion&quot;) {
        // the stopmotion function is not awaiting properly, a further investigation is needed (!)
        // once fixed, there is no need to use setTimeout
        setTimeout(async () =&gt; {
          const url = await convertImage(savedURL);
          window.location = url;
        }, 4500);
      } else {
        // for the rest of appTypes no need to set Timeout
        const url = await convertImage(savedURL);
        window.location = url;
      }
    }
  }

  const updateFrame = () =&gt; {
    frames[currentFrame] = canvas.toJSON();
    console.log(&quot;currentFrame&quot;, currentFrame)
    frames = frames;

    backgroundFrames[currentFrame] = canvas.toDataURL(&quot;image/png&quot;, 1);
    backgroundFrames = backgroundFrames;
  };

  const getImage = async () =&gt; {
    let localStore = JSON.parse(localStorage.getItem(&quot;Drawing&quot;));
    if (!!localStore) {
      console.log(localStore);
      console.log(&quot;store &quot; + localStore.name);
      console.log(&quot;param &quot; + params.name);
      if (localStore.name == params.name &amp;&amp; typeof params.name != &quot;undefined&quot;) {
        console.log(localStore.type);
        // isDrawn = true;
        // console.log(&quot;localstorage isDrawn&quot;, isDrawn);
        if (localStore.type == &quot;drawing&quot;) {
          console.log(&quot;test&quot;);
          // canvas.loadFromJSON(
          //   localStore.drawing,
          //   canvas.renderAll.bind(canvas)
          // );
          fabric.Image.fromURL(
            localStore.drawing,
            function (oImg) {
              oImg.set({ left: 0, top: 0 });
              oImg.scaleToHeight(1024);
              oImg.scaleToWidth(1024);
              canvas.add(oImg);
            },
            { crossOrigin: &quot;anonymous&quot; }
          );
        }

        //     if (localStore.type == &quot;stopmotion&quot;) {
        //       frames = localStore.frames;
        //       canvas.loadFromJSON(
        //         localStore.frames[0],
        //         canvas.renderAll.bind(canvas)
        //       );
        //     }
      }
    }

    if (!!!params.name &amp;&amp; (appType == &quot;stopmotion&quot; || appType == &quot;drawing&quot;))
      return setLoader(false);
    console.log(&quot;appType&quot;, appType);
    // get images
    if (appType == &quot;avatar&quot;) {
      lastImg = await convertImage($Profile.avatar_url, &quot;1024&quot;, &quot;10000&quot;);
      isPreexistingArt = true;
    } else if (appType == &quot;house&quot;) {
      let Object = await getObject(&quot;home&quot;, $Profile.meta.Azc, $Profile.user_id);
      lastImg = await convertImage(Object.value.url, &quot;1024&quot;, &quot;1024&quot;);
      lastValue = Object.value;
      title = Object.key;
      status = Object.permission_read == 2 ? true : false;
      isPreexistingArt = true;
    } else {
      Object = await getObject(appType, params.name, params.user);
      console.log(&quot;object&quot;, Object);
      displayName = Object.value.displayname;
      title = Object.key;
      status = Object.permission_read == 2 ? true : false;
      console.log(&quot;status in getImage&quot;, status);
      version = Object.value.version;
      console.log(&quot;displayName&quot;, displayName);
      lastImg = await convertImage(Object.value.url);
      isPreexistingArt = true;
    }
    // put images on canvas
    if (appType == &quot;avatar&quot; || appType == &quot;stopmotion&quot;) {
      console.log(&quot;avatar&quot;);
      let frameAmount;
      var framebuffer = new Image();
      framebuffer.src = lastImg;
      framebuffer.onload = function () {
        console.log(&quot;img&quot;, this.width);
        lastWidth = this.width;
        frameAmount = lastWidth / 1024;

        FrameObject.src = lastImg;
        FrameObject.width = lastWidth;
        frames = [];
        for (let i = 0; i &lt; frameAmount; i++) {
          FrameObject.left = 0;
          FrameObject.width = 1024;
          FrameObject.cropX = i * 1024;
          // FrameObject.clipTo = function (ctx) {
          //   // origin is the center of the image
          //   // var x = rectangle.left - image.getWidth() / 2;
          //   // var y = rectangle.top - image.getHeight() / 2;
          //   // ctx.rect(i * -1024, 1024, (i * -1024)+1024, 1024);
          //   ctx.rect(0,-1024,1024,1024)
          // };
          // FrameObject.setCoords();
          frames.push({
            version: &quot;4.6.0&quot;,
            objects: [{ ...FrameObject }],
          });
        }
        frames = frames;
        console.log(&quot;frames&quot;, frames);
        currentFrame = 0;
        canvas.loadFromJSON(frames[0], function () {
          canvas.renderAll.bind(canvas);});
      };
    }
    if (appType == &quot;drawing&quot; || appType == &quot;house&quot;) {
      fabric.Image.fromURL(
        lastImg,
        function (oImg) {
          oImg.set({ left: 0, top: 0 });
          oImg.scaleToHeight(1024);
          oImg.scaleToWidth(1024);
          canvas.add(oImg);
        },
        { crossOrigin: &quot;anonymous&quot; }
      );
    }

    if (!!!params.user) {
      console.log(window.location.pathname);
      replace(&quot;/&quot; + appType + &quot;/&quot; + $Session.user_id + &quot;/&quot; + displayName);
    }

    setLoader(false);
  };

  function dataURItoBlob(dataURI) {
    var binary = atob(dataURI.split(&quot;,&quot;)[1]);
    var array = [];
    for (var i = 0; i &lt; binary.length; i++) {
      array.push(binary.charCodeAt(i));
    }
    return new Blob([new Uint8Array(array)], { type: &quot;image/png&quot; });
  }

  async function getDataUrl(img) {
    //  // Set width and height
    //  savecanvas.width = img.width;
    //  savecanvas.height = img.height;
    //  // Draw the image
    //  savecanvas.drawImage(img, 0, 0);
    //  return savecanvas.toDataURL('image/jpeg');

    // Create canvas
    let image;
    console.log(&quot;img&quot;, img);
    await fabric.Image.fromURL(img, function (oImg) {
      oImg.set({ left: 0, top: 0 });
      oImg.scaleToHeight(1024);
      oImg.scaleToWidth(1024);
      console.log(oImg);
      console.log(canvas);
      savecanvas.add(oImg);
    });
    image = savecanvas.toDataURL(&quot;image/png&quot;, 1);
    return image;
  }

  function mouseEvent() {
    setTimeout(() =&gt; {
      updateFrame();
      saveHistory();
    }, 200);
  }

  function zoomIt(factor) {
    // canvas.setHeight(canvas.getHeight() * factor);
    // canvas.setWidth(canvas.getWidth() * factor);
    if (canvas.backgroundImage) {
      // Need to scale background images as well
      var bi = canvas.backgroundImage;
      bi.width = bi.width * factor;
      bi.height = bi.height * factor;
    }
    var objects = canvas.getObjects();
    for (var i in objects) {
      var scaleX = objects[i].scaleX;
      var scaleY = objects[i].scaleY;
      var left = objects[i].left;
      var top = objects[i].top;

      var tempScaleX = scaleX * factor;
      var tempScaleY = scaleY * factor;
      var tempLeft = left * factor;
      var tempTop = top * factor;

      objects[i].scaleX = tempScaleX;
      objects[i].scaleY = tempScaleY;
      objects[i].left = tempLeft;
      objects[i].top = tempTop;

      objects[i].setCoords();
    }
    canvas.renderAll();
    canvas.calcOffset();
  }

  ////////////////////////// stop motion functie ////////////////////////////////////////

  let frames = [{}];
  let backgroundFrames = [{}];
  let maxFrames = 100;
  let currentFrame = 0;
  let play = false;

  // Create a new instance of the Image class
  var img = new Image();

  // When the image loads, set it as background image
  if (showBackground) {
    img.onload = function () {
      var f_img = new fabric.Image(img);
      let options;
      let scale = 1024 / canvas.height;
      if (canvas.width &lt;= canvas.height) {
        scale = 1024 / canvas.width;
      }
      if (!play)
        options = {
          opacity: 0.5,
          width: 1024,
          height: 1024,
          scaleX: scale,
          scaleY: scale,
        };
      else options = {};
      canvas.setBackgroundImage(f_img, canvas.renderAll.bind(canvas), options);

      canvas.renderAll();
    };
  }

  const changeFrame = (newFrame) =&gt; {
    console.log(&quot;newFrame&quot;, newFrame);
    if (!play) {
      console.log(frames);
      // save frame
      // put as background of button
      canvas.clear();
      // load frame
      canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas));
      if (showBackground) img.src = backgroundFrames[newFrame - 1];

      // change current frame
      currentFrame = newFrame;
      frames[newFrame].backgroundImage;
    }
    if (play || !showBackground) {
      canvas.clear();

      frames[newFrame].backgroundImage = {};
      canvas.loadFromJSON(frames[newFrame], canvas.renderAll.bind(canvas));
    }
  };

  const deleteFrame = (Frame) =&gt; {
    console.log(&quot;Frame&quot;, Frame);
    for (var i = 0; i &lt; frames.length; i++) {
      console.log(&quot;frames[i], Frame&quot;, frames[i], Frame);
      if (i == Frame) {
        console.log(&quot;i&quot;, i);

        if (i &gt; 0) {
          frames.splice(i, 1);
          currentFrame = i - 1;
          frames[currentFrame].backgroundImage = {};
          changeFrame(currentFrame);
        } else {
          frames.shift();
          frames[0].backgroundImage = {};
          currentFrame = 0;
          changeFrame(0);
        }
      }
    }
  };

  async function addFrame() {
    await updateFrame();
    if (frames.length &gt;= maxFrames) return;
    console.log(&quot;click&quot;);
    frames.push({});
    frames = frames;
    await changeFrame(frames.length - 1);
    let framebar = document.getElementById(&quot;frame-bar&quot;);
    framebar.scrollTo({ left: 0, top: framebar.scrollHeight });
  }

  function playFrames() {
    if (currentFrame &lt; frames.length - 1) currentFrame++;
    else currentFrame = 0;

    changeFrame(currentFrame);
  }
  let playint;

  function setPlay(bool) {
    if (bool) {
      playint = window.setInterval(playFrames, 500);
    } else {
      window.clearInterval(playint);
    }
  }

  ///////////////////// select functions /////////////////////////////////
  function Copy() {
    // clone what are you copying since you
    // may want copy and paste on different moment.
    // and you do not want the changes happened
    // later to reflect on the copy.
    canvas.getActiveObject().clone(function (cloned) {
      _clipboard = cloned;
    });
  }

  function Paste() {
    // clone again, so you can do multiple copies.
    _clipboard.clone(function (clonedObj) {
      canvas.discardActiveObject();
      clonedObj.set({
        left: clonedObj.left + 10,
        top: clonedObj.top + 10,
        evented: true,
      });
      if (clonedObj.type === &quot;activeSelection&quot;) {
        // active selection needs a reference to the canvas.
        clonedObj.canvas = canvas;
        clonedObj.forEachObject(function (obj) {
          canvas.add(obj);
        });
        // this should solve the unselectability
        clonedObj.setCoords();
      } else {
        canvas.add(clonedObj);
      }
      _clipboard.top += 10;
      _clipboard.left += 10;
      canvas.setActiveObject(clonedObj);
      canvas.requestRenderAll();
    });
  }

  function Delete() {
    // clone what are you copying since you
    // may want copy and paste on different moment.
    // and you do not want the changes happened
    // later to reflect on the copy.
    var curSelectedObjects = canvas.getActiveObjects();
    canvas.discardActiveObject();
    for (var i = 0; i &lt; curSelectedObjects.length; i++) {
      canvas.remove(curSelectedObjects[i]);
    }
  }

  /////////////// select functions end //////////////////

  ///////////////////// stop motion functies end //////////////////////////////

  //////////////////// avatar functies /////////////////////////////////

  if (appType == &quot;avatar&quot;) {
    maxFrames = 5;
  }

  async function createAvatar() {
    let size = 1024;
    savecanvas.setHeight(size);
    savecanvas.setWidth(size * frames.length);
    savecanvas.renderAll();
    savecanvas.clear();
    let data = { objects: [] };

    for (let i = 0; i &lt; frames.length; i++) {
      frames[i].backgroundImage = {};
      const newFrames = frames[i].objects.map((object, index) =&gt; {
        //if (object.type == &quot;image&quot;) return;
        const newObject = { ...object };
        newObject.top = newObject.top;
        newObject.left += size * i;
        // newObject.scaleX = scaleRatio/1024;
        // newObject.scaleY = scaleRatio/1024;
        data.objects.push(newObject);
      });
    }
    FrameObject.left = 0;
    // data.objects = [{ ...FrameObject }].concat(data.objects);

    console.log(&quot;data&quot;, data);

    await savecanvas.loadFromJSON(data, savecanvas.renderAll.bind(savecanvas));
    await savecanvas.calcOffset();

    //var Image = savecanvas.toDataURL(&quot;image/png&quot;, 0.2);
    // console.log(Image);
    // var blobData = dataURItoBlob(Image);
    setTimeout(async () =&gt; {
      var Image = savecanvas.toDataURL(&quot;image/png&quot;, 1);
      var blobData = dataURItoBlob(Image);
      json = JSON.stringify(frames);
      Image = await uploadAvatar(blobData, json, version);
    }, 5000);
  }

  async function createStopmotion() {
    console.log(&quot;111&quot;);
    // console.log(&quot;saved&quot;);
    json = JSON.stringify(frames);
    // console.log(&quot;json&quot;, json);
    // var blobData = dataURItoBlob(frames);
    // uploadImage(title, appType, json, blobData, status);
    let size = 1024;
    savecanvas.setHeight(size);
    savecanvas.setWidth(size * frames.length);
    savecanvas.renderAll();
    savecanvas.clear();
    let data = { objects: [] };

    for (let i = 0; i &lt; frames.length; i++) {
      frames[i].backgroundImage = {};
      const newFrames = frames[i].objects.map((object, index) =&gt; {
        //if (object.type == &quot;image&quot;) return;
        const newObject = { ...object };
        newObject.top = newObject.top;
        newObject.left += size * i;
        // newObject.scaleX = scaleRatio/1024;
        // newObject.scaleY = scaleRatio/1024;
        data.objects.push(newObject);
      });
    }
    FrameObject.left = 0;
    // data.objects = [{ ...FrameObject }].concat(data.objects);

    // console.log(&quot;data&quot;, data);

    savecanvas.loadFromJSON(data, async () =&gt; {
      console.log(&quot;222&quot;);
      savecanvas.renderAll.bind(savecanvas);
      savecanvas.calcOffset();

      var saveImage = await savecanvas.toDataURL(&quot;image/png&quot;, 1);
      // console.log(&quot;savedImage&quot;, saveImage);

      var blobData = dataURItoBlob(saveImage);
      // console.log(&quot;blobData&quot;, blobData);
      if (!!!title) {
        title = Date.now() + &quot;_&quot; + displayName;
      }
      await uploadImage(
        title,
        appType,
        blobData,
        status,
        version,
        displayName
      ).then((url) =&gt; {
        console.log(&quot;333&quot;);
        savedURL = url;
        console.log(&quot;savedURL stopmotion&quot;, savedURL);
        // saving = false;
        setLoader(false);
      });
      //Profile.update(n =&gt; n.url = Image);
    });
  }

  //////////////////// avatar functies end /////////////////////////////////

  //////////////////// camera functies ///////////////////////////////
  function camera() {
    current = &quot;camera&quot;;

    if (navigator.mediaDevices &amp;&amp; navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then(function (stream) {
          video.srcObject = stream;
          video.play();
        })
        .catch((err) =&gt; {
          console.log(err);
          alert(err);
        });
    }
  }

  async function capturePicture() {
    let videocanv = new fabric.Canvas(videoCanvas, {
      isDrawingMode: false,
    });
    videocanv.setHeight(videoWidth / 1.33);
    videocanv.setWidth(videoWidth);
    let vidContext = videocanv.getContext(&quot;2d&quot;);
    vidContext.drawImage(video, 0, 0, videoWidth, videoWidth / 1.33);
    var uri = videoCanvas.toDataURL(&quot;image/png&quot;, 1);
    fabric.Image.fromURL(uri, function (oImg) {
      oImg.scale(1);
      oImg.set({ left: 0, top: 0 });
      canvas.add(oImg);
    });
    video.srcObject.getTracks()[0].stop();
    current = &quot;select&quot;;
  }

  //////////////////// camera functies end ///////////////////////////

  //////////////////// redo/undo function ///////////////////////////

  const saveHistory = () =&gt; {};

  const undo = () =&gt; {
    let lastObject =
      canvas.toJSON().objects[canvas.toJSON().objects.length - 1];
    history.push(lastObject);
    let newFile = canvas.toJSON();
    newFile.objects.pop();
    canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas));

    // once all previously drawn objects are deleted, isDrawn is set to false
    if (canvas.toJSON().objects.length == 0) {
      isDrawn = false;
    }
  };

  const redo = () =&gt; {
    let newFile = canvas.toJSON();
    newFile.objects.push(history[history.length - 1]);
    history.pop();
    canvas.loadFromJSON(newFile, canvas.renderAll.bind(canvas));

    // once the elements that has been removed are brought back, isDrawn is set back to true
    if (canvas.toJSON().objects.length &gt; 0) {
      isDrawn = true;
    }
  };

  //////////////////// redo/undo function end ///////////////////////////

  /////////////////// fill functie //////////////////////////////////////
  var FloodFill = {
    // Compare subsection of array1's values to array2's values, with an optional tolerance
    withinTolerance: function (array1, offset, array2, tolerance) {
      var length = array2.length,
        start = offset + length;
      tolerance = tolerance || 0;

      // Iterate (in reverse) the items being compared in each array, checking their values are
      // within tolerance of each other
      while (start-- &amp;&amp; length--) {
        if (Math.abs(array1[start] - array2[length]) &gt; tolerance) {
          return false;
        }
      }

      return true;
    },

    // The actual flood fill implementation
    fill: function (
      imageData,
      getPointOffsetFn,
      point,
      color,
      target,
      tolerance,
      width,
      height
    ) {
      var directions = [
          [1, 0],
          [0, 1],
          [0, -1],
          [-1, 0],
        ],
        coords = [],
        points = [point],
        seen = {},
        key,
        x,
        y,
        offset,
        i,
        x2,
        y2,
        minX = -1,
        maxX = -1,
        minY = -1,
        maxY = -1;

      // Keep going while we have points to walk
      while (!!(point = points.pop())) {
        x = point.x;
        y = point.y;
        offset = getPointOffsetFn(x, y);

        // Move to next point if this pixel isn't within tolerance of the color being filled
        if (!FloodFill.withinTolerance(imageData, offset, target, tolerance)) {
          continue;
        }

        if (x &gt; maxX) {
          maxX = x;
        }
        if (y &gt; maxY) {
          maxY = y;
        }
        if (x &lt; minX || minX == -1) {
          minX = x;
        }
        if (y &lt; minY || minY == -1) {
          minY = y;
        }

        // Update the pixel to the fill color and add neighbours onto stack to traverse
        // the fill area
        i = directions.length;
        while (i--) {
          // Use the same loop for setting RGBA as for checking the neighbouring pixels
          if (i &lt; 4) {
            imageData[offset + i] = color[i];
            coords[offset + i] = color[i];
          }

          // Get the new coordinate by adjusting x and y based on current step
          x2 = x + directions[i][0];
          y2 = y + directions[i][1];
          key = x2 + &quot;,&quot; + y2;

          // If new coordinate is out of bounds, or we've already added it, then skip to
          // trying the next neighbour without adding this one
          if (x2 &lt; 0 || y2 &lt; 0 || x2 &gt;= width || y2 &gt;= height || seen[key]) {
            continue;
          }

          // Push neighbour onto points array to be processed, and tag as seen
          points.push({ x: x2, y: y2 });
          seen[key] = true;
        }
      }

      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY,
        coords: coords,
      };
    },
  }; // End FloodFill

  function hexToRgb(hex, opacity) {
    opacity = Math.round(opacity * 255) || 255;
    hex = hex.replace(&quot;#&quot;, &quot;&quot;);
    var rgb = [],
      re = new RegExp(&quot;(.{&quot; + hex.length / 3 + &quot;})&quot;, &quot;g&quot;);
    hex.match(re).map(function (l) {
      rgb.push(parseInt(hex.length % 2 ? l + l : l, 16));
    });
    return rgb.concat(opacity);
  }

  function floodFill(enable) {
    if (!enable) {
      canvas.off(&quot;mouse:down&quot;);
      canvas.selection = true;
      canvas.forEachObject(function (object) {
        object.selectable = true;
      });
      return;
    }

    canvas.discardActiveObject();
    canvas.renderAll();
    canvas.selection = false;
    canvas.forEachObject(function (object) {
      object.selectable = false;
    });

    canvas.on({
      &quot;mouse:down&quot;: function (e) {
        var mouseX = Math.round(e.e.layerX),
          mouseY = Math.round(e.e.layerY),
          //canvas = canvas.lowerCanvasEl,
          context = canvas.getContext(&quot;2d&quot;),
          parsedColor = hexToRgb(fillColor),
          imageData = context.getImageData(0, 0, canvas.width, canvas.height),
          getPointOffset = function (x, y) {
            return 4 * (y * imageData.width + x);
          },
          targetOffset = getPointOffset(mouseX, mouseY),
          target = imageData.data.slice(targetOffset, targetOffset + 4);

        if (FloodFill.withinTolerance(target, 0, parsedColor, fillTolerance)) {
          // Trying to fill something which is (essentially) the fill color
          return;
        }

        // Perform flood fill
        var data = FloodFill.fill(
          imageData.data,
          getPointOffset,
          { x: mouseX, y: mouseY },
          parsedColor,
          target,
          fillTolerance,
          imageData.width,
          imageData.height
        );

        if (0 == data.width || 0 == data.height) {
          return;
        }

        var tmpCanvas = document.createElement(&quot;canvas&quot;),
          tmpCtx = tmpCanvas.getContext(&quot;2d&quot;);
        tmpCanvas.width = canvas.width;
        tmpCanvas.height = canvas.height;

        var palette = tmpCtx.getImageData(
          0,
          0,
          tmpCanvas.width,
          tmpCanvas.height
        ); // x, y, w, h
        palette.data.set(new Uint8ClampedArray(data.coords)); // Assuming values 0..255, RGBA
        tmpCtx.putImageData(palette, 0, 0); // Repost the data.
        var imgData = tmpCtx.getImageData(
          data.x,
          data.y,
          data.width,
          data.height
        ); // Get cropped image

        tmpCanvas.width = data.width;
        tmpCanvas.height = data.height;
        tmpCtx.putImageData(imgData, 0, 0);

        // Convert canvas back to image:
        var img = new Image();
        img.onload = function () {
          canvas.add(
            new fabric.Image(img, {
              left: data.x,
              top: data.y,
              selectable: false,
            })
          );
        };
        img.src = tmpCanvas.toDataURL(&quot;image/png&quot;, 1);

        canvas.add(
          new fabric.Image(tmpCanvas, {
            left: data.x,
            top: data.y,
            selectable: false,
          })
        );
      },
    });
  }

  ///////////////// fill functie end ///////////////////////

  function backgroundHide() {
    showBackground = !showBackground;
    if (!showBackground) {
      for (let i = 0; i &lt; frames.length; i++) {
        frames[i].backgroundImage = {};
      }
      canvas.loadFromJSON(frames[currentFrame], canvas.renderAll.bind(canvas));
      frames = frames;
    } else {
      img.src = backgroundFrames[currentFrame - 1];
    }
  }

  function switchOption(option) {
    if (current === option) {
      optionbox = !optionbox;
    } else {
      optionbox = false;
      current = option;
    }
  }

  let transition = { y: 200, duration: 500 };
  if (window.screen.width &gt;= 600) {
    transition = { x: 200, duration: 500 };
  }
&lt;/script&gt;

&lt;main on:mouseup={mouseEvent}&gt;
  &lt;div class=&quot;main-container&quot;&gt;
    &lt;div class=&quot;canvas-frame-container&quot;&gt;
      {#if current == &quot;camera&quot;}
        &lt;video bind:this={video} autoplay /&gt;
        &lt;button on:click={capturePicture} class=&quot;videoButton&quot; /&gt;
        &lt;div class=&quot;videocanvas&quot;&gt;
          &lt;canvas bind:this={videoCanvas} /&gt;
        &lt;/div&gt;
      {/if}
      &lt;!-- &lt;div class=&quot;topbar&quot;&gt;
      &lt;div&gt;
        &lt;a on:click={undo}&gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-rotate-CCW.svg&quot;&gt;&lt;/a&gt;
        &lt;a on:click={redo}&gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-rotate-CW.svg&quot;&gt;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt; --&gt;
      &lt;div class=&quot;canvas-box&quot; class:hidden={current === &quot;camera&quot;}&gt;
        &lt;canvas bind:this={canv} class=&quot;canvas&quot; /&gt;
        &lt;canvas bind:this={Cursor} id=&quot;cursor&quot; /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;savecanvas&quot;&gt;
        &lt;canvas bind:this={saveCanvas} /&gt;
      &lt;/div&gt;
      &lt;div class=&quot;frame-box&quot;&gt;
        {#if appType == &quot;stopmotion&quot; || appType == &quot;avatar&quot;}
          &lt;div id=&quot;frame-bar&quot;&gt;
            {#each frames as frame, index}
              &lt;div&gt;
                &lt;div
                  id={index}
                  class:selected={currentFrame === index}
                  on:click={() =&gt; {
                    changeFrame(index);
                    console.log(&quot;debug index of frame:&quot;, index); //remove debug
                  }}
                  style=&quot;background-image: url({backgroundFrames[index]})&quot;
                &gt;
                  &lt;div&gt;{index + 1}&lt;/div&gt;
                &lt;/div&gt;
                {#if currentFrame === index &amp;&amp; frames.length &gt; 1}
                  &lt;img
                    class=&quot;icon&quot;
                    on:click={() =&gt; {
                      deleteFrame(index);
                    }}
                    src=&quot;assets/SHB/svg/AW-icon-trash.svg&quot;
                  /&gt;
                {/if}
              &lt;/div&gt;
            {/each}
            {#if frames.length &lt; maxFrames}
              &lt;div&gt;
                &lt;div id=&quot;frameNew&quot; on:click={addFrame}&gt;&lt;div&gt;+&lt;/div&gt;&lt;/div&gt;
              &lt;/div&gt;
            {/if}
          &lt;/div&gt;
          &lt;div class=&quot;frame-buttons&quot;&gt;
            {#if play}
              &lt;a
                id=&quot;playPause&quot;
                on:click={() =&gt; {
                  play = false;
                  setPlay(false);
                }}
                &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-pause.svg&quot; /&gt;&lt;/a
              &gt;
            {:else}
              &lt;a
                id=&quot;playPause&quot;
                on:click={() =&gt; {
                  play = true;
                  setPlay(true);
                }}&gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-play.svg&quot; /&gt;&lt;/a
              &gt;
            {/if}
            &lt;a on:click={backgroundHide}
              &gt;&lt;img
                class=&quot;icon&quot;
                class:unselected={!showBackground}
                src=&quot;assets/SHB/svg/AW-icon-onion.svg&quot;
              /&gt;&lt;/a
            &gt;
          &lt;/div&gt;
        {/if}
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;optionbox-container&quot;&gt;
    &lt;div class=&quot;optionbox&quot;&gt;
      &lt;div class=&quot;optionbar&quot; class:hidden={optionbox}&gt;
        &lt;div class=&quot;colorTab&quot; class:hidden={current != &quot;draw&quot;}&gt;
          &lt;div class=&quot;drawing-options-container&quot;&gt;
            &lt;img
              on:click={() =&gt; applyBrush(&quot;Pencil&quot;)}
              class=&quot;icon&quot;
              class:selected={selectedBrush == &quot;Pencil&quot;}
              src=&quot;assets/svg/drawing_pencil2.svg&quot;
            /&gt;
            &lt;img
              on:click={() =&gt; applyBrush(&quot;Circle&quot;)}
              class=&quot;icon&quot;
              class:selected={selectedBrush == &quot;Circle&quot;}
              src=&quot;assets/svg/drawing_circle2.svg&quot;
            /&gt;
            &lt;img
              on:click={() =&gt; applyBrush(&quot;Spray&quot;)}
              class=&quot;icon&quot;
              class:selected={selectedBrush == &quot;Spray&quot;}
              src=&quot;assets/svg/drawing_spray.svg&quot;
            /&gt;
            &lt;img
              on:click={() =&gt; applyBrush(&quot;Pattern&quot;)}
              class=&quot;icon&quot;
              class:selected={selectedBrush == &quot;Pattern&quot;}
              src=&quot;assets/svg/drawing_pattern.svg&quot;
            /&gt;
          &lt;/div&gt;
          &lt;!-- &lt;div id=&quot;drawing-mode-options&quot;&gt;
            &lt;select id=&quot;drawing-mode-selector&quot;&gt;
              &lt;option&gt;Pencil&lt;/option&gt;
              &lt;option&gt;Circle&lt;/option&gt;
              &lt;option&gt;Spray&lt;/option&gt;
              &lt;option&gt;Pattern&lt;/option&gt;

              &lt;option&gt;hline&lt;/option&gt;
              &lt;option&gt;vline&lt;/option&gt;
              &lt;option&gt;square&lt;/option&gt;
              &lt;option&gt;diamond&lt;/option&gt;
              &lt;option&gt;texture&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt; --&gt;
          &lt;!-- &lt;div
          class=&quot;widthBox&quot;
          style=&quot;background-color: {drawingColor};&quot;
          on:click={() =&gt; {
            drawingColorEl.click();
          }}
        &gt;

        &lt;/div&gt; --&gt;
          &lt;input
            type=&quot;color&quot;
            bind:value={drawingColor}
            bind:this={drawingColorEl}
            id=&quot;drawing-color&quot;
          /&gt;
          &lt;!-- &lt;img class=&quot;colorIcon&quot; src=&quot;assets/SHB/svg/AW-icon-paint.svg&quot; /&gt; --&gt;

          &lt;!-- &lt;span class=&quot;info&quot;&gt;{lineWidth}&lt;/span&gt; --&gt;
          &lt;div class=&quot;range-container&quot;&gt;
            &lt;div class=&quot;circle-box-small&quot; /&gt;
            &lt;input
              type=&quot;range&quot;
              min=&quot;10&quot;
              max=&quot;500&quot;
              id=&quot;drawing-line-width&quot;
              bind:value={lineWidth}
            /&gt;
            &lt;div class=&quot;circle-box-big&quot; /&gt;
          &lt;/div&gt;

          &lt;!-- &lt;label for=&quot;drawing-shadow-color&quot;&gt;Shadow color:&lt;/label&gt;
        &lt;input
          type=&quot;color&quot;
          bind:value={shadowColor}
          id=&quot;drawing-shadow-color&quot;
        /&gt;

        &lt;label for=&quot;drawing-shadow-width&quot;&gt;Shadow width:&lt;/label&gt;
        &lt;span class=&quot;info&quot;&gt;0&lt;/span&gt;&lt;input
          type=&quot;range&quot;
          bind:value={shadowWidth}
          min=&quot;0&quot;
          max=&quot;50&quot;
          id=&quot;drawing-shadow-width&quot;
        /&gt;

        &lt;label for=&quot;drawing-shadow-offset&quot;&gt;Shadow offset:&lt;/label&gt;
        &lt;span class=&quot;info&quot;&gt;0&lt;/span&gt;&lt;input
          type=&quot;range&quot;
          bind:value={shadowOffset}
          min=&quot;0&quot;
          max=&quot;50&quot;
          id=&quot;drawing-shadow-offset&quot;
        /&gt; --&gt;
        &lt;/div&gt;
        &lt;div class=&quot;eraseTab&quot; class:hidden={current != &quot;erase&quot;}&gt;
          &lt;!-- &lt;div class=&quot;widthBox&quot;&gt;
            &lt;div
              class=&quot;lineWidth&quot;
              style=&quot;background-color: black;margin:  0px auto;&quot;
            /&gt;
          &lt;/div&gt;
          &lt;span class=&quot;info&quot;&gt;{lineWidth}&lt;/span&gt; --&gt;
          &lt;div class=&quot;range-container&quot;&gt;
            &lt;div class=&quot;circle-box-small&quot; /&gt;
            &lt;input
              type=&quot;range&quot;
              min=&quot;10&quot;
              max=&quot;500&quot;
              id=&quot;erase-line-width&quot;
              bind:value={lineWidth}
            /&gt;
            &lt;div class=&quot;circle-box-big&quot; /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;fillTab&quot; class:hidden={current != &quot;fill&quot;}&gt;
          &lt;input type=&quot;color&quot; bind:value={fillColor} id=&quot;fill-color&quot; /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;selectTab&quot; class:hidden={current != &quot;select&quot;}&gt;
          &lt;a on:click={Copy}
            &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-copy.svg&quot; /&gt;&lt;/a
          &gt;
          &lt;a on:click={Paste}
            &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-paste.svg&quot; /&gt;&lt;/a
          &gt;
          &lt;a on:click={Delete}
            &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-trash.svg&quot; /&gt;&lt;/a
          &gt;
        &lt;/div&gt;
        &lt;div class=&quot;saveBox&quot; class:hidden={current != &quot;saveToggle&quot;}&gt;
          &lt;div class=&quot;saveTab&quot;&gt;
            {#if appType != &quot;avatar&quot; &amp;&amp; appType != &quot;house&quot;}
              &lt;label for=&quot;title&quot;&gt;Title&lt;/label&gt;
              &lt;NameGenerator
                bind:value={displayName}
                bind:invalidTitle
                bind:isTitleChanged
              /&gt;
            {/if}
            &lt;!-- &lt;label for=&quot;status&quot;&gt;Status&lt;/label&gt;
              &lt;select bind:value={status} on:change={() =&gt; (answer = &quot;&quot;)}&gt;
                {#each statussen as status}
                  &lt;option value={status}&gt;
                    {status}
                  &lt;/option&gt;
                {/each}
              &lt;/select&gt; --&gt;
            &lt;div class=&quot;status-save-download-container&quot;&gt;
              {#if appType != &quot;avatar&quot; &amp;&amp; appType != &quot;house&quot;}
                &lt;div on:click={changeVisibility}&gt;
                  {#if status}
                    &lt;img
                      class=&quot;icon selected&quot;
                      src=&quot;assets/SHB/svg/AW-icon-visible.svg&quot;
                    /&gt;
                  {:else}
                    &lt;img
                      class=&quot;icon selected&quot;
                      src=&quot;assets/SHB/svg/AW-icon-invisible.svg&quot;
                    /&gt;
                  {/if}
                &lt;/div&gt;
              {/if}

              &lt;div&gt;
                &lt;!-- {#if saving} --&gt;
                &lt;!-- &lt;img
                    on:click={upload}
                    class=&quot;icon selected&quot;
                    src=&quot;assets/SHB/svg/AW-icon-history.svg&quot;
                  /&gt; --&gt;
                &lt;!-- {:else if saved} --&gt;
                &lt;img
                  on:click={upload}
                  class=&quot;icon selected&quot;
                  src=&quot;assets/SHB/svg/AW-icon-check.svg&quot;
                /&gt;
                &lt;!-- {/if} --&gt;
              &lt;/div&gt;
              &lt;!-- &lt;button on:click={upload}
              &gt;{#if saving}Saving{:else if saved}
                Saved{:else}Save{/if}&lt;/button
            &gt; --&gt;
              &lt;div&gt;
                &lt;!-- {#if saved} --&gt;
                &lt;img
                  on:click={download}
                  class=&quot;icon selected&quot;
                  src=&quot;assets/SHB/svg/AW-icon-save.svg&quot;
                /&gt;
                &lt;!-- {/if} --&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;!-- {#if saved}
              &lt;button &gt;Download&lt;/button&gt;
            {/if} --&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;iconbox&quot;&gt;
        &lt;a on:click={undo}
          &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-rotate-CCW.svg&quot; /&gt;&lt;/a
        &gt;
        &lt;a on:click={redo}
          &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-rotate-CW.svg&quot; /&gt;&lt;/a
        &gt;
        &lt;a
          on:click={applyBrush}
          id=&quot;drawing-mode&quot;
          class:currentSelected={current === &quot;draw&quot;}
          &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-pen.svg&quot; /&gt;&lt;/a
        &gt;
        &lt;a id=&quot;erase-mode&quot; class:currentSelected={current === &quot;erase&quot;}
          &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-erase.svg&quot; /&gt;&lt;/a
        &gt;
        &lt;!-- &lt;button
        class=&quot;icon&quot;
        id=&quot;fill-mode&quot;
        class:currentSelected={current === &quot;fill&quot;}&gt;&lt;BucketIcon /&gt;&lt;/button
      &gt; --&gt;
        &lt;a id=&quot;select-mode&quot; class:currentSelected={current === &quot;select&quot;}
          &gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-pointer.svg&quot; /&gt;&lt;/a
        &gt;
        &lt;!-- {#if &quot;mediaDevices&quot; in navigator &amp;&amp; &quot;getUserMedia&quot; in navigator.mediaDevices}
        &lt;button
          class=&quot;icon&quot;
          id=&quot;camera-mode&quot;
          class:currentSelected={current == &quot;camera&quot;}
          on:click={camera}&gt;&lt;CameraIcon /&gt;&lt;/button
        &gt;
      {/if} --&gt;
        &lt;!-- &lt;button id=&quot;clear-canvas&quot; class=&quot;btn btn-info icon&quot;&gt;
        &lt;TrashIcon /&gt;
      &lt;/button&gt; --&gt;

        &lt;!-- svelte-ignore a11y-missing-attribute --&gt;
        &lt;a
          class:currentSelected={current === &quot;saveToggle&quot;}
          on:click={() =&gt; {
            // console.log(&quot;saving is clicked&quot;);
            // console.log(&quot;length&quot;, canvas.toJSON().objects);
            if (
              appType == &quot;drawing&quot; ||
              appType == &quot;stopmotion&quot; ||
              appType == &quot;house&quot; ||
              appType == &quot;avatar&quot;
            ) {
              saveToggle = !saveToggle;
              switchOption(&quot;saveToggle&quot;);
            }
          }}&gt;&lt;img class=&quot;icon&quot; src=&quot;assets/SHB/svg/AW-icon-save.svg&quot; /&gt;&lt;/a
        &gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=&quot;clear-canvas&quot;&gt;&lt;img src=&quot;assets/SHB/svg/AW-icon-reset.svg&quot; /&gt;&lt;/div&gt;
  {#if appType == &quot;avatar&quot;}
    &lt;div id=&quot;avatarBox&quot;&gt;
      &lt;Avatar /&gt;
    &lt;/div&gt;
  {/if}
&lt;/main&gt;

&lt;style&gt;
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  .main-container {
    display: flex;
    align-items: center;
    margin-left: 60px;
    justify-content: flex-end;
    /* justify-content: space-around; */
    margin: 20px 20px 0 0;
  }

  #cursor {
    pointer-events: none !important;
    width: 100vw;
    height: 100vw;
    margin: 0px;
    position: absolute;
    user-select: none;
    top: 0px;
    left: 0px;
    pointer-events: none;
  }

  .topbar {
    width: 100vw;
    margin: 0px auto;
  }

  .selected {
    box-shadow: 3px 3px #7300ed;
  }

  .colorTab {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .saveTab {
    min-width: 160px;
    bottom: 50px;
    z-index: 1;
  }

  .savecanvas {
    display: none;
  }

  .saveTab &gt; * {
    padding: 12px 16px;
    text-decoration: none;
    display: block;
  }
  .saveBox {
    position: relative;
    display: inline-block;
  }

  .saveBox:hover .saveTab {
    display: block;
    color: green;
  }

  .iconbox {
    width: 50px;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    flex-wrap: wrap;
    transition: all 0.5s ease-in-out;
  }

  .optionbar {
    margin-left: 10px;
    border-right: 2px solid #7300ed;
    /* box-shadow: 10px 0px 5px 0px rgba(115,0,237,0.5); */
    height: 100vh;
    background-color: white;
    transition: all 0.5s ease-in-out;
    width: fit-content;
    padding: 15px;
    transform: translateX(0%);
    width: 280px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    flex-wrap: wrap;
  }

  .optionbar.hidden {
    width: 0px;
    transform: translateX(-160%);
    display: inline;
    padding: 0px;
    margin: 0px;
  }

  .optionbar.hidden &gt; * {
    display: none;
  }

  .optionbar &gt; * {
    /* margin: 5px auto; */
  }

  .icon {
    min-width: 50px;
    height: 50px;
    border-radius: 50%;
    padding: 5px 0px 5px 0px;
    cursor: pointer;
  }

  #drawing-color,
  #drawing-shadow-color {
    padding: 0px;
    display: block;
    margin: 20px auto;
  }

  .optionbox {
    width: fit-content;
    display: flex;
  }

  .currentSelected {
    box-shadow: 0px 4px #7300ed;
    border-radius: 0% 50% 50% 0;
    height: 60px;
    display: block;
    width: 49px;
    padding: 0px;
    background-color: white;
    margin-left: -5px;
  }

  .hidden {
    display: none;
  }

  .videoButton {
    border-radius: 50%;
    padding: 25px;
    margin: 0 auto;
    background: red;
    display: block;
  }

  .lineWidth {
    border-radius: 50%;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  .range-container {
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-items: center;
  }

  .circle-box-small {
    border: solid 2px black;
    border-radius: 50%;
    padding: 5px;
  }

  .circle-box-big {
    border: solid 2px black;
    border-radius: 50%;
    padding: 10px;
  }

  input[type=&quot;range&quot;] {
    -webkit-appearance: none;
    -moz-apperance: none;
    border-radius: 6px;
    border: 4px solid #7300ed;
    height: 4px;
    margin: 0 10px;
  }

  input[type=&quot;range&quot;]::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    background-color: black;
    border: 1px solid black;
    border-radius: 50%;
    height: 15px;
    width: 15px;
  }

  /* .colorIcon {
    width: 32px;
    position: absolute;
    right: 5px;
    bottom: 5px;
  } */

  .canvas-box {
    position: relative;
    background-color: white;
    border: 2px solid #7300ed;
  }

  .frame-box {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    flex-direction: column;
  }

  #frame-bar {
    display: flex;
    flex-direction: column;
    max-height: 300px;
    width: 130px;
    overflow-y: auto;
    overscroll-behavior-y: contain;
    scroll-snap-type: y proximity;
  }
  #frame-bar &gt; div {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: row;
  }

  #frame-bar &gt; div &gt; div {
    display: inline-block;
    width: 60px;
    height: 60px;
    margin: 5px;
    border: 2px solid #7300eb;
    font-size: 30px;
    text-align: center;
    background-position: center;
    background-repeat: no-repeat;
    background-size: contain;
  }

  #frame-bar &gt; div &gt; div:hover {
    cursor: pointer;
  }

  #frame-bar &gt; div &gt; div &gt; div {
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .frame-buttons {
    display: flex;
    flex-direction: column;
  }

  .frame-buttons &gt; a &gt; img {
    display: block;
  }

  #clear-canvas {
    position: fixed;
    left: 8px;
    top: 80px;
    z-index: 13;
    box-shadow: 5px 5px 0px #7300ed;
    cursor: pointer;
    padding: 0;
    margin: 0;
    border-radius: 50%;
    width: 40px;
    height: 40px;
  }

  #clear-canvas &gt; img {
    width: 40px;
  }

  video {
    margin: 0 auto;
    display: block;
  }

  .canvas-frame-container {
    display: flex;
    flex-direction: row;
  }

  .topbar {
    width: unset;
  }

  .topbar {
    float: left;
    height: 100vh;
  }

  .topbar &gt; div {
    display: inline-grid;
    position: relative;
    top: 50%;
    margin: 10px;
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
  }

  #frame-bar &gt; div:last-child {
    overflow-anchor: auto;
  }

  .optionbox-container {
    margin: 0 10px 0 0;
    position: fixed;
    left: 0;
    top: 50vh;
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
  }

  .unselected {
    filter: grayscale(1) opacity(0.5);
  }

  #avatarBox {
    position: fixed;
    top: 130px;
    left: 20px;
  }

  .drawing-options-container {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
  }

  .status-save-download-container {
    display: flex;
    flex-direction: column;
    /* justify-content: center; */
    /* align-items: center; */
    height: min-content;
  }

  /* medium size */
  @media only screen and (max-width: 1007px) {
    .canvas-frame-container {
      flex-direction: column;
    }

    .frame-box {
      flex-direction: row;
    }

    #frame-bar {
      flex-direction: row;
      width: 250px;
      overflow-x: auto;
      overflow-y: none;
      overscroll-behavior-x: contain;
      scroll-snap-type: x proximity;
    }

    #frame-bar &gt; div {
      flex-direction: column;
    }

    .frame-buttons {
      flex-direction: row;
    }
  }

  /* small */
  @media only screen and (max-width: 640px) {
    .main-container {
      display: unset;
      align-items: unset;
      margin: 0;
    }

    .canvas-frame-container {
      justify-content: center;
      align-items: center;
    }

    .canvas-box {
      order: 2;
    }

    .frame-box {
      order: 1;
      flex-direction: row;
      /* width: 100%; */
      justify-content: space-between;
      /* align-self: flex-end; */
    }

    #frame-bar {
      max-width: 300px;
      height: 140px;
      margin-right: 10px;
    }

    #frame-bar &gt; div {
      flex-direction: column-reverse;
    }

    .frame-buttons {
      flex-direction: column-reverse;
      margin: unset;
      align-self: center;
    }

    .optionbox {
      width: 100%;
      height: min-content;
      position: fixed;
      bottom: 0;
      display: block;
    }

    .optionbar {
      margin: 0;
      border-right: none;
      border-top: 2px solid #7300ed;
      box-shadow: 0px -5px 5px 0px #7300ed;
      height: min-content;
      width: 100%;
      padding: 0px;
      transition: none;
      animation: growup 0.3s ease-in-out forwards;
      transform-origin: bottom center;
      position: sticky;
      z-index: 40;
      align-items: flex-end;
    }

    .optionbar &gt; * {
      margin: 20px 50px 20px 0;
    }

    .status-save-download-container {
      flex-direction: row;
      justify-content: space-between;
    }

    @keyframes growup {
      0% {
        transform: scaleY(0);
      }
      80% {
        transform: scaleY(1.1);
      }
      100% {
        transform: scaleY(1);
      }
    }

    .optionbar.hidden {
      margin: 0;
      border-right: none;
      height: min-content;
      width: auto;
      transform: none;
      display: inline;
      animation: growdown 2s ease-in-out forwards;
    }

    @keyframes growdown {
      0% {
        transform: scaleY(1);
      }
      50% {
        transform: scaleY(0.5);
      }
      100% {
        transform: scaleY(0);
      }
    }

    .optionbox-container {
      position: fixed;
      -ms-transform: initial;
      transform: initial;
    }

    .currentSelected {
      display: inline;
    }

    .iconbox {
      width: max-content;
      height: min-content;
      display: block;
      margin: 0 auto;
    }

    .currentSelected &gt; img {
      border: 2px solid #7300ed;
    }
    .currentSelected {
      box-shadow: unset;
    }

    #clear-canvas {
      top: unset;
      bottom: 60px;
    }
  }
&lt;/style&gt;
</code></pre>
<p>Het gaat vooral om deze componenten:</p>
<pre><code>    let FrameObject = {
    type: &quot;image&quot;,
    version: &quot;4.6.0&quot;,
    originX: &quot;left&quot;,
    originY: &quot;top&quot;,
    left: -1024,
    top: 0,
    width: 0,
    height: 1024,
    fill: &quot;rgb(0,0,0)&quot;,
    stroke: null,
    strokeWidth: 0,
    strokeDashArray: null,
    strokeLineCap: &quot;butt&quot;,
    strokeDashOffset: 0,
    strokeLineJoin: &quot;miter&quot;,
    strokeUniform: false,
    strokeMiterLimit: 4,
    scaleX: 1,
    scaleY: 1,
    angle: 0,
    flipX: false,
    flipY: false,
    opacity: 1,
    shadow: null,
    visible: true,
    backgroundColor: &quot;&quot;,
    fillRule: &quot;nonzero&quot;,
    paintFirst: &quot;fill&quot;,
    globalCompositeOperation: &quot;source-over&quot;,
    skewX: 0,
    skewY: 0,
    erasable: true,
    cropX: 0,
    cropY: 0,
    src: &quot;&quot;,
    crossOrigin: &quot;anonymous&quot;,
    filters: [],
  };

  const updateFrame = () =&gt; {
    frames[currentFrame] = canvas.toJSON();
    console.log(&quot;currentFrame&quot;, currentFrame)
    frames = frames;

    backgroundFrames[currentFrame] = canvas.toDataURL(&quot;image/png&quot;, 1);
    backgroundFrames = backgroundFrames;
  };


  lastImg = await convertImage(Object.value.url); // dit moet ingeladen worden zonder convertImage, maar met de raw versie
      isPreexistingArt = true;

  let frameAmount;
      var framebuffer = new Image();
      framebuffer.src = lastImg;
      framebuffer.onload = function () {
        console.log(&quot;img&quot;, this.width);
        lastWidth = this.width;
        frameAmount = lastWidth / 2048;

        FrameObject.src = lastImg;
        FrameObject.width = lastWidth;
        frames = [];
        for (let i = 0; i &lt; frameAmount; i++) {
          FrameObject.left = 0;
          FrameObject.width = 2048;
          FrameObject.cropX = i * 2048;
          frames.push({
            version: &quot;4.6.0&quot;,
            objects: [{ ...FrameObject }],
          });
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../Bug-tracking-100-cpu-usage/" class="btn btn-neutral float-left" title="Log: bug tracking 100% CPU usage"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../Cors-error-on-retrieving-images/" class="btn btn-neutral float-right" title="Log: cors error on retrieving images">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../Bug-tracking-100-cpu-usage/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../Cors-error-on-retrieving-images/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../../..";</script>
    <script src="../../../js/theme_extra.js"></script>
    <script src="../../../js/theme.js"></script>
      <script src="../../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
